<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PHONE MANAGEMENT: UI-UX/SFML/include/lzma/base.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PHONE MANAGEMENT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_669fb1e37e108424641b4492fae48a00.html">UI-UX</a></li><li class="navelem"><a class="el" href="dir_fef68780f280e2b18cfa5347c2a48e1f.html">SFML</a></li><li class="navelem"><a class="el" href="dir_ab5abbf355e63c20d9132dc628d44eb6.html">include</a></li><li class="navelem"><a class="el" href="dir_40a6e693a8331efa19c2f3d27b8cdc28.html">lzma</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">base.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Data types and functions used in many places in liblzma API.  
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="base_8h__dep__incl.png" border="0" usemap="#UI-UX_2SFML_2include_2lzma_2base_8hdep" alt=""/></div>
<map name="UI-UX_2SFML_2include_2lzma_2base_8hdep" id="UI-UX_2SFML_2include_2lzma_2base_8hdep">
<area shape="rect" title="Data types and functions used in many places in liblzma API." alt="" coords="5,5,156,47"/>
<area shape="rect" href="lzma_8h_source.html" title=" " alt="" coords="5,95,156,136"/>
</map>
</div>
</div>
<p><a href="base_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__allocator.html">lzma_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom functions for memory handling.  <a href="structlzma__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__stream.html">lzma_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passing data to and from liblzma.  <a href="structlzma__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af31f0c8b6f14359cd082b9559f7f3e01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="base_8h.html#af31f0c8b6f14359cd082b9559f7f3e01">LZMA_STREAM_INIT</a></td></tr>
<tr class="memdesc:af31f0c8b6f14359cd082b9559f7f3e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a>.  <a href="base_8h.html#af31f0c8b6f14359cd082b9559f7f3e01">More...</a><br /></td></tr>
<tr class="separator:af31f0c8b6f14359cd082b9559f7f3e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abbc819c74b484c846825ae1388a50a59"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a></td></tr>
<tr class="memdesc:abbc819c74b484c846825ae1388a50a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean.  <a href="base_8h.html#abbc819c74b484c846825ae1388a50a59">More...</a><br /></td></tr>
<tr class="separator:abbc819c74b484c846825ae1388a50a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a60127c640135687a5bcc232cec906"><td class="memItemLeft" align="right" valign="top">typedef struct lzma_internal_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="base_8h.html#ab1a60127c640135687a5bcc232cec906">lzma_internal</a></td></tr>
<tr class="memdesc:ab1a60127c640135687a5bcc232cec906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal data structure.  <a href="base_8h.html#ab1a60127c640135687a5bcc232cec906">More...</a><br /></td></tr>
<tr class="separator:ab1a60127c640135687a5bcc232cec906"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a05805a07754b2aa22f7d443eb7ece41a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="base_8h.html#a05805a07754b2aa22f7d443eb7ece41a">lzma_reserved_enum</a> { <b>LZMA_RESERVED_ENUM</b> = 0
 }</td></tr>
<tr class="memdesc:a05805a07754b2aa22f7d443eb7ece41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of reserved enumeration variable in structures.  <a href="base_8h.html#a05805a07754b2aa22f7d443eb7ece41a">More...</a><br /></td></tr>
<tr class="separator:a05805a07754b2aa22f7d443eb7ece41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8494e0457e1463d6d2b6836018d87b6e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a> { <br />
&#160;&#160;<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe">LZMA_OK</a> = 0, 
<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea91ecc6fab14c13ad36224afbcb4e55c4">LZMA_STREAM_END</a> = 1, 
<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa720d30092d504d7d138a320db1905ef">LZMA_NO_CHECK</a> = 2, 
<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea989f393a1772d85bf545a9da48fc7ac2">LZMA_UNSUPPORTED_CHECK</a> = 3, 
<br />
&#160;&#160;<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa5b648c18da0f584f621cfdf7fef1bdb">LZMA_GET_CHECK</a> = 4, 
<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea567e1464feca03900a5425fb45b2f5b6">LZMA_MEM_ERROR</a> = 5, 
<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa1d705effe6026f32c0fe9756b6326bc">LZMA_MEMLIMIT_ERROR</a> = 6, 
<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea63b7a58949854eb9307f8e351358d56c">LZMA_FORMAT_ERROR</a> = 7, 
<br />
&#160;&#160;<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6eaa9ff6dfee36b7aba4fae60706d37425f">LZMA_OPTIONS_ERROR</a> = 8, 
<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb">LZMA_DATA_ERROR</a> = 9, 
<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea9ca0ecb62459bdc84d6af47d16b23ae5">LZMA_BUF_ERROR</a> = 10, 
<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2">LZMA_PROG_ERROR</a> = 11, 
<br />
&#160;&#160;<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6ea6cf28e5345851f13bd798a4eab8cc939">LZMA_SEEK_NEEDED</a> = 12, 
<b>LZMA_RET_INTERNAL1</b> = 101, 
<b>LZMA_RET_INTERNAL2</b> = 102, 
<b>LZMA_RET_INTERNAL3</b> = 103, 
<br />
&#160;&#160;<b>LZMA_RET_INTERNAL4</b> = 104, 
<b>LZMA_RET_INTERNAL5</b> = 105, 
<b>LZMA_RET_INTERNAL6</b> = 106, 
<b>LZMA_RET_INTERNAL7</b> = 107, 
<br />
&#160;&#160;<b>LZMA_RET_INTERNAL8</b> = 108
<br />
 }</td></tr>
<tr class="memdesc:a8494e0457e1463d6d2b6836018d87b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return values used by several functions in liblzma.  <a href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">More...</a><br /></td></tr>
<tr class="separator:a8494e0457e1463d6d2b6836018d87b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92efcbf3cecfcac79c81fc645fce77e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77e">lzma_action</a> { <br />
&#160;&#160;<a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1">LZMA_RUN</a> = 0, 
<a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea14d75152afcda85d215e877fdd9c4170">LZMA_SYNC_FLUSH</a> = 1, 
<a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77eaab46f0d7c721f1ec377e9575eab2586f">LZMA_FULL_FLUSH</a> = 2, 
<a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77eaf7bf60e3555a4d10ffad3ecc3d2e01f1">LZMA_FULL_BARRIER</a> = 4, 
<br />
&#160;&#160;<a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1">LZMA_FINISH</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:aa92efcbf3cecfcac79c81fc645fce77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 'action' argument for lzma_code()  <a href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77e">More...</a><br /></td></tr>
<tr class="separator:aa92efcbf3cecfcac79c81fc645fce77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a408876aeee9dd3330df165835dd8bfa0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="base_8h.html#a408876aeee9dd3330df165835dd8bfa0">LZMA_API</a> (<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>) lzma_code(<a class="el" href="structlzma__stream.html">lzma_stream</a> *strm</td></tr>
<tr class="memdesc:a408876aeee9dd3330df165835dd8bfa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode or decode data.  <a href="base_8h.html#a408876aeee9dd3330df165835dd8bfa0">More...</a><br /></td></tr>
<tr class="separator:a408876aeee9dd3330df165835dd8bfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a37da2f150216d0bf61e211ed62308"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="base_8h.html#ae0a37da2f150216d0bf61e211ed62308">LZMA_API</a> (void) lzma_end(<a class="el" href="structlzma__stream.html">lzma_stream</a> *strm) lzma_nothrow</td></tr>
<tr class="memdesc:ae0a37da2f150216d0bf61e211ed62308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated for the coder data structures.  <a href="base_8h.html#ae0a37da2f150216d0bf61e211ed62308">More...</a><br /></td></tr>
<tr class="separator:ae0a37da2f150216d0bf61e211ed62308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7de85227aa867358f8f68bb0a358cbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="base_8h.html#ab7de85227aa867358f8f68bb0a358cbc">LZMA_API</a> (uint64_t) lzma_memusage(const <a class="el" href="structlzma__stream.html">lzma_stream</a> *strm) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:ab7de85227aa867358f8f68bb0a358cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory usage of decoder filter chain.  <a href="base_8h.html#ab7de85227aa867358f8f68bb0a358cbc">More...</a><br /></td></tr>
<tr class="separator:ab7de85227aa867358f8f68bb0a358cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a33ff90fbabf4b820c9d765d0f1538624"><td class="memItemLeft" align="right" valign="top"><a id="a33ff90fbabf4b820c9d765d0f1538624"></a>
<a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77e">lzma_action</a> action lzma_nothrow&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_attr_warn_unused_result</b></td></tr>
<tr class="separator:a33ff90fbabf4b820c9d765d0f1538624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec36359721a7b9ad06f2ed8f5770cb03"><td class="memItemLeft" align="right" valign="top"><a id="aec36359721a7b9ad06f2ed8f5770cb03"></a>
uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><b>progress_in</b></td></tr>
<tr class="separator:aec36359721a7b9ad06f2ed8f5770cb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838a8d21f6fa04a1b52a72943b4fd0b2"><td class="memItemLeft" align="right" valign="top"><a id="a838a8d21f6fa04a1b52a72943b4fd0b2"></a>
uint64_t uint64_t *progress_out&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_nothrow</b></td></tr>
<tr class="separator:a838a8d21f6fa04a1b52a72943b4fd0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data types and functions used in many places in liblzma API. </p>
<dl class="section note"><dt>Note</dt><dd>Never include this file directly. Use &lt;<a class="el" href="lzma_8h_source.html">lzma.h</a>&gt; instead. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af31f0c8b6f14359cd082b9559f7f3e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31f0c8b6f14359cd082b9559f7f3e01">&#9670;&nbsp;</a></span>LZMA_STREAM_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_STREAM_INIT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    { NULL, 0, 0, NULL, 0, 0, NULL, NULL, \</div>
<div class="line">    NULL, NULL, NULL, NULL, 0, 0, 0, 0, \</div>
<div class="line">    LZMA_RESERVED_ENUM, LZMA_RESERVED_ENUM }</div>
</div><!-- fragment -->
<p>Initialization for <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a>. </p>
<p>When you declare an instance of <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a>, you can immediately initialize it so that initialization functions know that no memory has been allocated yet: </p><pre class="fragment">lzma_stream strm = LZMA_STREAM_INIT;
</pre><p>If you need to initialize a dynamically allocated <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a>, you can use memset(strm_pointer, 0, sizeof(lzma_stream)). Strictly speaking, this violates the C standard since NULL may have different internal representation than zero, but it should be portable enough in practice. Anyway, for maximum portability, you can use something like this: </p><pre class="fragment">lzma_stream tmp = LZMA_STREAM_INIT;
*strm = tmp;
</pre> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abbc819c74b484c846825ae1388a50a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc819c74b484c846825ae1388a50a59">&#9670;&nbsp;</a></span>lzma_bool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean. </p>
<p>This is here because C89 doesn't have stdbool.h. To set a value for variables having type lzma_bool, you can use</p><ul>
<li>C99's 'true' and 'false' from stdbool.h;</li>
<li>C++'s internal 'true' and 'false'; or</li>
<li>integers one (true) and zero (false). </li>
</ul>

</div>
</div>
<a id="ab1a60127c640135687a5bcc232cec906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a60127c640135687a5bcc232cec906">&#9670;&nbsp;</a></span>lzma_internal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lzma_internal_s <a class="el" href="base_8h.html#ab1a60127c640135687a5bcc232cec906">lzma_internal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal data structure. </p>
<p>The contents of this structure is not visible outside the library. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa92efcbf3cecfcac79c81fc645fce77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92efcbf3cecfcac79c81fc645fce77e">&#9670;&nbsp;</a></span>lzma_action</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="base_8h.html#aa92efcbf3cecfcac79c81fc645fce77e">lzma_action</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The 'action' argument for lzma_code() </p>
<p>After the first use of LZMA_SYNC_FLUSH, LZMA_FULL_FLUSH, LZMA_FULL_BARRIER, or LZMA_FINISH, the same 'action' must be used until lzma_code() returns LZMA_STREAM_END. Also, the amount of input (that is, strm-&gt;avail_in) must not be modified by the application until lzma_code() returns LZMA_STREAM_END. Changing the 'action' or modifying the amount of input will make lzma_code() return LZMA_PROG_ERROR. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa92efcbf3cecfcac79c81fc645fce77ea868472b76492afcaef54020a481890b1"></a>LZMA_RUN&#160;</td><td class="fielddoc"><p>Continue coding. </p>
<p>Encoder: Encode as much input as possible. Some internal buffering will probably be done (depends on the filter chain in use), which causes latency: the input used won't usually be decodeable from the output of the same lzma_code() call.</p>
<p>Decoder: Decode as much input as possible and produce as much output as possible. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa92efcbf3cecfcac79c81fc645fce77ea14d75152afcda85d215e877fdd9c4170"></a>LZMA_SYNC_FLUSH&#160;</td><td class="fielddoc"><p>Make all the input available at output. </p>
<p>Normally the encoder introduces some latency. LZMA_SYNC_FLUSH forces all the buffered data to be available at output without resetting the internal state of the encoder. This way it is possible to use compressed stream for example for communication over network.</p>
<p>Only some filters support LZMA_SYNC_FLUSH. Trying to use LZMA_SYNC_FLUSH with filters that don't support it will make lzma_code() return LZMA_OPTIONS_ERROR. For example, LZMA1 doesn't support LZMA_SYNC_FLUSH but LZMA2 does.</p>
<p>Using LZMA_SYNC_FLUSH very often can dramatically reduce the compression ratio. With some filters (for example, LZMA2), fine-tuning the compression options may help mitigate this problem significantly (for example, match finder with LZMA2).</p>
<p>Decoders don't support LZMA_SYNC_FLUSH. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa92efcbf3cecfcac79c81fc645fce77eaab46f0d7c721f1ec377e9575eab2586f"></a>LZMA_FULL_FLUSH&#160;</td><td class="fielddoc"><p>Finish encoding of the current Block. </p>
<p>All the input data going to the current Block must have been given to the encoder (the last bytes can still be pending in *next_in). Call lzma_code() with LZMA_FULL_FLUSH until it returns LZMA_STREAM_END. Then continue normally with LZMA_RUN or finish the Stream with LZMA_FINISH.</p>
<p>This action is currently supported only by Stream encoder and easy encoder (which uses Stream encoder). If there is no unfinished Block, no empty Block is created. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa92efcbf3cecfcac79c81fc645fce77eaf7bf60e3555a4d10ffad3ecc3d2e01f1"></a>LZMA_FULL_BARRIER&#160;</td><td class="fielddoc"><p>Finish encoding of the current Block. </p>
<p>This is like LZMA_FULL_FLUSH except that this doesn't necessarily wait until all the input has been made available via the output buffer. That is, lzma_code() might return LZMA_STREAM_END as soon as all the input has been consumed (avail_in == 0).</p>
<p>LZMA_FULL_BARRIER is useful with a threaded encoder if one wants to split the .xz Stream into Blocks at specific offsets but doesn't care if the output isn't flushed immediately. Using LZMA_FULL_BARRIER allows keeping the threads busy while LZMA_FULL_FLUSH would make lzma_code() wait until all the threads have finished until more data could be passed to the encoder.</p>
<p>With a <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> initialized with the single-threaded lzma_stream_encoder() or lzma_easy_encoder(), LZMA_FULL_BARRIER is an alias for LZMA_FULL_FLUSH. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa92efcbf3cecfcac79c81fc645fce77ea7d24fb3c6c144d13bcb091195b8ebec1"></a>LZMA_FINISH&#160;</td><td class="fielddoc"><p>Finish the coding operation. </p>
<p>All the input data must have been given to the encoder (the last bytes can still be pending in next_in). Call lzma_code() with LZMA_FINISH until it returns LZMA_STREAM_END. Once LZMA_FINISH has been used, the amount of input must no longer be changed by the application.</p>
<p>When decoding, using LZMA_FINISH is optional unless the LZMA_CONCATENATED flag was used when the decoder was initialized. When LZMA_CONCATENATED was not used, the only effect of LZMA_FINISH is that the amount of input must not be changed just like in the encoder. </p>
</td></tr>
</table>

</div>
</div>
<a id="a05805a07754b2aa22f7d443eb7ece41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05805a07754b2aa22f7d443eb7ece41a">&#9670;&nbsp;</a></span>lzma_reserved_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="base_8h.html#a05805a07754b2aa22f7d443eb7ece41a">lzma_reserved_enum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of reserved enumeration variable in structures. </p>
<p>To avoid breaking library ABI when new features are added, several structures contain extra variables that may be used in future. Since sizeof(enum) can be different than sizeof(int), and sizeof(enum) may even vary depending on the range of enumeration constants, we specify a separate type to be used for reserved enumeration variables. All enumeration constants in liblzma API will be non-negative and less than 128, which should guarantee that the ABI won't break even when new constants are added to existing enumerations. </p>

</div>
</div>
<a id="a8494e0457e1463d6d2b6836018d87b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8494e0457e1463d6d2b6836018d87b6e">&#9670;&nbsp;</a></span>lzma_ret</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return values used by several functions in liblzma. </p>
<p>Check the descriptions of specific functions to find out which return values they can return. With some functions the return values may have more specific meanings than described here; those differences are described per-function basis. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6eac003781ccb81bbd5578e29abed8a8cfe"></a>LZMA_OK&#160;</td><td class="fielddoc"><p>Operation completed successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6ea91ecc6fab14c13ad36224afbcb4e55c4"></a>LZMA_STREAM_END&#160;</td><td class="fielddoc"><p>End of stream was reached. </p>
<p>In encoder, LZMA_SYNC_FLUSH, LZMA_FULL_FLUSH, or LZMA_FINISH was finished. In decoder, this indicates that all the data was successfully decoded.</p>
<p>In all cases, when LZMA_STREAM_END is returned, the last output bytes should be picked from strm-&gt;next_out. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6eaa720d30092d504d7d138a320db1905ef"></a>LZMA_NO_CHECK&#160;</td><td class="fielddoc"><p>Input stream has no integrity check. </p>
<p>This return value can be returned only if the LZMA_TELL_NO_CHECK flag was used when initializing the decoder. LZMA_NO_CHECK is just a warning, and the decoding can be continued normally.</p>
<p>It is possible to call lzma_get_check() immediately after lzma_code has returned LZMA_NO_CHECK. The result will naturally be LZMA_CHECK_NONE, but the possibility to call lzma_get_check() may be convenient in some applications. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6ea989f393a1772d85bf545a9da48fc7ac2"></a>LZMA_UNSUPPORTED_CHECK&#160;</td><td class="fielddoc"><p>Cannot calculate the integrity check. </p>
<p>The usage of this return value is different in encoders and decoders.</p>
<p>Encoders can return this value only from the initialization function. If initialization fails with this value, the encoding cannot be done, because there's no way to produce output with the correct integrity check.</p>
<p>Decoders can return this value only from lzma_code() and only if the LZMA_TELL_UNSUPPORTED_CHECK flag was used when initializing the decoder. The decoding can still be continued normally even if the check type is unsupported, but naturally the check will not be validated, and possible errors may go undetected.</p>
<p>With decoder, it is possible to call lzma_get_check() immediately after lzma_code() has returned LZMA_UNSUPPORTED_CHECK. This way it is possible to find out what the unsupported Check ID was. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6eaa5b648c18da0f584f621cfdf7fef1bdb"></a>LZMA_GET_CHECK&#160;</td><td class="fielddoc"><p>Integrity check type is now available. </p>
<p>This value can be returned only by the lzma_code() function and only if the decoder was initialized with the LZMA_TELL_ANY_CHECK flag. LZMA_GET_CHECK tells the application that it may now call lzma_get_check() to find out the Check ID. This can be used, for example, to implement a decoder that accepts only files that have strong enough integrity check. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6ea567e1464feca03900a5425fb45b2f5b6"></a>LZMA_MEM_ERROR&#160;</td><td class="fielddoc"><p>Cannot allocate memory. </p>
<p>Memory allocation failed, or the size of the allocation would be greater than SIZE_MAX.</p>
<p>Due to internal implementation reasons, the coding cannot be continued even if more memory were made available after LZMA_MEM_ERROR. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6eaa1d705effe6026f32c0fe9756b6326bc"></a>LZMA_MEMLIMIT_ERROR&#160;</td><td class="fielddoc"><p>Memory usage limit was reached. </p>
<p>Decoder would need more memory than allowed by the specified memory usage limit. To continue decoding, the memory usage limit has to be increased with lzma_memlimit_set().</p>
<p>liblzma 5.2.6 and earlier had a bug in single-threaded .xz decoder (lzma_stream_decoder()) which made it impossible to continue decoding after LZMA_MEMLIMIT_ERROR even if the limit was increased using lzma_memlimit_set(). Other decoders worked correctly. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6ea63b7a58949854eb9307f8e351358d56c"></a>LZMA_FORMAT_ERROR&#160;</td><td class="fielddoc"><p>File format not recognized. </p>
<p>The decoder did not recognize the input as supported file format. This error can occur, for example, when trying to decode .lzma format file with lzma_stream_decoder, because lzma_stream_decoder accepts only the .xz format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6eaa9ff6dfee36b7aba4fae60706d37425f"></a>LZMA_OPTIONS_ERROR&#160;</td><td class="fielddoc"><p>Invalid or unsupported options. </p>
<p>Invalid or unsupported options, for example</p><ul>
<li>unsupported filter(s) or filter options; or</li>
<li>reserved bits set in headers (decoder only).</li>
</ul>
<p>Rebuilding liblzma with more features enabled, or upgrading to a newer version of liblzma may help. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6ea3aa72729a844790e39b4e1101a731dfb"></a>LZMA_DATA_ERROR&#160;</td><td class="fielddoc"><p>Data is corrupt. </p>
<p>The usage of this return value is different in encoders and decoders. In both encoder and decoder, the coding cannot continue after this error.</p>
<p>Encoders return this if size limits of the target file format would be exceeded. These limits are huge, thus getting this error from an encoder is mostly theoretical. For example, the maximum compressed and uncompressed size of a .xz Stream is roughly 8 EiB (2^63 bytes).</p>
<p>Decoders return this error if the input data is corrupt. This can mean, for example, invalid CRC32 in headers or invalid check of uncompressed data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6ea9ca0ecb62459bdc84d6af47d16b23ae5"></a>LZMA_BUF_ERROR&#160;</td><td class="fielddoc"><p>No progress is possible. </p>
<p>This error code is returned when the coder cannot consume any new input and produce any new output. The most common reason for this error is that the input stream being decoded is truncated or corrupt.</p>
<p>This error is not fatal. Coding can be continued normally by providing more input and/or more output space, if possible.</p>
<p>Typically the first call to lzma_code() that can do no progress returns LZMA_OK instead of LZMA_BUF_ERROR. Only the second consecutive call doing no progress will return LZMA_BUF_ERROR. This is intentional.</p>
<p>With zlib, Z_BUF_ERROR may be returned even if the application is doing nothing wrong, so apps will need to handle Z_BUF_ERROR specially. The above hack guarantees that liblzma never returns LZMA_BUF_ERROR to properly written applications unless the input file is truncated or corrupt. This should simplify the applications a little. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6ea2dac8d451cb38da8550653d0d7be4ec2"></a>LZMA_PROG_ERROR&#160;</td><td class="fielddoc"><p>Programming error. </p>
<p>This indicates that the arguments given to the function are invalid or the internal state of the decoder is corrupt.</p><ul>
<li>Function arguments are invalid or the structures pointed by the argument pointers are invalid e.g. if strm-&gt;next_out has been set to NULL and strm-&gt;avail_out &gt; 0 when calling lzma_code().</li>
<li>lzma_* functions have been called in wrong order e.g. lzma_code() was called right after lzma_end().</li>
<li>If errors occur randomly, the reason might be flaky hardware.</li>
</ul>
<p>If you think that your code is correct, this error code can be a sign of a bug in liblzma. See the documentation how to report bugs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8494e0457e1463d6d2b6836018d87b6ea6cf28e5345851f13bd798a4eab8cc939"></a>LZMA_SEEK_NEEDED&#160;</td><td class="fielddoc"><p>Request to change the input file position. </p>
<p>Some coders can do random access in the input file. The initialization functions of these coders take the file size as an argument. No other coders can return LZMA_SEEK_NEEDED.</p>
<p>When this value is returned, the application must seek to the file position given in <a class="el" href="structlzma__stream.html#af7c43a61f3dfeb0b9c8487b7f275054e" title="New seek input position for LZMA_SEEK_NEEDED.">lzma_stream.seek_pos</a>. This value is guaranteed to never exceed the file size that was specified at the coder initialization.</p>
<p>After seeking the application should read new input and pass it normally via <a class="el" href="structlzma__stream.html#a72fdc738c793f07a5c29715aa57802cf">lzma_stream.next_in</a> and .avail_in. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a408876aeee9dd3330df165835dd8bfa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408876aeee9dd3330df165835dd8bfa0">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode or decode data. </p>
<p>Decode a variable-length integer.</p>
<p>Compare two <a class="el" href="structlzma__stream__flags.html" title="Options for encoding/decoding Stream Header and Stream Footer.">lzma_stream_flags</a> structures.</p>
<p>Decode Stream Footer.</p>
<p>Decode Stream Header.</p>
<p>Encode Stream Footer.</p>
<p>Decode and validate the Index field.</p>
<p>Initialize a .xz file information decoder.</p>
<p>Single-call .xz Index decoder.</p>
<p>Single-call .xz Index encoder.</p>
<p>Initialize .xz Index decoder.</p>
<p>Initialize .xz Index encoder.</p>
<p>Concatenate lzma_indexes.</p>
<p>Set the amount of Stream Padding.</p>
<p>Set the Stream Flags.</p>
<p><a class="el" href="structList.html">List</a> available filters and/or their options (for help message)</p>
<p>Convert a filter chain to a string.</p>
<p>Decode Filter Flags from given buffer.</p>
<p>Encode Filter Flags into given buffer.</p>
<p>Calculate encoded size of a Filter Flags field.</p>
<p>Decode the Filter Properties field.</p>
<p>Encode the Filter Properties field.</p>
<p>Get the size of the Filter Properties field.</p>
<p>Single-call raw decoder.</p>
<p>Single-call raw encoder.</p>
<p>Update the filter chain in the encoder.</p>
<p>Initialize raw decoder.</p>
<p>Initialize raw encoder.</p>
<p>MicroLZMA decoder.</p>
<p>Single-call .xz Stream decoder.</p>
<p>Initialize .lz (lzip) decoder (a foreign file format)</p>
<p>Initialize .lzma decoder (legacy file format)</p>
<p>Decode .xz, .lzma, and .lz (lzip) files with autodetection.</p>
<p>Initialize multithreaded .xz Stream decoder.</p>
<p>Initialize .xz Stream decoder.</p>
<p>MicroLZMA encoder.</p>
<p>Single-call .xz Stream encoder.</p>
<p>Initialize .lzma encoder (legacy file format)</p>
<p>Initialize multithreaded .xz Stream encoder.</p>
<p>Initialize .xz Stream encoder using a custom filter chain.</p>
<p>Single-call .xz Stream encoding using a preset number.</p>
<p>Single-call .xz Block decoder.</p>
<p>Single-call uncompressed .xz Block encoder.</p>
<p>Single-call .xz Block encoder.</p>
<p>Initialize .xz Block decoder.</p>
<p>Initialize .xz Block encoder.</p>
<p>Validate and set Compressed Size according to Unpadded Size.</p>
<p>Decode Block Header.</p>
<p>Encode Block Header.</p>
<p>Set the memory usage limit.</p>
<p>Once the <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> has been successfully initialized (e.g. with lzma_stream_encoder()), the actual encoding or decoding is done using this function. The application has to update strm-&gt;next_in, strm-&gt;avail_in, strm-&gt;next_out, and strm-&gt;avail_out to pass input to and get output from liblzma.</p>
<p>See the description of the coder-specific initialization function to find out what 'action' values are supported by the coder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">action</td><td>Action for this function to take. Must be a valid lzma_action enum value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Any valid lzma_ret. See the lzma_ret enum description for more information.</dd></dl>
<p>This function is supported only when *strm has been initialized with a function that takes a memlimit argument.</p>
<p>liblzma 5.2.3 and earlier has a bug where memlimit value of 0 causes this function to do nothing (leaving the limit unchanged) and still return LZMA_OK. Later versions treat 0 as if 1 had been specified (so lzma_memlimit_get() will return 1 even if you specify 0 here).</p>
<p>liblzma 5.2.6 and earlier had a bug in single-threaded .xz decoder (lzma_stream_decoder()) which made it impossible to continue decoding after LZMA_MEMLIMIT_ERROR even if the limit was increased using lzma_memlimit_set(). Other decoders worked correctly.</p>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: New memory usage limit successfully set.</li>
<li>LZMA_MEMLIMIT_ERROR: The new limit is too small. The limit was not changed.</li>
<li>LZMA_PROG_ERROR: Invalid arguments, e.g. *strm doesn't support memory usage limit.</li>
</ul>
</dd></dl>
<p>The caller must have calculated the size of the Block Header already with lzma_block_header_size(). If a value larger than the one calculated by lzma_block_header_size() is used, the Block Header will be padded to the specified size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">block</td><td>Block options to be encoded. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer. This must be at least block-&gt;header_size bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful. block-&gt;header_size bytes were written to output buffer.</li>
<li>LZMA_OPTIONS_ERROR: Invalid or unsupported options.</li>
<li>LZMA_PROG_ERROR: Invalid arguments, for example block-&gt;header_size is invalid or block-&gt;filters is NULL.</li>
</ul>
</dd></dl>
<p>block-&gt;version should (usually) be set to the highest value supported by the application. If the application sets block-&gt;version to a value higher than supported by the current liblzma version, this function will downgrade block-&gt;version to the highest value supported by it. Thus one should check the value of block-&gt;version after calling this function if block-&gt;version was set to a non-zero value and the application doesn't otherwise know that the liblzma version being used is new enough to support the specified block-&gt;version.</p>
<p>The size of the Block Header must have already been decoded with <a class="el" href="block_8h.html#ac025c940683a70f4c7f956bad814fd5f" title="Decode the Block Header Size field.">lzma_block_header_size_decode()</a> macro and stored to block-&gt;header_size.</p>
<p>The integrity check type from Stream Header must have been stored to block-&gt;check.</p>
<p>block-&gt;filters must have been allocated, but they don't need to be initialized (possible existing filter options are not freed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">block</td><td>Destination for Block options </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() (and also free() if an error occurs). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer. This must be at least block-&gt;header_size bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Decoding was successful. block-&gt;header_size bytes were read from the input buffer.</li>
<li>LZMA_OPTIONS_ERROR: The Block Header specifies some unsupported options such as unsupported filters. This can happen also if block-&gt;version was set to a too low value compared to what would be required to properly represent the information stored in the Block Header.</li>
<li>LZMA_DATA_ERROR: Block Header is corrupt, for example, the CRC32 doesn't match.</li>
<li>LZMA_PROG_ERROR: Invalid arguments, for example block-&gt;header_size is invalid or block-&gt;filters is NULL.</li>
</ul>
</dd></dl>
<p>Block Header stores Compressed Size, but Index has Unpadded Size. If the application has already parsed the Index and is now decoding Blocks, it can calculate Compressed Size from Unpadded Size. This function does exactly that with error checking:</p>
<ul>
<li>Compressed Size calculated from Unpadded Size must be positive integer, that is, Unpadded Size must be big enough that after Block Header and Check fields there's still at least one byte for Compressed Size.</li>
<li>If Compressed Size was present in Block Header, the new value calculated from Unpadded Size is compared against the value from Block Header.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function must be called <em>after</em> decoding the Block Header field so that it can properly validate Compressed Size if it was present in Block Header.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>Block options: block-&gt;header_size must already be set with lzma_block_header_size(). </td></tr>
    <tr><td class="paramname">unpadded_size</td><td>Unpadded Size from the Index field in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: block-&gt;compressed_size was set successfully.</li>
<li>LZMA_DATA_ERROR: unpadded_size is too small compared to block-&gt;header_size and lzma_check_size(block-&gt;check).</li>
<li>LZMA_PROG_ERROR: Some values are invalid. For example, block-&gt;header_size must be a multiple of four and between 8 and 1024 inclusive.</li>
</ul>
</dd></dl>
<p>Valid actions for lzma_code() are LZMA_RUN, LZMA_SYNC_FLUSH (only if the filter chain supports it), and LZMA_FINISH.</p>
<p>The Block encoder encodes the Block Data, Block Padding, and Check value. It does NOT encode the Block Header which can be encoded with lzma_block_header_encode().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">block</td><td>Block options: block-&gt;version, block-&gt;check, and block-&gt;filters must have been initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: All good, continue with lzma_code().</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_UNSUPPORTED_CHECK: block-&gt;check specifies a Check ID that is not supported by this build of liblzma. Initializing the encoder failed.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>Valid actions for lzma_code() are LZMA_RUN and LZMA_FINISH. Using LZMA_FINISH is not required. It is supported only for convenience.</p>
<p>The Block decoder decodes the Block Data, Block Padding, and Check value. It does NOT decode the Block Header which can be decoded with lzma_block_header_decode().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">block</td><td>Block options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: All good, continue with lzma_code().</li>
<li>LZMA_PROG_ERROR</li>
<li>LZMA_MEM_ERROR</li>
</ul>
</dd></dl>
<p>In contrast to the multi-call encoder initialized with lzma_block_encoder(), this function encodes also the Block Header. This is required to make it possible to write appropriate Block Header also in case the data isn't compressible, and different filter chain has to be used to encode the data in uncompressed form using uncompressed chunks of the LZMA2 filter.</p>
<p>When the data isn't compressible, header_size, compressed_size, and uncompressed_size are set just like when the data was compressible, but it is possible that header_size is too small to hold the filter chain specified in block-&gt;filters, because that isn't necessarily the filter chain that was actually used to encode the data. lzma_block_unpadded_size() still works normally, because it doesn't read the filters array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">block</td><td>Block options: block-&gt;version, block-&gt;check, and block-&gt;filters must have been initialized. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This is like lzma_block_buffer_encode() except this doesn't try to compress the data and instead encodes the data using LZMA2 uncompressed chunks. The required output buffer size can be determined with lzma_block_buffer_bound().</p>
<p>Since the data won't be compressed, this function ignores block-&gt;filters. This function doesn't take <a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> because this function doesn't allocate any memory from the heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">block</td><td>Block options: block-&gt;version, block-&gt;check, and block-&gt;filters must have been initialized. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This is single-call equivalent of lzma_block_decoder(), and requires that the caller has already decoded Block Header and checked its memory usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">block</td><td>Block options </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Decoding was successful.</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_BUF_ERROR: Output buffer was too small.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>The maximum required output buffer size can be calculated with lzma_stream_buffer_bound().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">preset</td><td>Compression preset to use. See the description in lzma_easy_encoder(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">check</td><td>Type of the integrity check to calculate from uncompressed data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN. See filters.h for more information. </td></tr>
    <tr><td class="paramname">check</td><td>Type of the integrity check to calculate from uncompressed data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization was successful.</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This provides the functionality of lzma_easy_encoder() and lzma_stream_encoder() as a single function for multithreaded use.</p>
<p>The supported actions for lzma_code() are LZMA_RUN, LZMA_FULL_FLUSH, LZMA_FULL_BARRIER, and LZMA_FINISH. Support for LZMA_SYNC_FLUSH might be added in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">options</td><td>Pointer to multithreaded compression options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>The .lzma format is sometimes called the LZMA_Alone format, which is the reason for the name of this function. The .lzma format supports only the LZMA1 filter. There is no support for integrity checks like CRC32.</p>
<p>Use this function if and only if you need to create files readable by legacy LZMA tools such as LZMA Utils 4.32.x. Moving to the .xz format is strongly recommended.</p>
<p>The valid action values for lzma_code() are LZMA_RUN and LZMA_FINISH. No kind of flushing is supported, because the file format doesn't make it possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">options</td><td>Pointer to encoder options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN. See filters.h for more information. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">check</td><td>Type of the integrity check to calculate from uncompressed data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>The MicroLZMA format is a raw LZMA stream whose first byte (always 0x00) has been replaced with bitwise-negation of the LZMA properties (lc/lp/pb). This encoding ensures that the first byte of MicroLZMA stream is never 0x00. There is no end of payload marker and thus the uncompressed size must be stored separately. For the best error detection the dictionary size should be stored separately as well but alternatively one may use the uncompressed size as the dictionary size when decoding.</p>
<p>With the MicroLZMA encoder, lzma_code() behaves slightly unusually. The action argument must be LZMA_FINISH and the return value will never be LZMA_OK. Thus the encoding is always done with a single lzma_code() after the initialization. The benefit of the combination of initialization function and lzma_code() is that memory allocations can be reused for better performance.</p>
<p>lzma_code() will try to encode as much input as is possible to fit into the given output buffer. If not all input can be encoded, the stream will be finished without encoding all the input. The caller must check both input and output buffer usage after lzma_code() (total_in and total_out in <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> can be convenient). Often lzma_code() can fill the output buffer completely if there is a lot of input, but sometimes a few bytes may remain unused because the next LZMA symbol would require more space.</p>
<p><a class="el" href="structlzma__stream.html#a5ff28ea4e39148723c19f59811627904">lzma_stream.avail_out</a> must be at least 6. Otherwise LZMA_PROG_ERROR will be returned.</p>
<p>The LZMA dictionary should be reasonably low to speed up the encoder re-initialization. A good value is bigger than the resulting uncompressed size of most of the output chunks. For example, if output size is 4 KiB, dictionary size of 32 KiB or 64 KiB is good. If the data compresses extremely well, even 128 KiB may be useful.</p>
<p>The MicroLZMA format and this encoder variant were made with the EROFS file system in mind. This format may be convenient in other embedded uses too where many small streams are needed. XZ Embedded includes a decoder for this format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">options</td><td>Pointer to encoder options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_STREAM_END: All good. Check the amounts of input used and output produced. Store the amount of input used (uncompressed size) as it needs to be known to decompress the data.</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR: In addition to the generic reasons for this error code, this may also be returned if there isn't enough output space (6 bytes) to create a valid MicroLZMA stream.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">memlimit</td><td>Memory usage limit as bytes. Use UINT64_MAX to effectively disable the limiter. liblzma 5.2.3 and earlier don't allow 0 here and return LZMA_PROG_ERROR; later versions treat 0 as if 1 had been specified. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitwise-or of zero or more of the decoder flags: LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK, LZMA_TELL_ANY_CHECK, LZMA_IGNORE_CHECK, LZMA_CONCATENATED, LZMA_FAIL_FAST</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization was successful.</li>
<li>LZMA_MEM_ERROR: Cannot allocate memory.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported flags</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>The decoder can decode multiple Blocks in parallel. This requires that each Block Header contains the Compressed Size and Uncompressed size fields which are added by the multi-threaded encoder, see lzma_stream_encoder_mt().</p>
<p>A Stream with one Block will only utilize one thread. A Stream with multiple Blocks but without size information in Block Headers will be processed in single-threaded mode in the same way as done by lzma_stream_decoder(). Concatenated Streams are processed one Stream at a time; no inter-Stream parallelization is done.</p>
<p>This function behaves like lzma_stream_decoder() when options-&gt;threads == 1 and options-&gt;memlimit_threading &lt;= 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">options</td><td>Pointer to multithreaded compression options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization was successful.</li>
<li>LZMA_MEM_ERROR: Cannot allocate memory.</li>
<li>LZMA_MEMLIMIT_ERROR: Memory usage limit was reached.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported flags.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This decoder autodetects between the .xz, .lzma, and .lz file formats, and calls lzma_stream_decoder(), lzma_alone_decoder(), or lzma_lzip_decoder() once the type of the input file has been detected.</p>
<p>Support for .lz was added in 5.4.0.</p>
<p>If the flag LZMA_CONCATENATED is used and the input is a .lzma file: For historical reasons concatenated .lzma files aren't supported. If there is trailing data after one .lzma stream, lzma_code() will return LZMA_DATA_ERROR. (lzma_alone_decoder() doesn't have such a check as it doesn't support any decoder flags. It will return LZMA_STREAM_END after one .lzma stream.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">memlimit</td><td>Memory usage limit as bytes. Use UINT64_MAX to effectively disable the limiter. liblzma 5.2.3 and earlier don't allow 0 here and return LZMA_PROG_ERROR; later versions treat 0 as if 1 had been specified. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitwise-or of zero or more of the decoder flags: LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK, LZMA_TELL_ANY_CHECK, LZMA_IGNORE_CHECK, LZMA_CONCATENATED, LZMA_FAIL_FAST</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization was successful.</li>
<li>LZMA_MEM_ERROR: Cannot allocate memory.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported flags</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>Valid 'action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH. There is no need to use LZMA_FINISH, but it's allowed because it may simplify certain types of applications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">memlimit</td><td>Memory usage limit as bytes. Use UINT64_MAX to effectively disable the limiter. liblzma 5.2.3 and earlier don't allow 0 here and return LZMA_PROG_ERROR; later versions treat 0 as if 1 had been specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This decoder supports the .lz format version 0 and the unextended .lz format version 1:</p>
<ul>
<li>Files in the format version 0 were produced by lzip 1.3 and older. Such files aren't common but may be found from file archives as a few source packages were released in this format. People might have old personal files in this format too. Decompression support for the format version 0 was removed in lzip 1.18.</li>
<li>lzip 1.3 added decompression support for .lz format version 1 files. Compression support was added in lzip 1.4. In lzip 1.6 the .lz format version 1 was extended to support the Sync Flush marker. This extension is not supported by liblzma. lzma_code() will return LZMA_DATA_ERROR at the location of the Sync Flush marker. In practice files with the Sync Flush marker are very rare and thus liblzma can decompress almost all .lz files.</li>
</ul>
<p>Just like with lzma_stream_decoder() for .xz files, LZMA_CONCATENATED should be used when decompressing normal standalone .lz files.</p>
<p>The .lz format allows putting non-.lz data at the end of a file after at least one valid .lz member. That is, one can append custom data at the end of a .lz file and the decoder is required to ignore it. In liblzma this is relevant only when LZMA_CONCATENATED is used. In that case lzma_code() will return LZMA_STREAM_END and leave <a class="el" href="structlzma__stream.html#a72fdc738c793f07a5c29715aa57802cf">lzma_stream.next_in</a> pointing to the first byte of the non-.lz data. An exception to this is if the first 1-3 bytes of the non-.lz data are identical to the .lz magic bytes (0x4C, 0x5A, 0x49, 0x50; "LZIP" in US-ASCII). In such a case the 1-3 bytes will have been ignored by lzma_code(). If one wishes to locate the non-.lz data reliably, one must ensure that the first byte isn't 0x4C. Actually one should ensure that none of the first four bytes of trailing data are equal to the magic bytes because lzip &gt;= 1.20 requires it by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">memlimit</td><td>Memory usage limit as bytes. Use UINT64_MAX to effectively disable the limiter. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitwise-or of flags, or zero for no flags. All decoder flags listed above are supported although only LZMA_CONCATENATED and (in very rare cases) LZMA_IGNORE_CHECK are actually useful. LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK, and LZMA_FAIL_FAST do nothing. LZMA_TELL_ANY_CHECK is supported for consistency only as CRC32 is always used in the .lz format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization was successful.</li>
<li>LZMA_MEM_ERROR: Cannot allocate memory.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported flags</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">memlimit</td><td>Pointer to how much memory the decoder is allowed to allocate. The value pointed by this pointer is modified if and only if LZMA_MEMLIMIT_ERROR is returned. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>Bitwise-or of zero or more of the decoder flags: LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK, LZMA_IGNORE_CHECK, LZMA_CONCATENATED, LZMA_FAIL_FAST. Note that LZMA_TELL_ANY_CHECK is not allowed and will return LZMA_PROG_ERROR. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Decoding was successful.</li>
<li>LZMA_FORMAT_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_NO_CHECK: This can be returned only if using the LZMA_TELL_NO_CHECK flag.</li>
<li>LZMA_UNSUPPORTED_CHECK: This can be returned only if using the LZMA_TELL_UNSUPPORTED_CHECK flag.</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_MEMLIMIT_ERROR: Memory usage limit was reached. The minimum required memlimit value was stored to *memlimit.</li>
<li>LZMA_BUF_ERROR: Output buffer was too small.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>See lzma_microlzma_encoder() for more information.</p>
<p>The lzma_code() usage with this decoder is completely normal. The special behavior of lzma_code() applies to lzma_microlzma_encoder() only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">comp_size</td><td>Compressed size of the MicroLZMA stream. The caller must somehow know this exactly. </td></tr>
    <tr><td class="paramname">uncomp_size</td><td>Uncompressed size of the MicroLZMA stream. If the exact uncompressed size isn't known, this can be set to a value that is at most as big as the exact uncompressed size would be, but then the next argument uncomp_size_is_exact must be false. </td></tr>
    <tr><td class="paramname">uncomp_size_is_exact</td><td>If true, uncomp_size must be exactly correct. This will improve error detection at the end of the stream. If the exact uncompressed size isn't known, this must be false. uncomp_size must still be at most as big as the exact uncompressed size is. Setting this to false when the exact size is known will work but error detection at the end of the stream will be weaker. </td></tr>
    <tr><td class="paramname">dict_size</td><td>LZMA dictionary size that was used when compressing the data. It is OK to use a bigger value too but liblzma will then allocate more memory than would actually be required and error detection will be slightly worse. (Note that with the implementation in XZ Embedded it doesn't affect the memory usage if one specifies bigger dictionary than actually required.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This function may be useful when implementing custom file formats.</p>
<p>The 'action' with lzma_code() can be LZMA_RUN, LZMA_SYNC_FLUSH (if the filter chain supports it), or LZMA_FINISH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>The initialization of raw decoder goes similarly to raw encoder.</p>
<p>The 'action' with lzma_code() can be LZMA_RUN or LZMA_FINISH. Using LZMA_FINISH is not required, it is supported just for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This function may be called after lzma_code() has returned LZMA_STREAM_END when LZMA_FULL_BARRIER, LZMA_FULL_FLUSH, or LZMA_SYNC_FLUSH was used:</p>
<ul>
<li>After LZMA_FULL_BARRIER or LZMA_FULL_FLUSH: Single-threaded .xz Stream encoder (lzma_stream_encoder()) and (since liblzma 5.4.0) multi-threaded Stream encoder (lzma_stream_encoder_mt()) allow setting a new filter chain to be used for the next Block(s).</li>
<li>After LZMA_SYNC_FLUSH: Raw encoder (lzma_raw_encoder()), Block encoder (lzma_block_encoder()), and single-threaded .xz Stream encoder (lzma_stream_encoder()) allow changing certain filter-specific options in the middle of encoding. The actual filters in the chain (Filter IDs) must not be changed! Currently only the lc, lp, and pb options of LZMA2 (not LZMA1) can be changed this way.</li>
<li>In the future some filters might allow changing some of their options without any barrier or flushing but currently such filters don't exist.</li>
</ul>
<p>This function may also be called when no data has been compressed yet although this is rarely useful. In that case, this function will behave as if LZMA_FULL_FLUSH (Stream encoders) or LZMA_SYNC_FLUSH (Raw or Block encoder) had been used right before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_MEMLIMIT_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is no function to calculate how big output buffer would surely be big enough. (lzma_stream_buffer_bound() works only for lzma_stream_buffer_encode(); raw encoder won't necessarily meet that bound.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Decoding was successful.</li>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This function may be useful when implementing custom file formats using the raw encoder and decoder.</p>
<dl class="section note"><dt>Note</dt><dd>This function validates the Filter ID, but does not necessarily validate the options. Thus, it is possible that this returns LZMA_OK while the following call to lzma_properties_encode() returns LZMA_OPTIONS_ERROR.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Pointer to uint32_t to hold the size of the properties </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>Filter ID and options (the size of the properties may vary depending on the options)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Even this function won't validate more options than actually necessary. Thus, it is possible that encoding the properties succeeds but using the same options to initialize the encoder will fail.</dd>
<dd>
If lzma_properties_size() indicated that the size of the Filter Properties field is zero, calling lzma_properties_encode() is not required, but it won't do any harm either.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>Filter ID and options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">props</td><td>Buffer to hold the encoded options. The size of the buffer must have been already determined with lzma_properties_size().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>filter-&gt;id must have been set to the correct Filter ID. filter-&gt;options doesn't need to be initialized (it's not freed by this function). The decoded options will be stored in filter-&gt;options; it's application's responsibility to free it when appropriate. filter-&gt;options is set to NULL if there are no properties or if an error occurs. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). and in case of an error, also free(). </td></tr>
    <tr><td class="paramname">props</td><td>Input buffer containing the properties. </td></tr>
    <tr><td class="paramname">props_size</td><td>Size of the properties. This must be the exact size; giving too much or too little input will return LZMA_OPTIONS_ERROR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
</ul>
</dd></dl>
<p>Knowing the size of Filter Flags is useful to know when allocating memory to hold the encoded Filter Flags.</p>
<dl class="section note"><dt>Note</dt><dd>If you need to calculate size of <a class="el" href="structList.html">List</a> of Filter Flags, you need to loop over every <a class="el" href="structlzma__filter.html" title="Filter options.">lzma_filter</a> entry.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Pointer to integer to hold the calculated size </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>Filter ID and associated options whose encoded size is to be calculated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: *size set successfully. Note that this doesn't guarantee that filter-&gt;options is valid, thus lzma_filter_flags_encode() may still fail.</li>
<li>LZMA_OPTIONS_ERROR: Unknown Filter ID or unsupported options.</li>
<li>LZMA_PROG_ERROR: Invalid options</li>
</ul>
</dd></dl>
<p>In contrast to some functions, this doesn't allocate the needed buffer. This is due to how this function is used internally by liblzma.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>Filter ID and options to be encoded </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>out[*out_pos] is the next write position. This is updated by the encoder. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>out[out_size] is the first byte to not write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_OPTIONS_ERROR: Invalid or unsupported options.</li>
<li>LZMA_PROG_ERROR: Invalid options or not enough output buffer space (you should have checked it with lzma_filter_flags_size()).</li>
</ul>
</dd></dl>
<p>The decoded result is stored into *filter. The old value of filter-&gt;options is not free()d. If anything other than LZMA_OK is returned, filter-&gt;options is set to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">filter</td><td>Destination filter. The decoded Filter ID will be stored in filter-&gt;id. If options are needed they will be allocated and the pointer will be stored in filter-&gt;options. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>Use cases:</p>
<ul>
<li>Verbose output showing the full encoder options to the user (use LZMA_STR_ENCODER in flags)</li>
<li>Showing the filters and options that are required to decode a file (use LZMA_STR_DECODER in flags)</li>
<li>Showing the filter names without any options in informational messages where the technical details aren't important (no flags). In this case the .options in the filters array are ignored and may be NULL even if a filter has a mandatory options structure.</li>
</ul>
<p>Note that even if the filter chain was specified using a preset, the resulting filter chain isn't reversed to a preset. So if you specify "6" to lzma_str_to_filters() then lzma_str_from_filters() will produce a string containing "lzma2".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">str</td><td>On success *str will be set to point to an allocated string describing the given filter chain. Old value is ignored. On error *str is always set to NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>Bitwise-or of zero or more of the flags LZMA_STR_ENCODER, LZMA_STR_DECODER, LZMA_STR_GETOPT_LONG, and LZMA_STR_NO_SPACES. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_OPTIONS_ERROR: Empty filter chain (filters[0].id == LZMA_VLI_UNKNOWN) or the filter chain includes a Filter ID that is not supported by this function.</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>If a filter_id is given then only one line is created which contains the filter name. If LZMA_STR_ENCODER or LZMA_STR_DECODER is used then the options read by the encoder or decoder are printed on the same line.</p>
<p>If filter_id is LZMA_VLI_UNKNOWN then all supported .xz-compatible filters are listed:</p>
<ul>
<li>If neither LZMA_STR_ENCODER nor LZMA_STR_DECODER is used then the supported filter names are listed on a single line separated by spaces.</li>
<li>If LZMA_STR_ENCODER or LZMA_STR_DECODER is used then filters and the supported options are listed one filter per line. There won't be a newline after the last filter.</li>
<li>If LZMA_STR_ALL_FILTERS is used then the list will include also those filters that cannot be used in the .xz format (LZMA1).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>On success *str will be set to point to an allocated string listing the filters and options. Old value is ignored. On error *str is always set to NULL. </td></tr>
    <tr><td class="paramname">filter_id</td><td>Filter ID or LZMA_VLI_UNKNOWN. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitwise-or of zero or more of the flags LZMA_STR_ALL_FILTERS, LZMA_STR_ENCODER, LZMA_STR_DECODER, and LZMA_STR_GETOPT_LONG. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_OPTIONS_ERROR: Unsupported filter_id or flags</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>Set the Stream Flags of the last (and typically the only) Stream in lzma_index. This can be useful when reading information from the lzma_index, because to decode Blocks, knowing the integrity check type is needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure </td></tr>
    <tr><td class="paramname">stream_flags</td><td>Pointer to <a class="el" href="structlzma__stream__flags.html" title="Options for encoding/decoding Stream Header and Stream Footer.">lzma_stream_flags</a> structure. This is copied into the internal preallocated structure, so the caller doesn't need to keep the flags' data available after calling this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_OPTIONS_ERROR: Unsupported stream_flags-&gt;version.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>Set the amount of Stream Padding of the last (and typically the only) Stream in the lzma_index. This is needed when planning to do random-access reading within multiple concatenated Streams.</p>
<p>By default, the amount of Stream Padding is assumed to be zero bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_DATA_ERROR: The file size would grow too big.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>Concatenating lzma_indexes is useful when doing random-access reading in multi-Stream .xz file, or when combining multiple Streams into single Stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>lzma_index after which src is appended </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">src</td><td>lzma_index to be appended after dest. If this function succeeds, the memory allocated for src is freed or moved to be part of dest, and all iterators pointing to src will become invalid. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: lzma_indexes were concatenated successfully. src is now a dangling pointer.</li>
<li>LZMA_DATA_ERROR: *dest would grow too big.</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to properly prepared <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> </td></tr>
    <tr><td class="paramname">i</td><td>Pointer to lzma_index which should be encoded.</td></tr>
  </table>
  </dd>
</dl>
<p>The valid 'action' values for lzma_code() are LZMA_RUN and LZMA_FINISH. It is enough to use only one of them (you can choose freely).</p>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization succeeded, continue with lzma_code().</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">strm</td><td>Pointer to properly prepared <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The decoded Index will be made available via this pointer. Initially this function will set *i to NULL (the old value is ignored). If decoding succeeds (lzma_code() returns LZMA_STREAM_END), *i will be set to point to a new lzma_index, which the application has to later free with lzma_index_end(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memlimit</td><td>How much memory the resulting lzma_index is allowed to require. liblzma 5.2.3 and earlier don't allow 0 here and return LZMA_PROG_ERROR; later versions treat 0 as if 1 had been specified.</td></tr>
  </table>
  </dd>
</dl>
<p>Valid 'action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH. There is no need to use LZMA_FINISH, but it's allowed because it may simplify certain types of applications.</p>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization succeeded, continue with lzma_code().</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>liblzma 5.2.3 and older list also LZMA_MEMLIMIT_ERROR here but that error code has never been possible from this initialization function.</dd>
<dd>
This function doesn't take allocator argument since all the internal data is allocated on stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>lzma_index to be encoded </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_BUF_ERROR: Output buffer is too small. Use lzma_index_size() to find out how much output space is needed.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>If decoding succeeds, *i will point to a new lzma_index, which the application has to later free with lzma_index_end(). If an error occurs, *i will be NULL. The old value of *i is always ignored and thus doesn't need to be initialized by the caller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">memlimit</td><td>Pointer to how much memory the resulting lzma_index is allowed to require. The value pointed by this pointer is modified if and only if LZMA_MEMLIMIT_ERROR is returned. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Decoding was successful.</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_MEMLIMIT_ERROR: Memory usage limit was reached. The minimum required memlimit value was stored to *memlimit.</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This decoder decodes the Stream Header, Stream Footer, Index, and Stream Padding field(s) from the input .xz file and stores the resulting combined index in *dest_index. This information can be used to get the uncompressed file size with lzma_index_uncompressed_size(*dest_index) or, for example, to implement random access reading by locating the Blocks in the Streams.</p>
<p>To get the required information from the .xz file, lzma_code() may ask the application to seek in the input file by returning LZMA_SEEK_NEEDED and having the target file position specified in <a class="el" href="structlzma__stream.html#af7c43a61f3dfeb0b9c8487b7f275054e" title="New seek input position for LZMA_SEEK_NEEDED.">lzma_stream.seek_pos</a>. The number of seeks required depends on the input file and how big buffers the application provides. When possible, the decoder will seek backward and forward in the given buffer to avoid useless seek requests. Thus, if the application provides the whole file at once, no external seeking will be required (that is, lzma_code() won't return LZMA_SEEK_NEEDED).</p>
<p>The value in <a class="el" href="structlzma__stream.html#a1a411e1755d6185756caefabc3932c7b">lzma_stream.total_in</a> can be used to estimate how much data liblzma had to read to get the file information. However, due to seeking and the way total_in is updated, the value of total_in will be somewhat inaccurate (a little too big). Thus, total_in is a good estimate but don't expect to see the same exact value for the same file if you change the input buffer size or switch to a different liblzma version.</p>
<p>Valid 'action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH. You only need to use LZMA_RUN; LZMA_FINISH is only supported because it might be convenient for some applications. If you use LZMA_FINISH and if lzma_code() asks the application to seek, remember to reset 'action' back to LZMA_RUN unless you hit the end of the file again.</p>
<p>Possible return values from lzma_code():</p><ul>
<li>LZMA_OK: All OK so far, more input needed</li>
<li>LZMA_SEEK_NEEDED: Provide more input starting from the absolute file position strm-&gt;seek_pos</li>
<li>LZMA_STREAM_END: Decoding was successful, *dest_index has been set</li>
<li>LZMA_FORMAT_ERROR: The input file is not in the .xz format (the expected magic bytes were not found from the beginning of the file)</li>
<li>LZMA_OPTIONS_ERROR: File looks valid but contains headers that aren't supported by this version of liblzma</li>
<li>LZMA_DATA_ERROR: File is corrupt</li>
<li>LZMA_BUF_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_MEMLIMIT_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">strm</td><td>Pointer to a properly prepared <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest_index</td><td>Pointer to a pointer where the decoder will put the decoded lzma_index. The old value of *dest_index is ignored (not freed). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memlimit</td><td>How much memory the resulting lzma_index is allowed to require. Use UINT64_MAX to effectively disable the limiter. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">file_size</td><td>Size of the input .xz file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>After telling the sizes of all Blocks with lzma_index_hash_append(), the actual Index field is decoded with this function. Specifically, once decoding of the Index field has been started, no more Records can be added using lzma_index_hash_append().</p>
<p>This function doesn't use <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> structure to pass the input data. Instead, the input buffer is specified using three arguments. This is because it matches better the internal APIs of liblzma.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">index_hash</td><td>Pointer to a lzma_index_hash structure </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Pointer to the beginning of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">in_pos</td><td>in[*in_pos] is the next byte to process </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>in[in_size] is the first byte not to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: So far good, but more input is needed.</li>
<li>LZMA_STREAM_END: Index decoded successfully and it matches the Records given with lzma_index_hash_append().</li>
<li>LZMA_DATA_ERROR: Index is corrupt or doesn't match the information given with lzma_index_hash_append().</li>
<li>LZMA_BUF_ERROR: Cannot progress because *in_pos &gt;= in_size.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Stream Footer options to be encoded. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer of LZMA_STREAM_HEADER_SIZE bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_OPTIONS_ERROR: options-&gt;version is not supported by this liblzma version.</li>
<li>LZMA_PROG_ERROR: Invalid options.</li>
</ul>
</dd></dl>
<p>options-&gt;backward_size is always set to LZMA_VLI_UNKNOWN. This is to help comparing Stream Flags from Stream Header and Stream Footer with lzma_stream_flags_compare().</p>
<dl class="section note"><dt>Note</dt><dd>When decoding .xz files that contain multiple Streams, it may make sense to print "file format not recognized" only if decoding of the Stream Header of the <em>first</em> Stream gives LZMA_FORMAT_ERROR. If non-first Stream Header gives LZMA_FORMAT_ERROR, the message used for LZMA_DATA_ERROR is probably more appropriate. For example, the Stream decoder in liblzma uses LZMA_DATA_ERROR if LZMA_FORMAT_ERROR is returned by lzma_stream_header_decode() when decoding non-first Stream.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">options</td><td>Target for the decoded Stream Header options. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer of LZMA_STREAM_HEADER_SIZE bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Decoding was successful.</li>
<li>LZMA_FORMAT_ERROR: Magic bytes don't match, thus the given buffer cannot be Stream Header.</li>
<li>LZMA_DATA_ERROR: CRC32 doesn't match, thus the header is corrupt.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported options are present in the header.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If Stream Header was already decoded successfully, but decoding Stream Footer returns LZMA_FORMAT_ERROR, the application should probably report some other error message than "file format not recognized". The file likely is corrupt (possibly truncated). The Stream decoder in liblzma uses LZMA_DATA_ERROR in this situation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">options</td><td>Target for the decoded Stream Footer options. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer of LZMA_STREAM_HEADER_SIZE bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Decoding was successful.</li>
<li>LZMA_FORMAT_ERROR: Magic bytes don't match, thus the given buffer cannot be Stream Footer.</li>
<li>LZMA_DATA_ERROR: CRC32 doesn't match, thus the Stream Footer is corrupt.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported options are present in Stream Footer.</li>
</ul>
</dd></dl>
<p>backward_size values are compared only if both are not LZMA_VLI_UNKNOWN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Pointer to <a class="el" href="structlzma__stream__flags.html" title="Options for encoding/decoding Stream Header and Stream Footer.">lzma_stream_flags</a> structure </td></tr>
    <tr><td class="paramname">b</td><td>Pointer to <a class="el" href="structlzma__stream__flags.html" title="Options for encoding/decoding Stream Header and Stream Footer.">lzma_stream_flags</a> structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Both are equal. If either had backward_size set to LZMA_VLI_UNKNOWN, backward_size values were not compared or validated.</li>
<li>LZMA_DATA_ERROR: The structures differ.</li>
<li>LZMA_OPTIONS_ERROR: version in either structure is greater than the maximum supported version (currently zero).</li>
<li>LZMA_PROG_ERROR: Invalid value, e.g. invalid check or backward_size.</li>
</ul>
</dd></dl>
<p>Like lzma_vli_encode(), this function has single-call and multi-call modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">vli</td><td>Pointer to decoded integer. The decoder will initialize it to zero when *vli_pos == 0, so application isn't required to initialize *vli. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vli_pos</td><td>How many bytes have already been decoded. When starting to decode a new integer in multi-call mode, *vli_pos must be initialized to zero. To use single-call decoding, set vli_pos to NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Slightly different return values are used in multi-call and single-call modes.</dd></dl>
<p>Single-call (vli_pos == NULL):</p><ul>
<li>LZMA_OK: Integer successfully decoded.</li>
<li>LZMA_DATA_ERROR: Integer is corrupt. This includes hitting the end of the input buffer before the whole integer was decoded; providing no input at all will use LZMA_DATA_ERROR.</li>
<li>LZMA_PROG_ERROR: Arguments are not sane.</li>
</ul>
<p>Multi-call (vli_pos != NULL):</p><ul>
<li>LZMA_OK: So far all OK, but the integer is not completely decoded yet.</li>
<li>LZMA_STREAM_END: Integer successfully decoded.</li>
<li>LZMA_DATA_ERROR: Integer is corrupt.</li>
<li>LZMA_BUF_ERROR: No input was provided.</li>
<li>LZMA_PROG_ERROR: Arguments are not sane. </li>
</ul>

</div>
</div>
<a id="ab7de85227aa867358f8f68bb0a358cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7de85227aa867358f8f68bb0a358cbc">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the memory usage of decoder filter chain. </p>
<p>Get the uncompressed size of the file.</p>
<p>Get the total size of the file.</p>
<p>Get the total size of the Blocks.</p>
<p>Get the total size of the Stream.</p>
<p>Get the size of the Index field as bytes.</p>
<p>Get the number of Blocks.</p>
<p>Get the number of Streams.</p>
<p>Calculate the memory usage of an existing lzma_index.</p>
<p>Calculate approximate memory requirements for raw decoder.</p>
<p>Calculate recommended Block size for multithreaded .xz encoder.</p>
<p>Calculate approximate memory usage of multithreaded .xz encoder.</p>
<p>Calculate approximate decoder memory usage of a preset.</p>
<p>Calculate the total encoded size of a Block.</p>
<p>Get the current memory usage limit.</p>
<p>This function is currently supported only when *strm has been initialized with a function that takes a memlimit argument. With other functions, you should use e.g. lzma_raw_encoder_memusage() or lzma_raw_decoder_memusage() to estimate the memory requirements.</p>
<p>This function is useful e.g. after LZMA_MEMLIMIT_ERROR to find out how big the memory usage limit should have been to decode the input. Note that this may give misleading information if decoding .xz Streams that have multiple Blocks, because each Block can have different memory requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>How much memory is currently allocated for the filter decoders. If no filter chain is currently allocated, some non-zero value is still returned, which is less than or equal to what any filter chain would indicate as its memory requirement.</dd></dl>
<p>If this function isn't supported by *strm or some other error occurs, zero is returned.</p>
<p>This function is supported only when *strm has been initialized with a function that takes a memlimit argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the current memory usage limit is returned (always non-zero). On error, zero is returned.</dd></dl>
<p>This is equivalent to lzma_block_unpadded_size() except that the returned value includes the size of the Block Padding field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>Block options: block-&gt;header_size must already be set with lzma_block_header_size().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, total encoded size of the Block. On error, zero is returned.</dd></dl>
<p>This function is a wrapper for lzma_raw_decoder_memusage().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preset</td><td>Compression preset (level and possible flags)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of memory required to decompress a file that was compressed using the given preset or UINT64_MAX on error.</dd></dl>
<p>Since doing the encoding in threaded mode doesn't affect the memory requirements of single-threaded decompressor, you can use lzma_easy_decoder_memusage(options-&gt;preset) or lzma_raw_decoder_memusage(options-&gt;filters) to calculate the decompressor memory requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Compression options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of memory required for encoding with the given options. If an error occurs, for example due to unsupported preset or filter chain, UINT64_MAX is returned.</dd></dl>
<p>This calculates a recommended Block size for multithreaded encoding given a filter chain. This is used internally by lzma_stream_encoder_mt() to determine the Block size if the block_size member is not set to the special value of 0 in the <a class="el" href="structlzma__mt.html" title="Multithreading options.">lzma_mt</a> options struct.</p>
<p>If one wishes to change the filters between Blocks, this function is helpful to set the block_size member of the <a class="el" href="structlzma__mt.html" title="Multithreading options.">lzma_mt</a> struct before calling lzma_stream_encoder_mt(). Since the block_size member represents the maximum possible Block size for the multithreaded .xz encoder, one can use this function to find the maximum recommended Block size based on all planned filter chains. Otherwise, the multithreaded encoder will base its maximum Block size on the first filter chain used (if the block_size member is not set), which may unnecessarily limit the Block size for a later filter chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Recommended Block size in bytes, or UINT64_MAX if an error occurred.</dd></dl>
<p>This function can be used to calculate the memory requirements for Block and Stream decoders too because Block and Stream decoders don't need significantly more memory than raw decoder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of memory required for the given filter chain when decoding or UINT64_MAX on error.</dd></dl>
<p>This is a shorthand for lzma_index_memusage(lzma_index_stream_count(i), lzma_index_block_count(i)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximate memory in bytes used by the lzma_index structure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of Streams in the lzma_index</dd></dl>
<p>This returns the total number of Blocks in lzma_index. To get number of Blocks in individual Streams, use <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of blocks in the lzma_index</dd></dl>
<p>This is needed to verify the Backward Size field in the Stream Footer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the Index</dd></dl>
<p>If multiple lzma_indexes have been combined, this works as if the Blocks were in a single Stream. This is useful if you are going to combine Blocks from multiple Streams into a single new Stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the Stream (if all Blocks are combined into one Stream).</dd></dl>
<p>This doesn't include the Stream Header, Stream Footer, Stream Padding, or Index fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of all Blocks in the Stream(s)</dd></dl>
<p>When no lzma_indexes have been combined with lzma_index_cat() and there is no Stream Padding, this function is identical to lzma_index_stream_size(). If multiple lzma_indexes have been combined, this includes also the headers of each separate Stream and the possible Stream Padding fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total size of the .xz file in bytes</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the uncompressed data in the file</dd></dl>
<p>Get the memory usage of decoder filter chain.</p>
<p>Calculate CRC64 using the polynomial from the ECMA-182 standard.</p>
<p>This function is used similarly to lzma_crc32().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the input buffer </td></tr>
    <tr><td class="paramname">size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramname">crc</td><td>Previously returned CRC value. This is used to calculate the CRC of a big buffer in smaller chunks. Set to zero when starting a new calculation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated CRC value, which can be passed to this function again to continue CRC calculation. </dd></dl>

</div>
</div>
<a id="ae0a37da2f150216d0bf61e211ed62308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a37da2f150216d0bf61e211ed62308">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory allocated for the coder data structures. </p>
<p>Rewind the iterator.</p>
<p>Initialize an iterator.</p>
<p>Get progress information.</p>
<p>After lzma_end(strm), strm-&gt;internal is guaranteed to be NULL. No other members of the <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> structure are touched.</p>
<dl class="section note"><dt>Note</dt><dd>zlib indicates an error if application end()s unfinished stream structure. liblzma doesn't do this, and assumes that application knows what it is doing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT.</td></tr>
  </table>
  </dd>
</dl>
<p>In single-threaded mode, applications can get progress information from strm-&gt;total_in and strm-&gt;total_out. In multi-threaded mode this is less useful because a significant amount of both input and output data gets buffered internally by liblzma. This makes total_in and total_out give misleading information and also makes the progress indicator updates non-smooth.</p>
<p>This function gives realistic progress information also in multi-threaded mode by taking into account the progress made by each thread. In single-threaded mode *progress_in and *progress_out are set to strm-&gt;total_in and strm-&gt;total_out, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">progress_in</td><td>Pointer to the number of input bytes processed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">progress_out</td><td>Pointer to the number of output bytes processed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function associates the iterator with the given lzma_index, and calls lzma_index_iter_rewind() on the iterator.</p>
<p>This function doesn't allocate any memory, thus there is no lzma_index_iter_end(). The iterator is valid as long as the associated lzma_index is valid, that is, until lzma_index_end() or using it as source in lzma_index_cat(). Specifically, lzma_index doesn't become invalid if new Blocks are added to it with lzma_index_append() or if it is used as the destination in lzma_index_cat().</p>
<p>It is safe to make copies of an initialized <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a>, for example, to easily restart reading at some particular position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Pointer to a <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a> structure </td></tr>
    <tr><td class="paramname">i</td><td>lzma_index to which the iterator will be associated</td></tr>
  </table>
  </dd>
</dl>
<p>Rewind the iterator so that next call to lzma_index_iter_next() will return the first Block or Stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Pointer to a <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
