<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PHONE MANAGEMENT: UI-UX/SFML/include/lzma/block.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PHONE MANAGEMENT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_669fb1e37e108424641b4492fae48a00.html">UI-UX</a></li><li class="navelem"><a class="el" href="dir_fef68780f280e2b18cfa5347c2a48e1f.html">SFML</a></li><li class="navelem"><a class="el" href="dir_ab5abbf355e63c20d9132dc628d44eb6.html">include</a></li><li class="navelem"><a class="el" href="dir_40a6e693a8331efa19c2f3d27b8cdc28.html">lzma</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">block.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>.xz Block handling  
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="block_8h__dep__incl.png" border="0" usemap="#UI-UX_2SFML_2include_2lzma_2block_8hdep" alt=""/></div>
<map name="UI-UX_2SFML_2include_2lzma_2block_8hdep" id="UI-UX_2SFML_2include_2lzma_2block_8hdep">
<area shape="rect" title=".xz Block handling" alt="" coords="5,5,156,47"/>
<area shape="rect" href="lzma_8h_source.html" title=" " alt="" coords="5,95,156,136"/>
</map>
</div>
</div>
<p><a href="block_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__block.html">lzma_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the Block and Block Header encoders and decoders.  <a href="structlzma__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9263c5b314592e658772e5eb83ffdd78"><td class="memItemLeft" align="right" valign="top"><a id="a9263c5b314592e658772e5eb83ffdd78"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LZMA_BLOCK_HEADER_SIZE_MIN</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a9263c5b314592e658772e5eb83ffdd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a39189d0721c55313a401b63811e49"><td class="memItemLeft" align="right" valign="top"><a id="af7a39189d0721c55313a401b63811e49"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LZMA_BLOCK_HEADER_SIZE_MAX</b>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:af7a39189d0721c55313a401b63811e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac025c940683a70f4c7f956bad814fd5f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#ac025c940683a70f4c7f956bad814fd5f">lzma_block_header_size_decode</a>(b)&#160;&#160;&#160;(((uint32_t)(b) + 1) * 4)</td></tr>
<tr class="memdesc:ac025c940683a70f4c7f956bad814fd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the Block Header Size field.  <a href="block_8h.html#ac025c940683a70f4c7f956bad814fd5f">More...</a><br /></td></tr>
<tr class="separator:ac025c940683a70f4c7f956bad814fd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adde90b9aeaccf73a6a3cd1edb2006afa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#adde90b9aeaccf73a6a3cd1edb2006afa">LZMA_API</a> (<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>) lzma_block_header_size(<a class="el" href="structlzma__block.html">lzma_block</a> *block) lzma_nothrow lzma_attr_warn_unused_result</td></tr>
<tr class="memdesc:adde90b9aeaccf73a6a3cd1edb2006afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Block Header Size.  <a href="block_8h.html#adde90b9aeaccf73a6a3cd1edb2006afa">More...</a><br /></td></tr>
<tr class="separator:adde90b9aeaccf73a6a3cd1edb2006afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb10da1ad1ba54c0f8a0c7543999ed5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#afb10da1ad1ba54c0f8a0c7543999ed5b">LZMA_API</a> (<a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>) lzma_block_unpadded_size(const <a class="el" href="structlzma__block.html">lzma_block</a> *block) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:afb10da1ad1ba54c0f8a0c7543999ed5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Unpadded Size.  <a href="block_8h.html#afb10da1ad1ba54c0f8a0c7543999ed5b">More...</a><br /></td></tr>
<tr class="separator:afb10da1ad1ba54c0f8a0c7543999ed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b9103a517ed8104855f6e14c9cf7ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="block_8h.html#a14b9103a517ed8104855f6e14c9cf7ed">LZMA_API</a> (size_t) lzma_block_buffer_bound(size_t uncompressed_size) lzma_nothrow</td></tr>
<tr class="memdesc:a14b9103a517ed8104855f6e14c9cf7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate maximum output size for single-call Block encoding.  <a href="block_8h.html#a14b9103a517ed8104855f6e14c9cf7ed">More...</a><br /></td></tr>
<tr class="separator:a14b9103a517ed8104855f6e14c9cf7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa2b72de5784774065db298e8d1f1a03d"><td class="memItemLeft" align="right" valign="top"><a id="aa2b72de5784774065db298e8d1f1a03d"></a>
uint8_t *out lzma_nothrow&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_attr_warn_unused_result</b></td></tr>
<tr class="separator:aa2b72de5784774065db298e8d1f1a03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d9ba564624e603e605591eda3edf00"><td class="memItemLeft" align="right" valign="top"><a id="aa9d9ba564624e603e605591eda3edf00"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>allocator</b></td></tr>
<tr class="separator:aa9d9ba564624e603e605591eda3edf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33660e730ac6849d6a4fbf1722e1aa8c"><td class="memItemLeft" align="right" valign="top"><a id="a33660e730ac6849d6a4fbf1722e1aa8c"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>in</b></td></tr>
<tr class="separator:a33660e730ac6849d6a4fbf1722e1aa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f87fba249664a288be5c92cbffeb1a0"><td class="memItemLeft" align="right" valign="top"><a id="a2f87fba249664a288be5c92cbffeb1a0"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>in_size</b></td></tr>
<tr class="separator:a2f87fba249664a288be5c92cbffeb1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78b8895128b1eb11164b477044beeb0"><td class="memItemLeft" align="right" valign="top"><a id="aa78b8895128b1eb11164b477044beeb0"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>out</b></td></tr>
<tr class="separator:aa78b8895128b1eb11164b477044beeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164e5bfe5d7bb8a74fc5fa86de0824ce"><td class="memItemLeft" align="right" valign="top"><a id="a164e5bfe5d7bb8a74fc5fa86de0824ce"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t uint8_t size_t *&#160;</td><td class="memItemRight" valign="bottom"><b>out_pos</b></td></tr>
<tr class="separator:a164e5bfe5d7bb8a74fc5fa86de0824ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a3ebd0951ebc7a18d0a3d0c1a675d4"><td class="memItemLeft" align="right" valign="top"><a id="a19a3ebd0951ebc7a18d0a3d0c1a675d4"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t *&#160;</td><td class="memItemRight" valign="bottom"><b>in_pos</b></td></tr>
<tr class="separator:a19a3ebd0951ebc7a18d0a3d0c1a675d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f33729ca04f8a5a886e691899cd7ade"><td class="memItemLeft" align="right" valign="top"><a id="a0f33729ca04f8a5a886e691899cd7ade"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t size_t uint8_t size_t size_t out_size&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_nothrow</b></td></tr>
<tr class="separator:a0f33729ca04f8a5a886e691899cd7ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>.xz Block handling </p>
<dl class="section note"><dt>Note</dt><dd>Never include this file directly. Use &lt;<a class="el" href="lzma_8h_source.html">lzma.h</a>&gt; instead. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac025c940683a70f4c7f956bad814fd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac025c940683a70f4c7f956bad814fd5f">&#9670;&nbsp;</a></span>lzma_block_header_size_decode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lzma_block_header_size_decode</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;(((uint32_t)(b) + 1) * 4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the Block Header Size field. </p>
<p>To decode Block Header using lzma_block_header_decode(), the size of the Block Header has to be known and stored into <a class="el" href="structlzma__block.html#a6689c4f7524b2c05772a2d6151138610" title="Size of the Block Header field in bytes.">lzma_block.header_size</a>. The size can be calculated from the first byte of a Block using this macro. Note that if the first byte is 0x00, it indicates beginning of Index; use this macro only when the byte is not 0x00.</p>
<p>There is no encoding macro because lzma_block_header_size() and lzma_block_header_encode() should be used. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adde90b9aeaccf73a6a3cd1edb2006afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde90b9aeaccf73a6a3cd1edb2006afa">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate Block Header Size. </p>
<p>Single-call .xz Block decoder.</p>
<p>Single-call uncompressed .xz Block encoder.</p>
<p>Single-call .xz Block encoder.</p>
<p>Initialize .xz Block decoder.</p>
<p>Initialize .xz Block encoder.</p>
<p>Validate and set Compressed Size according to Unpadded Size.</p>
<p>Decode Block Header.</p>
<p>Encode Block Header.</p>
<p>Calculate the minimum size needed for the Block Header field using the settings specified in the <a class="el" href="structlzma__block.html" title="Options for the Block and Block Header encoders and decoders.">lzma_block</a> structure. Note that it is OK to increase the calculated header_size value as long as it is a multiple of four and doesn't exceed LZMA_BLOCK_HEADER_SIZE_MAX. Increasing header_size just means that lzma_block_header_encode() will add Header Padding.</p>
<dl class="section note"><dt>Note</dt><dd>This doesn't check that all the options are valid i.e. this may return LZMA_OK even if lzma_block_header_encode() or lzma_block_encoder() would fail. If you want to validate the filter chain, consider using lzma_memlimit_encoder() which as a side-effect validates the filter chain.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>Block options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Size calculated successfully and stored to block-&gt;header_size.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported version, filters or filter options.</li>
<li>LZMA_PROG_ERROR: Invalid values like compressed_size == 0.</li>
</ul>
</dd></dl>
<p>The caller must have calculated the size of the Block Header already with lzma_block_header_size(). If a value larger than the one calculated by lzma_block_header_size() is used, the Block Header will be padded to the specified size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">block</td><td>Block options to be encoded. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer. This must be at least block-&gt;header_size bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful. block-&gt;header_size bytes were written to output buffer.</li>
<li>LZMA_OPTIONS_ERROR: Invalid or unsupported options.</li>
<li>LZMA_PROG_ERROR: Invalid arguments, for example block-&gt;header_size is invalid or block-&gt;filters is NULL.</li>
</ul>
</dd></dl>
<p>block-&gt;version should (usually) be set to the highest value supported by the application. If the application sets block-&gt;version to a value higher than supported by the current liblzma version, this function will downgrade block-&gt;version to the highest value supported by it. Thus one should check the value of block-&gt;version after calling this function if block-&gt;version was set to a non-zero value and the application doesn't otherwise know that the liblzma version being used is new enough to support the specified block-&gt;version.</p>
<p>The size of the Block Header must have already been decoded with <a class="el" href="block_8h.html#ac025c940683a70f4c7f956bad814fd5f" title="Decode the Block Header Size field.">lzma_block_header_size_decode()</a> macro and stored to block-&gt;header_size.</p>
<p>The integrity check type from Stream Header must have been stored to block-&gt;check.</p>
<p>block-&gt;filters must have been allocated, but they don't need to be initialized (possible existing filter options are not freed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">block</td><td>Destination for Block options </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() (and also free() if an error occurs). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer. This must be at least block-&gt;header_size bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Decoding was successful. block-&gt;header_size bytes were read from the input buffer.</li>
<li>LZMA_OPTIONS_ERROR: The Block Header specifies some unsupported options such as unsupported filters. This can happen also if block-&gt;version was set to a too low value compared to what would be required to properly represent the information stored in the Block Header.</li>
<li>LZMA_DATA_ERROR: Block Header is corrupt, for example, the CRC32 doesn't match.</li>
<li>LZMA_PROG_ERROR: Invalid arguments, for example block-&gt;header_size is invalid or block-&gt;filters is NULL.</li>
</ul>
</dd></dl>
<p>Block Header stores Compressed Size, but Index has Unpadded Size. If the application has already parsed the Index and is now decoding Blocks, it can calculate Compressed Size from Unpadded Size. This function does exactly that with error checking:</p>
<ul>
<li>Compressed Size calculated from Unpadded Size must be positive integer, that is, Unpadded Size must be big enough that after Block Header and Check fields there's still at least one byte for Compressed Size.</li>
<li>If Compressed Size was present in Block Header, the new value calculated from Unpadded Size is compared against the value from Block Header.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function must be called <em>after</em> decoding the Block Header field so that it can properly validate Compressed Size if it was present in Block Header.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>Block options: block-&gt;header_size must already be set with lzma_block_header_size(). </td></tr>
    <tr><td class="paramname">unpadded_size</td><td>Unpadded Size from the Index field in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: block-&gt;compressed_size was set successfully.</li>
<li>LZMA_DATA_ERROR: unpadded_size is too small compared to block-&gt;header_size and lzma_check_size(block-&gt;check).</li>
<li>LZMA_PROG_ERROR: Some values are invalid. For example, block-&gt;header_size must be a multiple of four and between 8 and 1024 inclusive.</li>
</ul>
</dd></dl>
<p>Valid actions for lzma_code() are LZMA_RUN, LZMA_SYNC_FLUSH (only if the filter chain supports it), and LZMA_FINISH.</p>
<p>The Block encoder encodes the Block Data, Block Padding, and Check value. It does NOT encode the Block Header which can be encoded with lzma_block_header_encode().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">block</td><td>Block options: block-&gt;version, block-&gt;check, and block-&gt;filters must have been initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: All good, continue with lzma_code().</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_UNSUPPORTED_CHECK: block-&gt;check specifies a Check ID that is not supported by this build of liblzma. Initializing the encoder failed.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>Valid actions for lzma_code() are LZMA_RUN and LZMA_FINISH. Using LZMA_FINISH is not required. It is supported only for convenience.</p>
<p>The Block decoder decodes the Block Data, Block Padding, and Check value. It does NOT decode the Block Header which can be decoded with lzma_block_header_decode().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">block</td><td>Block options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: All good, continue with lzma_code().</li>
<li>LZMA_PROG_ERROR</li>
<li>LZMA_MEM_ERROR</li>
</ul>
</dd></dl>
<p>In contrast to the multi-call encoder initialized with lzma_block_encoder(), this function encodes also the Block Header. This is required to make it possible to write appropriate Block Header also in case the data isn't compressible, and different filter chain has to be used to encode the data in uncompressed form using uncompressed chunks of the LZMA2 filter.</p>
<p>When the data isn't compressible, header_size, compressed_size, and uncompressed_size are set just like when the data was compressible, but it is possible that header_size is too small to hold the filter chain specified in block-&gt;filters, because that isn't necessarily the filter chain that was actually used to encode the data. lzma_block_unpadded_size() still works normally, because it doesn't read the filters array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">block</td><td>Block options: block-&gt;version, block-&gt;check, and block-&gt;filters must have been initialized. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This is like lzma_block_buffer_encode() except this doesn't try to compress the data and instead encodes the data using LZMA2 uncompressed chunks. The required output buffer size can be determined with lzma_block_buffer_bound().</p>
<p>Since the data won't be compressed, this function ignores block-&gt;filters. This function doesn't take <a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> because this function doesn't allocate any memory from the heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">block</td><td>Block options: block-&gt;version, block-&gt;check, and block-&gt;filters must have been initialized. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This is single-call equivalent of lzma_block_decoder(), and requires that the caller has already decoded Block Header and checked its memory usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">block</td><td>Block options </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Decoding was successful.</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_BUF_ERROR: Output buffer was too small.</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afb10da1ad1ba54c0f8a0c7543999ed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb10da1ad1ba54c0f8a0c7543999ed5b">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate Unpadded Size. </p>
<p>Calculate the total encoded size of a Block.</p>
<p>The Index field stores Unpadded Size and Uncompressed Size. The latter can be taken directly from the <a class="el" href="structlzma__block.html" title="Options for the Block and Block Header encoders and decoders.">lzma_block</a> structure after coding a Block, but Unpadded Size needs to be calculated from Block Header Size, Compressed Size, and size of the Check field. This is where this function is needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>Block options: block-&gt;header_size must already be set with lzma_block_header_size().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unpadded Size on success, or zero on error.</dd></dl>
<p>This is equivalent to lzma_block_unpadded_size() except that the returned value includes the size of the Block Padding field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>Block options: block-&gt;header_size must already be set with lzma_block_header_size().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, total encoded size of the Block. On error, zero is returned.</dd></dl>
<p>Calculate Unpadded Size.</p>
<p>Get the memory usage of decoder filter chain.</p>
<p>Calculate CRC64 using the polynomial from the ECMA-182 standard.</p>
<p>This function is used similarly to lzma_crc32().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the input buffer </td></tr>
    <tr><td class="paramname">size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramname">crc</td><td>Previously returned CRC value. This is used to calculate the CRC of a big buffer in smaller chunks. Set to zero when starting a new calculation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated CRC value, which can be passed to this function again to continue CRC calculation. </dd></dl>

</div>
</div>
<a id="a14b9103a517ed8104855f6e14c9cf7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b9103a517ed8104855f6e14c9cf7ed">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate maximum output size for single-call Block encoding. </p>
<p>This is equivalent to lzma_stream_buffer_bound() but for .xz Blocks. See the documentation of lzma_stream_buffer_bound().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uncompressed_size</td><td>Size of the data to be encoded with the single-call Block encoder.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum output size in bytes for single-call Block encoding.</dd></dl>
<p>Calculate maximum output size for single-call Block encoding.</p>
<p>Raw x86 BCJ decoder.</p>
<p>Raw x86 BCJ encoder.</p>
<p>Raw RISC-V BCJ decoder.</p>
<p>Raw RISC-V BCJ encoder.</p>
<p>Raw ARM64 BCJ decoder.</p>
<p>This is for special use cases only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_offset</td><td>The lowest 32 bits of the offset in the executable being filtered. For the ARM64 filter, this must be a multiple of four. For the very best results, this should also be in sync with 4096-byte page boundaries in the executable due to how ARM64's ADRP instruction works. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer to be filtered in place </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes that were processed in <code>buf</code>. This is at most <code>size</code>. With the ARM64 filter, the return value is always a multiple of 4, and at most 3 bytes are left unfiltered.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>5.7.1alpha</dd></dl>
<p>See lzma_bcj_arm64_encode().</p>
<dl class="section since"><dt>Since</dt><dd>5.7.1alpha</dd></dl>
<p>This is for special use cases only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_offset</td><td>The lowest 32 bits of the offset in the executable being filtered. For the RISC-V filter, this must be a multiple of 2. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer to be filtered in place </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes that were processed in <code>buf</code>. This is at most <code>size</code>. With the RISC-V filter, the return value is always a multiple of 2, and at most 7 bytes are left unfiltered.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>5.7.1alpha</dd></dl>
<p>See lzma_bcj_riscv_encode().</p>
<dl class="section since"><dt>Since</dt><dd>5.7.1alpha</dd></dl>
<p>This is for special use cases only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_offset</td><td>The lowest 32 bits of the offset in the executable being filtered. For the x86 filter, all values are valid. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer to be filtered in place </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes that were processed in <code>buf</code>. This is at most <code>size</code>. For the x86 filter, the return value is always a multiple of 1, and at most 4 bytes are left unfiltered.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>5.7.1alpha</dd></dl>
<p>See lzma_bcj_x86_encode().</p>
<dl class="section since"><dt>Since</dt><dd>5.7.1alpha </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
