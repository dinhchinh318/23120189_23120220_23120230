<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PHONE MANAGEMENT: UI-UX/SFML/include/lzma/filter.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PHONE MANAGEMENT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_669fb1e37e108424641b4492fae48a00.html">UI-UX</a></li><li class="navelem"><a class="el" href="dir_fef68780f280e2b18cfa5347c2a48e1f.html">SFML</a></li><li class="navelem"><a class="el" href="dir_ab5abbf355e63c20d9132dc628d44eb6.html">include</a></li><li class="navelem"><a class="el" href="dir_40a6e693a8331efa19c2f3d27b8cdc28.html">lzma</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">filter.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Common filter related types and functions.  
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="filter_8h__dep__incl.png" border="0" usemap="#UI-UX_2SFML_2include_2lzma_2filter_8hdep" alt=""/></div>
<map name="UI-UX_2SFML_2include_2lzma_2filter_8hdep" id="UI-UX_2SFML_2include_2lzma_2filter_8hdep">
<area shape="rect" title="Common filter related types and functions." alt="" coords="5,5,156,47"/>
<area shape="rect" href="lzma_8h_source.html" title=" " alt="" coords="5,95,156,136"/>
</map>
</div>
</div>
<p><a href="filter_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__filter.html">lzma_filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter options.  <a href="structlzma__filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab33c0cc1728bf390e5b84f8bce1928ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#ab33c0cc1728bf390e5b84f8bce1928ba">LZMA_FILTERS_MAX</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ab33c0cc1728bf390e5b84f8bce1928ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of filters in a chain.  <a href="filter_8h.html#ab33c0cc1728bf390e5b84f8bce1928ba">More...</a><br /></td></tr>
<tr class="separator:ab33c0cc1728bf390e5b84f8bce1928ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41aa51eeb53190404439c31d8e9c97cd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a41aa51eeb53190404439c31d8e9c97cd">LZMA_STR_ALL_FILTERS</a>&#160;&#160;&#160;UINT32_C(0x01)</td></tr>
<tr class="memdesc:a41aa51eeb53190404439c31d8e9c97cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow or show all filters.  <a href="filter_8h.html#a41aa51eeb53190404439c31d8e9c97cd">More...</a><br /></td></tr>
<tr class="separator:a41aa51eeb53190404439c31d8e9c97cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc33f4c0c7b5d3ae36acc0437a904339"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#adc33f4c0c7b5d3ae36acc0437a904339">LZMA_STR_NO_VALIDATION</a>&#160;&#160;&#160;UINT32_C(0x02)</td></tr>
<tr class="memdesc:adc33f4c0c7b5d3ae36acc0437a904339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not validate the filter chain in lzma_str_to_filters()  <a href="filter_8h.html#adc33f4c0c7b5d3ae36acc0437a904339">More...</a><br /></td></tr>
<tr class="separator:adc33f4c0c7b5d3ae36acc0437a904339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a775f6a78d28ca136acfb51ad5fa02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a09a775f6a78d28ca136acfb51ad5fa02">LZMA_STR_ENCODER</a>&#160;&#160;&#160;UINT32_C(0x10)</td></tr>
<tr class="memdesc:a09a775f6a78d28ca136acfb51ad5fa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringify encoder options.  <a href="filter_8h.html#a09a775f6a78d28ca136acfb51ad5fa02">More...</a><br /></td></tr>
<tr class="separator:a09a775f6a78d28ca136acfb51ad5fa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0f3fc03bdb84a294cdd53a98783104"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a8a0f3fc03bdb84a294cdd53a98783104">LZMA_STR_DECODER</a>&#160;&#160;&#160;UINT32_C(0x20)</td></tr>
<tr class="memdesc:a8a0f3fc03bdb84a294cdd53a98783104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringify decoder options.  <a href="filter_8h.html#a8a0f3fc03bdb84a294cdd53a98783104">More...</a><br /></td></tr>
<tr class="separator:a8a0f3fc03bdb84a294cdd53a98783104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e9ac4ae5829b092262223256141a29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a87e9ac4ae5829b092262223256141a29">LZMA_STR_GETOPT_LONG</a>&#160;&#160;&#160;UINT32_C(0x40)</td></tr>
<tr class="memdesc:a87e9ac4ae5829b092262223256141a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce xz-compatible getopt_long() syntax.  <a href="filter_8h.html#a87e9ac4ae5829b092262223256141a29">More...</a><br /></td></tr>
<tr class="separator:a87e9ac4ae5829b092262223256141a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0113c47caf98a735db2297936c5e857"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#ac0113c47caf98a735db2297936c5e857">LZMA_STR_NO_SPACES</a>&#160;&#160;&#160;UINT32_C(0x80)</td></tr>
<tr class="memdesc:ac0113c47caf98a735db2297936c5e857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use two dashes "--" instead of a space to separate filters.  <a href="filter_8h.html#ac0113c47caf98a735db2297936c5e857">More...</a><br /></td></tr>
<tr class="separator:ac0113c47caf98a735db2297936c5e857"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a71707b447b0a5e87a731bb844241f0f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a71707b447b0a5e87a731bb844241f0f9">LZMA_API</a> (<a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a>) lzma_filter_encoder_is_supported(<a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> id) lzma_nothrow lzma_attr_const</td></tr>
<tr class="memdesc:a71707b447b0a5e87a731bb844241f0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given Filter ID is supported for encoding.  <a href="filter_8h.html#a71707b447b0a5e87a731bb844241f0f9">More...</a><br /></td></tr>
<tr class="separator:a71707b447b0a5e87a731bb844241f0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa374a38a9ce71bc6adc66835dda7d5de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#aa374a38a9ce71bc6adc66835dda7d5de">LZMA_API</a> (<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>) lzma_filters_copy(const <a class="el" href="structlzma__filter.html">lzma_filter</a> *src</td></tr>
<tr class="memdesc:aa374a38a9ce71bc6adc66835dda7d5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the filters array.  <a href="filter_8h.html#aa374a38a9ce71bc6adc66835dda7d5de">More...</a><br /></td></tr>
<tr class="separator:aa374a38a9ce71bc6adc66835dda7d5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a90e15cd06a7b98b047629a482963b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a3a90e15cd06a7b98b047629a482963b6">LZMA_API</a> (void) lzma_filters_free(<a class="el" href="structlzma__filter.html">lzma_filter</a> *filters</td></tr>
<tr class="memdesc:a3a90e15cd06a7b98b047629a482963b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the options in the array of <a class="el" href="structlzma__filter.html" title="Filter options.">lzma_filter</a> structures.  <a href="filter_8h.html#a3a90e15cd06a7b98b047629a482963b6">More...</a><br /></td></tr>
<tr class="separator:a3a90e15cd06a7b98b047629a482963b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796c2785cf7c32dd911393c249f77c74"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#a796c2785cf7c32dd911393c249f77c74">LZMA_API</a> (uint64_t) lzma_raw_encoder_memusage(const <a class="el" href="structlzma__filter.html">lzma_filter</a> *filters) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:a796c2785cf7c32dd911393c249f77c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate approximate memory requirements for raw encoder.  <a href="filter_8h.html#a796c2785cf7c32dd911393c249f77c74">More...</a><br /></td></tr>
<tr class="separator:a796c2785cf7c32dd911393c249f77c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca03772e94b026c7fcd76b87f2603c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filter_8h.html#aeca03772e94b026c7fcd76b87f2603c9">LZMA_API</a> (const char *) lzma_str_to_filters(const char *str</td></tr>
<tr class="memdesc:aeca03772e94b026c7fcd76b87f2603c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string to a filter chain.  <a href="filter_8h.html#aeca03772e94b026c7fcd76b87f2603c9">More...</a><br /></td></tr>
<tr class="separator:aeca03772e94b026c7fcd76b87f2603c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a78b14163c73e6f87593e2b0931cb7128"><td class="memItemLeft" align="right" valign="top"><a id="a78b14163c73e6f87593e2b0931cb7128"></a>
<a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>dest</b></td></tr>
<tr class="separator:a78b14163c73e6f87593e2b0931cb7128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dfa08958c6bd3092701a90023a46d0"><td class="memItemLeft" align="right" valign="top"><a id="a36dfa08958c6bd3092701a90023a46d0"></a>
<a class="el" href="structlzma__filter.html">lzma_filter</a> const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator lzma_nothrow&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_attr_warn_unused_result</b></td></tr>
<tr class="separator:a36dfa08958c6bd3092701a90023a46d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa416c99bf48eef342f1aef5bbb01e2d1"><td class="memItemLeft" align="right" valign="top"><a id="aa416c99bf48eef342f1aef5bbb01e2d1"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_nothrow</b></td></tr>
<tr class="separator:aa416c99bf48eef342f1aef5bbb01e2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e105dab2d99cd376bbb46b18831feb5"><td class="memItemLeft" align="right" valign="top"><a id="a0e105dab2d99cd376bbb46b18831feb5"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>allocator</b></td></tr>
<tr class="separator:a0e105dab2d99cd376bbb46b18831feb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e844efa4146a7e2e2e7bfda377a6ac"><td class="memItemLeft" align="right" valign="top"><a id="aa6e844efa4146a7e2e2e7bfda377a6ac"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>in</b></td></tr>
<tr class="separator:aa6e844efa4146a7e2e2e7bfda377a6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f87fba249664a288be5c92cbffeb1a0"><td class="memItemLeft" align="right" valign="top"><a id="a2f87fba249664a288be5c92cbffeb1a0"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>in_size</b></td></tr>
<tr class="separator:a2f87fba249664a288be5c92cbffeb1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e75faab56db79cfe33d7c3d30a27a8"><td class="memItemLeft" align="right" valign="top"><a id="af3e75faab56db79cfe33d7c3d30a27a8"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>out</b></td></tr>
<tr class="separator:af3e75faab56db79cfe33d7c3d30a27a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349a406bbf028a7cb93cec74ca2f2e3b"><td class="memItemLeft" align="right" valign="top"><a id="a349a406bbf028a7cb93cec74ca2f2e3b"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t uint8_t size_t *&#160;</td><td class="memItemRight" valign="bottom"><b>out_pos</b></td></tr>
<tr class="separator:a349a406bbf028a7cb93cec74ca2f2e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cba32b90ff3c96ec91d2e92c832d82"><td class="memItemLeft" align="right" valign="top"><a id="ab0cba32b90ff3c96ec91d2e92c832d82"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t *&#160;</td><td class="memItemRight" valign="bottom"><b>in_pos</b></td></tr>
<tr class="separator:ab0cba32b90ff3c96ec91d2e92c832d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298f012a84ab4e11c05d3e169b8c4c02"><td class="memItemLeft" align="right" valign="top"><a id="a298f012a84ab4e11c05d3e169b8c4c02"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>props</b></td></tr>
<tr class="separator:a298f012a84ab4e11c05d3e169b8c4c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fab4a3c42ce2234ac82ce6a0c2c24dc"><td class="memItemLeft" align="right" valign="top"><a id="a7fab4a3c42ce2234ac82ce6a0c2c24dc"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>error_pos</b></td></tr>
<tr class="separator:a7fab4a3c42ce2234ac82ce6a0c2c24dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cb1068d3a36591cb45503e0ca6ff65"><td class="memItemLeft" align="right" valign="top"><a id="a88cb1068d3a36591cb45503e0ca6ff65"></a>
int <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>filters</b></td></tr>
<tr class="separator:a88cb1068d3a36591cb45503e0ca6ff65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccc734ffc82bcaec59b2f116aa395cb"><td class="memItemLeft" align="right" valign="top"><a id="acccc734ffc82bcaec59b2f116aa395cb"></a>
int <a class="el" href="structlzma__filter.html">lzma_filter</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>flags</b></td></tr>
<tr class="separator:acccc734ffc82bcaec59b2f116aa395cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633cc14f4b99fe96eb640b51b4a193cb"><td class="memItemLeft" align="right" valign="top"><a id="a633cc14f4b99fe96eb640b51b4a193cb"></a>
<a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><b>filter_id</b></td></tr>
<tr class="separator:a633cc14f4b99fe96eb640b51b4a193cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common filter related types and functions. </p>
<dl class="section note"><dt>Note</dt><dd>Never include this file directly. Use &lt;<a class="el" href="lzma_8h_source.html">lzma.h</a>&gt; instead. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab33c0cc1728bf390e5b84f8bce1928ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33c0cc1728bf390e5b84f8bce1928ba">&#9670;&nbsp;</a></span>LZMA_FILTERS_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_FILTERS_MAX&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of filters in a chain. </p>
<p>A filter chain can have 1-4 filters, of which three are allowed to change the size of the data. Usually only one or two filters are needed. </p>

</div>
</div>
<a id="a41aa51eeb53190404439c31d8e9c97cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41aa51eeb53190404439c31d8e9c97cd">&#9670;&nbsp;</a></span>LZMA_STR_ALL_FILTERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_STR_ALL_FILTERS&#160;&#160;&#160;UINT32_C(0x01)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow or show all filters. </p>
<p>By default only the filters supported in the .xz format are accept by lzma_str_to_filters() or shown by lzma_str_list_filters(). </p>

</div>
</div>
<a id="a8a0f3fc03bdb84a294cdd53a98783104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0f3fc03bdb84a294cdd53a98783104">&#9670;&nbsp;</a></span>LZMA_STR_DECODER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_STR_DECODER&#160;&#160;&#160;UINT32_C(0x20)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stringify decoder options. </p>
<p>Show the filter-specific options that the decoder will use. This may be useful for showing what filter options were decoded from file headers. </p>

</div>
</div>
<a id="a09a775f6a78d28ca136acfb51ad5fa02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a775f6a78d28ca136acfb51ad5fa02">&#9670;&nbsp;</a></span>LZMA_STR_ENCODER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_STR_ENCODER&#160;&#160;&#160;UINT32_C(0x10)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stringify encoder options. </p>
<p>Show the filter-specific options that the encoder will use. This may be useful for verbose diagnostic messages.</p>
<p>Note that if options were decoded from .xz headers then the encoder options may be undefined. This flag shouldn't be used in such a situation. </p>

</div>
</div>
<a id="a87e9ac4ae5829b092262223256141a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e9ac4ae5829b092262223256141a29">&#9670;&nbsp;</a></span>LZMA_STR_GETOPT_LONG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_STR_GETOPT_LONG&#160;&#160;&#160;UINT32_C(0x40)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce xz-compatible getopt_long() syntax. </p>
<p>That is, "delta:dist=2 lzma2:dict=4MiB,pb=1,lp=1" becomes "--delta=dist=2 --lzma2=dict=4MiB,pb=1,lp=1".</p>
<p>This syntax is compatible with xz 5.0.0 as long as the filters and their options are supported too. </p>

</div>
</div>
<a id="ac0113c47caf98a735db2297936c5e857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0113c47caf98a735db2297936c5e857">&#9670;&nbsp;</a></span>LZMA_STR_NO_SPACES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_STR_NO_SPACES&#160;&#160;&#160;UINT32_C(0x80)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use two dashes "--" instead of a space to separate filters. </p>
<p>That is, "delta:dist=2 lzma2:pb=1,lp=1" becomes "delta:dist=2--lzma2:pb=1,lp=1". This looks slightly odd but this kind of strings should be usable on the command line without quoting. However, it is possible that future versions with new filter options might produce strings that require shell quoting anyway as the exact set of possible characters isn't frozen for now.</p>
<p>It is guaranteed that the single quote (') will never be used in filter chain strings (even if LZMA_STR_NO_SPACES isn't used). </p>

</div>
</div>
<a id="adc33f4c0c7b5d3ae36acc0437a904339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc33f4c0c7b5d3ae36acc0437a904339">&#9670;&nbsp;</a></span>LZMA_STR_NO_VALIDATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_STR_NO_VALIDATION&#160;&#160;&#160;UINT32_C(0x02)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not validate the filter chain in lzma_str_to_filters() </p>
<p>By default lzma_str_to_filters() can return an error if the filter chain as a whole isn't usable in the .xz format or in the raw encoder or decoder. With this flag, this validation is skipped. This flag doesn't affect the handling of the individual filter options. To allow non-.xz filters also LZMA_STR_ALL_FILTERS is needed. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aeca03772e94b026c7fcd76b87f2603c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca03772e94b026c7fcd76b87f2603c9">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string to a filter chain. </p>
<p>This tries to make it easier to write applications that allow users to set custom compression options. This only handles the filter configuration (including presets) but not the number of threads, block size, check type, or memory limits.</p>
<p>The input string can be either a preset or a filter chain. Presets begin with a digit 0-9 and may be followed by zero or more flags which are lower-case letters. Currently only "e" is supported, matching LZMA_PRESET_EXTREME. For partial xz command line syntax compatibility, a preset string may start with a single dash "-".</p>
<p>A filter chain consists of one or more "filtername:opt1=value1,opt2=value2" strings separated by one or more spaces. Leading and trailing spaces are ignored. All names and values must be lower-case. Extra commas in the option list are ignored. The order of filters is significant: when encoding, the uncompressed input data goes to the leftmost filter first. Normally "lzma2" is the last filter in the chain.</p>
<p>If one wishes to avoid spaces, for example, to avoid shell quoting, it is possible to use two dashes "--" instead of spaces to separate the filters.</p>
<p>For xz command line compatibility, each filter may be prefixed with two dashes "--" and the colon ":" separating the filter name from the options may be replaced with an equals sign "=".</p>
<p>By default, only filters that can be used in the .xz format are accepted. To allow all filters (LZMA1) use the flag LZMA_STR_ALL_FILTERS.</p>
<p>By default, very basic validation is done for the filter chain as a whole, for example, that LZMA2 is only used as the last filter in the chain. The validation isn't perfect though and it's possible that this function succeeds but using the filter chain for encoding or decoding will still result in LZMA_OPTIONS_ERROR. To disable this validation, use the flag LZMA_STR_NO_VALIDATION.</p>
<p>The available filter names and their options are available via lzma_str_list_filters(). See the xz man page for the description of filter names and options.</p>
<p>For command line applications, below is an example how an error message can be displayed. Note the use of an empty string for the field width. If "^" was used there it would create an off-by-one error except at the very beginning of the line.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *str = ...; <span class="comment">// From user</span></div>
<div class="line"><a class="code" href="structlzma__filter.html">lzma_filter</a> filters[<a class="code" href="filter_8h.html#ab33c0cc1728bf390e5b84f8bce1928ba">LZMA_FILTERS_MAX</a> + 1];</div>
<div class="line"><span class="keywordtype">int</span> pos;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *msg = lzma_str_to_filters(str, &amp;pos, filters, 0, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (msg != NULL) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;%s: Error in XZ compression options:\n&quot;</span>, argv[0]);</div>
<div class="line">    printf(<span class="stringliteral">&quot;%s: %s\n&quot;</span>, argv[0], str);</div>
<div class="line">    printf(<span class="stringliteral">&quot;%s: %*s^\n&quot;</span>, argv[0], errpos, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    printf(<span class="stringliteral">&quot;%s: %s\n&quot;</span>, argv[0], msg);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>User-supplied string describing a preset or a filter chain. If a default value is needed and you don't know what would be good, use "6" since that is the default preset in xz too. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error_pos</td><td>If this isn't NULL, this value will be set on both success and on all errors. This tells the location of the error in the string. This is an int to make it straightforward to use this as printf() field width. The value is guaranteed to be in the range [0, INT_MAX] even if strlen(str) somehow was greater than INT_MAX. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filters</td><td>An array of <a class="el" href="structlzma__filter.html" title="Filter options.">lzma_filter</a> structures. There must be LZMA_FILTERS_MAX + 1 (that is, five) elements in the array. The old contents are ignored so it doesn't need to be initialized. This array is modified only if this function returns NULL. Once the allocated filter options are no longer needed, lzma_filters_free() can be used to free the options (it doesn't free the filters array itself). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>Bitwise-or of zero or more of the flags LZMA_STR_ALL_FILTERS and LZMA_STR_NO_VALIDATION. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, NULL is returned. On error, a statically-allocated error message is returned which together with the error_pos should give some idea what is wrong. </dd></dl>

</div>
</div>
<a id="a71707b447b0a5e87a731bb844241f0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71707b447b0a5e87a731bb844241f0f9">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the given Filter ID is supported for encoding. </p>
<p>Test if the given Filter ID is supported for decoding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Filter ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lzma_bool:<ul>
<li>true if the Filter ID is supported for encoding by this liblzma build.</li>
<li>false otherwise.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Filter ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lzma_bool:<ul>
<li>true if the Filter ID is supported for decoding by this liblzma build.</li>
<li>false otherwise.</li>
</ul>
</dd></dl>
<p>Test if the given Filter ID is supported for encoding.</p>
<p>Test if the given Check ID is supported.</p>
<p>Locate a Block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Iterator initialized with lzma_index_iter_init() </td></tr>
    <tr><td class="paramname">mode</td><td>Specify what kind of information the caller wants to get. See lzma_index_iter_mode for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lzma_bool:<ul>
<li>true if no Block or Stream matching the mode is found. *iter is not updated (failure).</li>
<li>false if the next Block or Stream matching the mode was found. *iter is updated (success).</li>
</ul>
</dd></dl>
<p>If it is possible to seek in the .xz file, it is possible to parse the Index field(s) and use lzma_index_iter_locate() to do random-access reading with granularity of Block size.</p>
<p>If the target is smaller than the uncompressed size of the Stream (can be checked with lzma_index_uncompressed_size()):</p><ul>
<li>Information about the Stream and Block containing the requested uncompressed offset is stored into *iter.</li>
<li>Internal state of the iterator is adjusted so that lzma_index_iter_next() can be used to read subsequent Blocks or Streams.</li>
</ul>
<p>If the target is greater than the uncompressed size of the Stream, *iter is not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Iterator that was earlier initialized with lzma_index_iter_init(). </td></tr>
    <tr><td class="paramname">target</td><td>Uncompressed target offset which the caller would like to locate from the Stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lzma_bool:<ul>
<li>true if the target is greater than or equal to the uncompressed size of the Stream (failure)</li>
<li>false if the target is smaller than the uncompressed size of the Stream (success)</li>
</ul>
</dd></dl>
<p>Test if the given Filter ID is supported for encoding.</p>
<p>Test if the given Check ID is supported.</p>
<p>Set a compression preset to <a class="el" href="structlzma__options__lzma.html" title="Options specific to the LZMA1 and LZMA2 filters.">lzma_options_lzma</a> structure.</p>
<p>Test if given compression mode is supported.</p>
<p>It is safe to call this with a value that isn't listed in lzma_match_finder enumeration; the return value will be false.</p>
<p>There is no way to list which match finders are available in this particular liblzma version and build. It would be useless, because a new match finder, which the application developer wasn't aware, could require giving additional options to the encoder that the older match finders don't need.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">match_finder</td><td>Match finder ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lzma_bool:<ul>
<li>true if the match finder is supported by this liblzma build.</li>
<li>false otherwise.</li>
</ul>
</dd></dl>
<p>It is safe to call this with a value that isn't listed in lzma_mode enumeration; the return value will be false.</p>
<p>There is no way to list which modes are available in this particular liblzma version and build. It would be useless, because a new compression mode, which the application developer wasn't aware, could require giving additional options to the encoder that the older modes don't need.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Mode ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lzma_bool:<ul>
<li>true if the compression mode is supported by this liblzma build.</li>
<li>false otherwise.</li>
</ul>
</dd></dl>
<p>0 is the fastest and 9 is the slowest. These match the switches -0 .. -9 of the xz command line tool. In addition, it is possible to bitwise-or flags to the preset. Currently only LZMA_PRESET_EXTREME is supported. The flags are defined in <a class="el" href="container_8h.html" title="File formats.">container.h</a>, because the flags are used also with lzma_easy_encoder().</p>
<p>The preset levels are subject to changes between liblzma versions.</p>
<p>This function is available only if LZMA1 or LZMA2 encoder has been enabled when building liblzma.</p>
<p>If features (like certain match finders) have been disabled at build time, then the function may return success (false) even though the resulting LZMA1/LZMA2 options may not be usable for encoder initialization (LZMA_OPTIONS_ERROR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">options</td><td>Pointer to LZMA1 or LZMA2 options to be filled </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">preset</td><td>Preset level bitwse-ORed with preset flags</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lzma_bool:<ul>
<li>true if the preset is not supported (failure).</li>
<li>false otherwise (success). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa374a38a9ce71bc6adc66835dda7d5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa374a38a9ce71bc6adc66835dda7d5de">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the filters array. </p>
<p><a class="el" href="structList.html">List</a> available filters and/or their options (for help message)</p>
<p>Convert a filter chain to a string.</p>
<p>Decode Filter Flags from given buffer.</p>
<p>Encode Filter Flags into given buffer.</p>
<p>Calculate encoded size of a Filter Flags field.</p>
<p>Decode the Filter Properties field.</p>
<p>Encode the Filter Properties field.</p>
<p>Get the size of the Filter Properties field.</p>
<p>Single-call raw decoder.</p>
<p>Single-call raw encoder.</p>
<p>Update the filter chain in the encoder.</p>
<p>Initialize raw decoder.</p>
<p>Initialize raw encoder.</p>
<p>Copy the Filter IDs and filter-specific options from src to dest. Up to LZMA_FILTERS_MAX filters are copied, plus the terminating .id == LZMA_VLI_UNKNOWN. Thus, dest should have at least LZMA_FILTERS_MAX + 1 elements space unless the caller knows that src is smaller than that.</p>
<p>Unless the filter-specific options is NULL, the Filter ID has to be supported by liblzma, because liblzma needs to know the size of every filter-specific options structure. The filter-specific options are not validated. If options is NULL, any unsupported Filter IDs are copied without returning an error.</p>
<p>Old filter-specific options in dest are not freed, so dest doesn't need to be initialized by the caller in any way.</p>
<p>If an error occurs, memory possibly already allocated by this function is always freed. liblzma versions older than 5.2.7 may modify the dest array and leave its contents in an undefined state if an error occurs. liblzma 5.2.7 and newer only modify the dest array when returning LZMA_OK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">src</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Destination filter array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR: Unsupported Filter ID and its options is not NULL.</li>
<li>LZMA_PROG_ERROR: src or dest is NULL.</li>
</ul>
</dd></dl>
<p>This function may be useful when implementing custom file formats.</p>
<p>The 'action' with lzma_code() can be LZMA_RUN, LZMA_SYNC_FLUSH (if the filter chain supports it), or LZMA_FINISH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>The initialization of raw decoder goes similarly to raw encoder.</p>
<p>The 'action' with lzma_code() can be LZMA_RUN or LZMA_FINISH. Using LZMA_FINISH is not required, it is supported just for convenience.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This function may be called after lzma_code() has returned LZMA_STREAM_END when LZMA_FULL_BARRIER, LZMA_FULL_FLUSH, or LZMA_SYNC_FLUSH was used:</p>
<ul>
<li>After LZMA_FULL_BARRIER or LZMA_FULL_FLUSH: Single-threaded .xz Stream encoder (lzma_stream_encoder()) and (since liblzma 5.4.0) multi-threaded Stream encoder (lzma_stream_encoder_mt()) allow setting a new filter chain to be used for the next Block(s).</li>
<li>After LZMA_SYNC_FLUSH: Raw encoder (lzma_raw_encoder()), Block encoder (lzma_block_encoder()), and single-threaded .xz Stream encoder (lzma_stream_encoder()) allow changing certain filter-specific options in the middle of encoding. The actual filters in the chain (Filter IDs) must not be changed! Currently only the lc, lp, and pb options of LZMA2 (not LZMA1) can be changed this way.</li>
<li>In the future some filters might allow changing some of their options without any barrier or flushing but currently such filters don't exist.</li>
</ul>
<p>This function may also be called when no data has been compressed yet although this is rarely useful. In that case, this function will behave as if LZMA_FULL_FLUSH (Stream encoders) or LZMA_SYNC_FLUSH (Raw or Block encoder) had been used right before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_MEMLIMIT_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is no function to calculate how big output buffer would surely be big enough. (lzma_stream_buffer_bound() works only for lzma_stream_buffer_encode(); raw encoder won't necessarily meet that bound.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Decoding was successful.</li>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This function may be useful when implementing custom file formats using the raw encoder and decoder.</p>
<dl class="section note"><dt>Note</dt><dd>This function validates the Filter ID, but does not necessarily validate the options. Thus, it is possible that this returns LZMA_OK while the following call to lzma_properties_encode() returns LZMA_OPTIONS_ERROR.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Pointer to uint32_t to hold the size of the properties </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>Filter ID and options (the size of the properties may vary depending on the options)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Even this function won't validate more options than actually necessary. Thus, it is possible that encoding the properties succeeds but using the same options to initialize the encoder will fail.</dd>
<dd>
If lzma_properties_size() indicated that the size of the Filter Properties field is zero, calling lzma_properties_encode() is not required, but it won't do any harm either.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>Filter ID and options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">props</td><td>Buffer to hold the encoded options. The size of the buffer must have been already determined with lzma_properties_size().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>filter-&gt;id must have been set to the correct Filter ID. filter-&gt;options doesn't need to be initialized (it's not freed by this function). The decoded options will be stored in filter-&gt;options; it's application's responsibility to free it when appropriate. filter-&gt;options is set to NULL if there are no properties or if an error occurs. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). and in case of an error, also free(). </td></tr>
    <tr><td class="paramname">props</td><td>Input buffer containing the properties. </td></tr>
    <tr><td class="paramname">props_size</td><td>Size of the properties. This must be the exact size; giving too much or too little input will return LZMA_OPTIONS_ERROR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
</ul>
</dd></dl>
<p>Knowing the size of Filter Flags is useful to know when allocating memory to hold the encoded Filter Flags.</p>
<dl class="section note"><dt>Note</dt><dd>If you need to calculate size of <a class="el" href="structList.html">List</a> of Filter Flags, you need to loop over every <a class="el" href="structlzma__filter.html" title="Filter options.">lzma_filter</a> entry.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Pointer to integer to hold the calculated size </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>Filter ID and associated options whose encoded size is to be calculated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: *size set successfully. Note that this doesn't guarantee that filter-&gt;options is valid, thus lzma_filter_flags_encode() may still fail.</li>
<li>LZMA_OPTIONS_ERROR: Unknown Filter ID or unsupported options.</li>
<li>LZMA_PROG_ERROR: Invalid options</li>
</ul>
</dd></dl>
<p>In contrast to some functions, this doesn't allocate the needed buffer. This is due to how this function is used internally by liblzma.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>Filter ID and options to be encoded </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>out[*out_pos] is the next write position. This is updated by the encoder. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>out[out_size] is the first byte to not write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_OPTIONS_ERROR: Invalid or unsupported options.</li>
<li>LZMA_PROG_ERROR: Invalid options or not enough output buffer space (you should have checked it with lzma_filter_flags_size()).</li>
</ul>
</dd></dl>
<p>The decoded result is stored into *filter. The old value of filter-&gt;options is not free()d. If anything other than LZMA_OK is returned, filter-&gt;options is set to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">filter</td><td>Destination filter. The decoded Filter ID will be stored in filter-&gt;id. If options are needed they will be allocated and the pointer will be stored in filter-&gt;options. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>Use cases:</p>
<ul>
<li>Verbose output showing the full encoder options to the user (use LZMA_STR_ENCODER in flags)</li>
<li>Showing the filters and options that are required to decode a file (use LZMA_STR_DECODER in flags)</li>
<li>Showing the filter names without any options in informational messages where the technical details aren't important (no flags). In this case the .options in the filters array are ignored and may be NULL even if a filter has a mandatory options structure.</li>
</ul>
<p>Note that even if the filter chain was specified using a preset, the resulting filter chain isn't reversed to a preset. So if you specify "6" to lzma_str_to_filters() then lzma_str_from_filters() will produce a string containing "lzma2".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">str</td><td>On success *str will be set to point to an allocated string describing the given filter chain. Old value is ignored. On error *str is always set to NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>Bitwise-or of zero or more of the flags LZMA_STR_ENCODER, LZMA_STR_DECODER, LZMA_STR_GETOPT_LONG, and LZMA_STR_NO_SPACES. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_OPTIONS_ERROR: Empty filter chain (filters[0].id == LZMA_VLI_UNKNOWN) or the filter chain includes a Filter ID that is not supported by this function.</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>If a filter_id is given then only one line is created which contains the filter name. If LZMA_STR_ENCODER or LZMA_STR_DECODER is used then the options read by the encoder or decoder are printed on the same line.</p>
<p>If filter_id is LZMA_VLI_UNKNOWN then all supported .xz-compatible filters are listed:</p>
<ul>
<li>If neither LZMA_STR_ENCODER nor LZMA_STR_DECODER is used then the supported filter names are listed on a single line separated by spaces.</li>
<li>If LZMA_STR_ENCODER or LZMA_STR_DECODER is used then filters and the supported options are listed one filter per line. There won't be a newline after the last filter.</li>
<li>If LZMA_STR_ALL_FILTERS is used then the list will include also those filters that cannot be used in the .xz format (LZMA1).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>On success *str will be set to point to an allocated string listing the filters and options. Old value is ignored. On error *str is always set to NULL. </td></tr>
    <tr><td class="paramname">filter_id</td><td>Filter ID or LZMA_VLI_UNKNOWN. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitwise-or of zero or more of the flags LZMA_STR_ALL_FILTERS, LZMA_STR_ENCODER, LZMA_STR_DECODER, and LZMA_STR_GETOPT_LONG. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_OPTIONS_ERROR: Unsupported filter_id or flags</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a796c2785cf7c32dd911393c249f77c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796c2785cf7c32dd911393c249f77c74">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate approximate memory requirements for raw encoder. </p>
<p>Calculate approximate memory requirements for raw decoder.</p>
<p>This function can be used to calculate the memory requirements for Block and Stream encoders too because Block and Stream encoders don't need significantly more memory than raw encoder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of memory required for the given filter chain when encoding or UINT64_MAX on error.</dd></dl>
<p>This function can be used to calculate the memory requirements for Block and Stream decoders too because Block and Stream decoders don't need significantly more memory than raw decoder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of memory required for the given filter chain when decoding or UINT64_MAX on error.</dd></dl>
<p>Calculate approximate memory requirements for raw encoder.</p>
<p>Calculate Unpadded Size.</p>
<p>Get the memory usage of decoder filter chain.</p>
<p>Calculate CRC64 using the polynomial from the ECMA-182 standard.</p>
<p>This function is used similarly to lzma_crc32().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the input buffer </td></tr>
    <tr><td class="paramname">size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramname">crc</td><td>Previously returned CRC value. This is used to calculate the CRC of a big buffer in smaller chunks. Set to zero when starting a new calculation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated CRC value, which can be passed to this function again to continue CRC calculation. </dd></dl>

</div>
</div>
<a id="a3a90e15cd06a7b98b047629a482963b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a90e15cd06a7b98b047629a482963b6">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the options in the array of <a class="el" href="structlzma__filter.html" title="Filter options.">lzma_filter</a> structures. </p>
<p>This frees the filter chain options. The filters array itself is not freed.</p>
<p>The filters array must have at most LZMA_FILTERS_MAX + 1 elements including the terminating element which must have .id = LZMA_VLI_UNKNOWN. For all elements before the terminating element:</p><ul>
<li>options will be freed using the given <a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> or, if allocator is NULL, using free().</li>
<li>options will be set to NULL.</li>
<li>id will be set to LZMA_VLI_UNKNOWN.</li>
</ul>
<p>If filters is NULL, this does nothing. Again, this never frees the filters array itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="afilter_8h_html_ab33c0cc1728bf390e5b84f8bce1928ba"><div class="ttname"><a href="filter_8h.html#ab33c0cc1728bf390e5b84f8bce1928ba">LZMA_FILTERS_MAX</a></div><div class="ttdeci">#define LZMA_FILTERS_MAX</div><div class="ttdoc">Maximum number of filters in a chain.</div><div class="ttdef"><b>Definition:</b> filter.h:24</div></div>
<div class="ttc" id="astructlzma__filter_html"><div class="ttname"><a href="structlzma__filter.html">lzma_filter</a></div><div class="ttdoc">Filter options.</div><div class="ttdef"><b>Definition:</b> filter.h:41</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
