<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PHONE MANAGEMENT: asyncio.base_events.BaseEventLoop Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PHONE MANAGEMENT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceasyncio.html">asyncio</a></li><li class="navelem"><a class="el" href="namespaceasyncio_1_1base__events.html">base_events</a></li><li class="navelem"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html">BaseEventLoop</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classasyncio_1_1base__events_1_1BaseEventLoop-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">asyncio.base_events.BaseEventLoop Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for asyncio.base_events.BaseEventLoop:</div>
<div class="dyncontent">
<div class="center"><img src="classasyncio_1_1base__events_1_1BaseEventLoop__inherit__graph.png" border="0" usemap="#asyncio_8base__events_8BaseEventLoop_inherit__map" alt="Inheritance graph"/></div>
<map name="asyncio_8base__events_8BaseEventLoop_inherit__map" id="asyncio_8base__events_8BaseEventLoop_inherit__map">
<area shape="rect" title=" " alt="" coords="300,120,495,161"/>
<area shape="rect" href="classasyncio_1_1proactor__events_1_1BaseProactorEventLoop.html" title=" " alt="" coords="558,23,743,64"/>
<area shape="rect" href="classasyncio_1_1selector__events_1_1BaseSelectorEventLoop.html" title=" " alt="" coords="559,120,742,161"/>
<area shape="rect" href="classtest_1_1test__asyncio_1_1test__futures_1_1SimpleEvilEventLoop.html" title=" " alt="" coords="543,185,759,227"/>
<area shape="rect" href="classasyncio_1_1events_1_1AbstractEventLoop.html" title=" " alt="" coords="5,127,252,154"/>
<area shape="rect" href="classasyncio_1_1windows__events_1_1ProactorEventLoop.html" title=" " alt="" coords="809,5,1051,47"/>
<area shape="rect" href="classasyncio_1_1unix__events_1_1__UnixSelectorEventLoop.html" title=" " alt="" coords="840,71,1020,112"/>
<area shape="rect" href="classasyncio_1_1windows__events_1_1__WindowsSelectorEventLoop.html" title=" " alt="" coords="825,136,1035,177"/>
<area shape="rect" href="classtest_1_1test__asyncio_1_1test__selector__events_1_1TestBaseSelectorEventLoop.html" title=" " alt="" coords="807,202,1053,258"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for asyncio.base_events.BaseEventLoop:</div>
<div class="dyncontent">
<div class="center"><img src="classasyncio_1_1base__events_1_1BaseEventLoop__coll__graph.png" border="0" usemap="#asyncio_8base__events_8BaseEventLoop_coll__map" alt="Collaboration graph"/></div>
<map name="asyncio_8base__events_8BaseEventLoop_coll__map" id="asyncio_8base__events_8BaseEventLoop_coll__map">
<area shape="rect" title=" " alt="" coords="31,80,226,121"/>
<area shape="rect" href="classasyncio_1_1events_1_1AbstractEventLoop.html" title=" " alt="" coords="5,5,252,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa5c41f4dca676a13809210a1483e83c5"><td class="memItemLeft" align="right" valign="top"><a id="aa5c41f4dca676a13809210a1483e83c5"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__init__</b> (self)</td></tr>
<tr class="separator:aa5c41f4dca676a13809210a1483e83c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c947c6f67011259b70e038a7851bb2f"><td class="memItemLeft" align="right" valign="top"><a id="a2c947c6f67011259b70e038a7851bb2f"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__repr__</b> (self)</td></tr>
<tr class="separator:a2c947c6f67011259b70e038a7851bb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4b8144546c554b48bf3f14e116f8d1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#abd4b8144546c554b48bf3f14e116f8d1">create_future</a> (self)</td></tr>
<tr class="separator:abd4b8144546c554b48bf3f14e116f8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc47457b896a1b7950642ca63f7754f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a0dc47457b896a1b7950642ca63f7754f">create_task</a> (self, coro, *name=None, context=None)</td></tr>
<tr class="separator:a0dc47457b896a1b7950642ca63f7754f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6934b40be3b1d7dcaea761ea2eeb7bc1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a6934b40be3b1d7dcaea761ea2eeb7bc1">set_task_factory</a> (self, factory)</td></tr>
<tr class="separator:a6934b40be3b1d7dcaea761ea2eeb7bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df367c993d00c9266b39cc899c8472a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a7df367c993d00c9266b39cc899c8472a">get_task_factory</a> (self)</td></tr>
<tr class="separator:a7df367c993d00c9266b39cc899c8472a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25119ef4a9a9128bf3c55e3c47823520"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a25119ef4a9a9128bf3c55e3c47823520">shutdown_asyncgens</a> (self)</td></tr>
<tr class="separator:a25119ef4a9a9128bf3c55e3c47823520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407c8bbb9aaf8ee4407ae07794d5033f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a407c8bbb9aaf8ee4407ae07794d5033f">shutdown_default_executor</a> (self, timeout=None)</td></tr>
<tr class="separator:a407c8bbb9aaf8ee4407ae07794d5033f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2735643e577be7a5e69db41b3e6a4d5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#af2735643e577be7a5e69db41b3e6a4d5">run_forever</a> (self)</td></tr>
<tr class="separator:af2735643e577be7a5e69db41b3e6a4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a3d195d47ced704013a9e3ebb02da6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#ab7a3d195d47ced704013a9e3ebb02da6">run_until_complete</a> (self, future)</td></tr>
<tr class="separator:ab7a3d195d47ced704013a9e3ebb02da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa925fcc0b1fd0ada20aa38fc793a66a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#afa925fcc0b1fd0ada20aa38fc793a66a">stop</a> (self)</td></tr>
<tr class="separator:afa925fcc0b1fd0ada20aa38fc793a66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980d68b6681be79b7289970f38712925"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a980d68b6681be79b7289970f38712925">close</a> (self)</td></tr>
<tr class="separator:a980d68b6681be79b7289970f38712925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9de3c18cd4beb4ece1a0b6c22f5714a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#ab9de3c18cd4beb4ece1a0b6c22f5714a">is_closed</a> (self)</td></tr>
<tr class="separator:ab9de3c18cd4beb4ece1a0b6c22f5714a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbaeb2dae19f638375c2b9b880461190"><td class="memItemLeft" align="right" valign="top"><a id="abbaeb2dae19f638375c2b9b880461190"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__del__</b> (self, _warn=<a class="el" href="namespacewarnings.html#a920589c7e697e9afe3328f93fea87b17">warnings.warn</a>)</td></tr>
<tr class="separator:abbaeb2dae19f638375c2b9b880461190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2ad8d56c0a3ebd38fc65ad24a20b65"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a4f2ad8d56c0a3ebd38fc65ad24a20b65">is_running</a> (self)</td></tr>
<tr class="separator:a4f2ad8d56c0a3ebd38fc65ad24a20b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bef083d75d9b0ae3feec8c017fae06f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a5bef083d75d9b0ae3feec8c017fae06f">time</a> (self)</td></tr>
<tr class="separator:a5bef083d75d9b0ae3feec8c017fae06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62a35f8a65f5305ae0bfc945705fdc4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#aa62a35f8a65f5305ae0bfc945705fdc4">call_later</a> (self, delay, callback, *args, context=None)</td></tr>
<tr class="separator:aa62a35f8a65f5305ae0bfc945705fdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76bf86c74d9c5c4678fa6d2b196ba8e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#ac76bf86c74d9c5c4678fa6d2b196ba8e">call_at</a> (self, when, callback, *args, context=None)</td></tr>
<tr class="separator:ac76bf86c74d9c5c4678fa6d2b196ba8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98379c32c7f80893b35af6033a5ce11b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a98379c32c7f80893b35af6033a5ce11b">call_soon</a> (self, callback, *args, context=None)</td></tr>
<tr class="separator:a98379c32c7f80893b35af6033a5ce11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcee7601e4786a333c59b754fea926e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#abfcee7601e4786a333c59b754fea926e">call_soon_threadsafe</a> (self, callback, *args, context=None)</td></tr>
<tr class="separator:abfcee7601e4786a333c59b754fea926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864bce0669f87dd3120543ba21ebcc8c"><td class="memItemLeft" align="right" valign="top"><a id="a864bce0669f87dd3120543ba21ebcc8c"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>run_in_executor</b> (self, executor, func, *args)</td></tr>
<tr class="separator:a864bce0669f87dd3120543ba21ebcc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fc3be5bc5c2a5bd637466595fe2d3a"><td class="memItemLeft" align="right" valign="top"><a id="aa0fc3be5bc5c2a5bd637466595fe2d3a"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>set_default_executor</b> (self, executor)</td></tr>
<tr class="separator:aa0fc3be5bc5c2a5bd637466595fe2d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b27d2b949baeffd9fbfee6e66f56b27"><td class="memItemLeft" align="right" valign="top"><a id="a6b27d2b949baeffd9fbfee6e66f56b27"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>getaddrinfo</b> (self, host, port, *family=0, type=0, proto=0, flags=0)</td></tr>
<tr class="separator:a6b27d2b949baeffd9fbfee6e66f56b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa2c93dc8b6bb549e9d44d65ca9c7b2"><td class="memItemLeft" align="right" valign="top"><a id="a0aa2c93dc8b6bb549e9d44d65ca9c7b2"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>getnameinfo</b> (self, sockaddr, flags=0)</td></tr>
<tr class="separator:a0aa2c93dc8b6bb549e9d44d65ca9c7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af228c75643baf4939fc4705e24ad0cb7"><td class="memItemLeft" align="right" valign="top"><a id="af228c75643baf4939fc4705e24ad0cb7"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_sendfile</b> (self, sock, file, offset=0, count=None, *fallback=True)</td></tr>
<tr class="separator:af228c75643baf4939fc4705e24ad0cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1700070b6115200f0cbf94372a836924"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a1700070b6115200f0cbf94372a836924">create_connection</a> (self, protocol_factory, host=None, port=None, *ssl=None, family=0, proto=0, flags=0, sock=None, local_addr=None, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, happy_eyeballs_delay=None, interleave=None, all_errors=False)</td></tr>
<tr class="separator:a1700070b6115200f0cbf94372a836924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5940885522a735cda10a659074ca1e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#afc5940885522a735cda10a659074ca1e">sendfile</a> (self, transport, file, offset=0, count=None, *fallback=True)</td></tr>
<tr class="separator:afc5940885522a735cda10a659074ca1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c3d49e324a18706284e85bcf099ecc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#ae1c3d49e324a18706284e85bcf099ecc">start_tls</a> (self, transport, protocol, sslcontext, *server_side=False, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None)</td></tr>
<tr class="separator:ae1c3d49e324a18706284e85bcf099ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4d4ddc133c611b586d9beca317a835"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a0a4d4ddc133c611b586d9beca317a835">create_datagram_endpoint</a> (self, protocol_factory, local_addr=None, remote_addr=None, *family=0, proto=0, flags=0, reuse_port=None, allow_broadcast=None, sock=None)</td></tr>
<tr class="separator:a0a4d4ddc133c611b586d9beca317a835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc4b919e9edd4fc9ac8a6930ac8b200"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a4cc4b919e9edd4fc9ac8a6930ac8b200">create_server</a> (self, protocol_factory, host=None, port=None, *family=socket.AF_UNSPEC, flags=socket.AI_PASSIVE, sock=None, backlog=100, ssl=None, reuse_address=None, reuse_port=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, start_serving=True)</td></tr>
<tr class="separator:a4cc4b919e9edd4fc9ac8a6930ac8b200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992792cd3da9befc2b5e86dd27349fac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a992792cd3da9befc2b5e86dd27349fac">connect_accepted_socket</a> (self, protocol_factory, sock, *ssl=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None)</td></tr>
<tr class="separator:a992792cd3da9befc2b5e86dd27349fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3c381e0efe853d62f6968d383cf575"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a2a3c381e0efe853d62f6968d383cf575">connect_read_pipe</a> (self, protocol_factory, pipe)</td></tr>
<tr class="separator:a2a3c381e0efe853d62f6968d383cf575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc433e0b24ebf84ba08b4d344efc9e61"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#abc433e0b24ebf84ba08b4d344efc9e61">connect_write_pipe</a> (self, protocol_factory, pipe)</td></tr>
<tr class="separator:abc433e0b24ebf84ba08b4d344efc9e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faaed18753ed0d7369e4f00ded2ac35"><td class="memItemLeft" align="right" valign="top"><a id="a2faaed18753ed0d7369e4f00ded2ac35"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>subprocess_shell</b> (self, protocol_factory, cmd, *stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=False, shell=True, bufsize=0, encoding=None, errors=None, text=None, **kwargs)</td></tr>
<tr class="separator:a2faaed18753ed0d7369e4f00ded2ac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8df77899edbea553bc7956219403f5"><td class="memItemLeft" align="right" valign="top"><a id="aba8df77899edbea553bc7956219403f5"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>subprocess_exec</b> (self, protocol_factory, program, *args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=False, shell=False, bufsize=0, encoding=None, errors=None, text=None, **kwargs)</td></tr>
<tr class="separator:aba8df77899edbea553bc7956219403f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137a9ae72f6ea6e8f070584293ecc142"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a137a9ae72f6ea6e8f070584293ecc142">get_exception_handler</a> (self)</td></tr>
<tr class="separator:a137a9ae72f6ea6e8f070584293ecc142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94675eaec58386406ab7e2d5ab862511"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a94675eaec58386406ab7e2d5ab862511">set_exception_handler</a> (self, handler)</td></tr>
<tr class="separator:a94675eaec58386406ab7e2d5ab862511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f0ad767b8b5dd0911bd7657bdb6270"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a78f0ad767b8b5dd0911bd7657bdb6270">default_exception_handler</a> (self, context)</td></tr>
<tr class="separator:a78f0ad767b8b5dd0911bd7657bdb6270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c4e6803f8df077b238753f3e5e4921"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a42c4e6803f8df077b238753f3e5e4921">call_exception_handler</a> (self, context)</td></tr>
<tr class="separator:a42c4e6803f8df077b238753f3e5e4921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b86b365dc8a57ad8a7223b9fcf5dcc"><td class="memItemLeft" align="right" valign="top"><a id="ae1b86b365dc8a57ad8a7223b9fcf5dcc"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>get_debug</b> (self)</td></tr>
<tr class="separator:ae1b86b365dc8a57ad8a7223b9fcf5dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfd15e27776681650464a03d9a76198"><td class="memItemLeft" align="right" valign="top"><a id="abbfd15e27776681650464a03d9a76198"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>set_debug</b> (self, enabled)</td></tr>
<tr class="separator:abbfd15e27776681650464a03d9a76198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classasyncio_1_1events_1_1AbstractEventLoop')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a></td></tr>
<tr class="memitem:a5013993cc977bb88b93a8666a3470b0c inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a5013993cc977bb88b93a8666a3470b0c">shutdown_default_executor</a> (self)</td></tr>
<tr class="separator:a5013993cc977bb88b93a8666a3470b0c inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd380bf16df7dd12f598c1f7e0a6a63 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a2dd380bf16df7dd12f598c1f7e0a6a63"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>create_connection</b> (self, protocol_factory, host=None, port=None, *ssl=None, family=0, proto=0, flags=0, sock=None, local_addr=None, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, happy_eyeballs_delay=None, interleave=None)</td></tr>
<tr class="separator:a2dd380bf16df7dd12f598c1f7e0a6a63 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320fc977ebde2e7930898bf63d305cb9 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a320fc977ebde2e7930898bf63d305cb9"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>create_unix_connection</b> (self, protocol_factory, path=None, *ssl=None, sock=None, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None)</td></tr>
<tr class="separator:a320fc977ebde2e7930898bf63d305cb9 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd28eab6b3fce628d4b5947306d5acd inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#abcd28eab6b3fce628d4b5947306d5acd">create_unix_server</a> (self, protocol_factory, path=None, *sock=None, backlog=100, ssl=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, start_serving=True)</td></tr>
<tr class="separator:abcd28eab6b3fce628d4b5947306d5acd inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16515bf200bd711dc2446fb5c5124c64 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a16515bf200bd711dc2446fb5c5124c64">create_datagram_endpoint</a> (self, protocol_factory, local_addr=None, remote_addr=None, *family=0, proto=0, flags=0, reuse_address=None, reuse_port=None, allow_broadcast=None, sock=None)</td></tr>
<tr class="separator:a16515bf200bd711dc2446fb5c5124c64 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa27e26eae8bed78440461d2848608f inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a4aa27e26eae8bed78440461d2848608f"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>subprocess_shell</b> (self, protocol_factory, cmd, *stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kwargs)</td></tr>
<tr class="separator:a4aa27e26eae8bed78440461d2848608f inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25feda476e28b25661e92067133377d inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="aa25feda476e28b25661e92067133377d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>subprocess_exec</b> (self, protocol_factory, *args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kwargs)</td></tr>
<tr class="separator:aa25feda476e28b25661e92067133377d inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edc8f81bd8d977e2f511d4135efd017 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a1edc8f81bd8d977e2f511d4135efd017"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>add_reader</b> (self, fd, callback, *args)</td></tr>
<tr class="separator:a1edc8f81bd8d977e2f511d4135efd017 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a328557e34fc23e44d18939d1818c4 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a21a328557e34fc23e44d18939d1818c4"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>remove_reader</b> (self, fd)</td></tr>
<tr class="separator:a21a328557e34fc23e44d18939d1818c4 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7440ed9024e60259b31aba6f5757762b inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a7440ed9024e60259b31aba6f5757762b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>add_writer</b> (self, fd, callback, *args)</td></tr>
<tr class="separator:a7440ed9024e60259b31aba6f5757762b inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3552c0ce0081bce7a5416210ea69567d inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a3552c0ce0081bce7a5416210ea69567d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>remove_writer</b> (self, fd)</td></tr>
<tr class="separator:a3552c0ce0081bce7a5416210ea69567d inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472115671360c4dd2fcf52c758b9c2f2 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a472115671360c4dd2fcf52c758b9c2f2"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_recv</b> (self, sock, nbytes)</td></tr>
<tr class="separator:a472115671360c4dd2fcf52c758b9c2f2 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c595d470509aed3c0447672874a62b3 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a7c595d470509aed3c0447672874a62b3"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_recv_into</b> (self, sock, buf)</td></tr>
<tr class="separator:a7c595d470509aed3c0447672874a62b3 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1937bb7fff8059b33065812fddb139f3 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a1937bb7fff8059b33065812fddb139f3"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_recvfrom</b> (self, sock, bufsize)</td></tr>
<tr class="separator:a1937bb7fff8059b33065812fddb139f3 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bd246c7618053971c5c486df55041b inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a98bd246c7618053971c5c486df55041b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_recvfrom_into</b> (self, sock, buf, nbytes=0)</td></tr>
<tr class="separator:a98bd246c7618053971c5c486df55041b inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c155d5cd37f20a6fa0df29135f9ce49 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a9c155d5cd37f20a6fa0df29135f9ce49"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_sendall</b> (self, sock, data)</td></tr>
<tr class="separator:a9c155d5cd37f20a6fa0df29135f9ce49 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39aad429d79d5a74b75954536f9b0096 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a39aad429d79d5a74b75954536f9b0096"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_sendto</b> (self, sock, data, address)</td></tr>
<tr class="separator:a39aad429d79d5a74b75954536f9b0096 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64978a2031000a60d991f22eaf7510a4 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a64978a2031000a60d991f22eaf7510a4"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_connect</b> (self, sock, address)</td></tr>
<tr class="separator:a64978a2031000a60d991f22eaf7510a4 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdf825f59e25d82993ff21a58b63c3b inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a8cdf825f59e25d82993ff21a58b63c3b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_accept</b> (self, sock)</td></tr>
<tr class="separator:a8cdf825f59e25d82993ff21a58b63c3b inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938aa96b11db1d2f2f2c25abee6f4b85 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="a938aa96b11db1d2f2f2c25abee6f4b85"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>add_signal_handler</b> (self, sig, callback, *args)</td></tr>
<tr class="separator:a938aa96b11db1d2f2f2c25abee6f4b85 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f3104ebdf8b15c09eaa5269fe8c712 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memItemLeft" align="right" valign="top"><a id="ac6f3104ebdf8b15c09eaa5269fe8c712"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>remove_signal_handler</b> (self, sig)</td></tr>
<tr class="separator:ac6f3104ebdf8b15c09eaa5269fe8c712 inherit pub_methods_classasyncio_1_1events_1_1AbstractEventLoop"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab8e37634e6bdbc6fde665cb03c26e7f9"><td class="memItemLeft" align="right" valign="top"><a id="ab8e37634e6bdbc6fde665cb03c26e7f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>slow_callback_duration</b></td></tr>
<tr class="separator:ab8e37634e6bdbc6fde665cb03c26e7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac76bf86c74d9c5c4678fa6d2b196ba8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76bf86c74d9c5c4678fa6d2b196ba8e">&#9670;&nbsp;</a></span>call_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.call_at </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Like call_later(), but uses an absolute time.

Absolute time corresponds to the event loop's time() method.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a42c4e6803f8df077b238753f3e5e4921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c4e6803f8df077b238753f3e5e4921">&#9670;&nbsp;</a></span>call_exception_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.call_exception_handler </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Call the current event loop's exception handler.

The context argument is a dict containing the following keys:

- 'message': Error message;
- 'exception' (optional): Exception object;
- 'future' (optional): Future instance;
- 'task' (optional): Task instance;
- 'handle' (optional): Handle instance;
- 'protocol' (optional): Protocol instance;
- 'transport' (optional): Transport instance;
- 'socket' (optional): Socket instance;
- 'asyncgen' (optional): Asynchronous generator that caused
                 the exception.

New keys maybe introduced in the future.

Note: do not overload this method in an event loop subclass.
For custom exception handling, use the
`set_exception_handler()` method.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="aa62a35f8a65f5305ae0bfc945705fdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62a35f8a65f5305ae0bfc945705fdc4">&#9670;&nbsp;</a></span>call_later()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.call_later </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Arrange for a callback to be called at a given time.

Return a Handle: an opaque object with a cancel() method that
can be used to cancel the call.

The delay can be an int or float, expressed in seconds.  It is
always relative to the current time.

Each callback will be called exactly once.  If two callbacks
are scheduled for exactly the same time, it is undefined which
will be called first.

Any positional arguments after the callback will be passed to
the callback when it is called.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a98379c32c7f80893b35af6033a5ce11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98379c32c7f80893b35af6033a5ce11b">&#9670;&nbsp;</a></span>call_soon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.call_soon </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Arrange for a callback to be called as soon as possible.

This operates as a FIFO queue: callbacks are called in the
order in which they are registered.  Each callback will be
called exactly once.

Any positional arguments after the callback will be passed to
the callback when it is called.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="abfcee7601e4786a333c59b754fea926e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcee7601e4786a333c59b754fea926e">&#9670;&nbsp;</a></span>call_soon_threadsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.call_soon_threadsafe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Like call_soon(), but thread-safe.</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a980d68b6681be79b7289970f38712925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980d68b6681be79b7289970f38712925">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Close the event loop.

This clears the queues and shuts down the executor,
but does not wait for the executor to finish.

The event loop must not be running.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#abd74b51251a6e880e9248f6c2ea7c82f">asyncio.events.AbstractEventLoop</a>.</p>

<p>Reimplemented in <a class="el" href="classasyncio_1_1proactor__events_1_1BaseProactorEventLoop.html#a98f3fcc00378c14a7c59889454cc8961">asyncio.proactor_events.BaseProactorEventLoop</a>, <a class="el" href="classasyncio_1_1selector__events_1_1BaseSelectorEventLoop.html#af4edf592ea3982f3a7506adb73e20021">asyncio.selector_events.BaseSelectorEventLoop</a>, and <a class="el" href="classasyncio_1_1unix__events_1_1__UnixSelectorEventLoop.html#a9922b58386ba9179c17522096ecaaeb6">asyncio.unix_events._UnixSelectorEventLoop</a>.</p>

</div>
</div>
<a id="a992792cd3da9befc2b5e86dd27349fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992792cd3da9befc2b5e86dd27349fac">&#9670;&nbsp;</a></span>connect_accepted_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.connect_accepted_socket </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>ssl</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_handshake_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_shutdown_timeout</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Handle an accepted connection.

This is used by servers that accept connections outside of
asyncio, but use asyncio to handle connections.

This method is a coroutine.  When completed, the coroutine
returns a (transport, protocol) pair.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a0a596c3e2da22758c983add8f6df070c">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a2a3c381e0efe853d62f6968d383cf575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3c381e0efe853d62f6968d383cf575">&#9670;&nbsp;</a></span>connect_read_pipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.connect_read_pipe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Register read pipe in event loop. Set the pipe to non-blocking mode.

protocol_factory should instantiate object with Protocol interface.
pipe is a file-like object.
Return pair (transport, protocol), where transport supports the
ReadTransport interface.</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a7ac62792db163b5f65d930e219091ef1">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="abc433e0b24ebf84ba08b4d344efc9e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc433e0b24ebf84ba08b4d344efc9e61">&#9670;&nbsp;</a></span>connect_write_pipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.connect_write_pipe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Register write pipe in event loop.

protocol_factory should instantiate object with BaseProtocol interface.
Pipe is file-like object already switched to nonblocking.
Return pair (transport, protocol), where transport support
WriteTransport interface.</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a9a63358afa691b5762e8e50815dfce6d">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a1700070b6115200f0cbf94372a836924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1700070b6115200f0cbf94372a836924">&#9670;&nbsp;</a></span>create_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.create_connection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>host</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>ssl</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>family</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proto</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sock</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>local_addr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>server_hostname</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_handshake_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_shutdown_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>happy_eyeballs_delay</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interleave</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>all_errors</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Connect to a TCP server.

Create a streaming transport connection to a given internet host and
port: socket family AF_INET or socket.AF_INET6 depending on host (or
family if specified), socket type SOCK_STREAM. protocol_factory must be
a callable returning a protocol instance.

This method is a coroutine which will try to establish the connection
in the background.  When successful, the coroutine returns a
(transport, protocol) pair.
</pre> 
</div>
</div>
<a id="a0a4d4ddc133c611b586d9beca317a835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4d4ddc133c611b586d9beca317a835">&#9670;&nbsp;</a></span>create_datagram_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.create_datagram_endpoint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>local_addr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>remote_addr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>family</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proto</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reuse_port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_broadcast</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sock</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create datagram connection.</pre> 
</div>
</div>
<a id="abd4b8144546c554b48bf3f14e116f8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4b8144546c554b48bf3f14e116f8d1">&#9670;&nbsp;</a></span>create_future()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.create_future </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a Future object attached to the loop.</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a4cc4b919e9edd4fc9ac8a6930ac8b200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc4b919e9edd4fc9ac8a6930ac8b200">&#9670;&nbsp;</a></span>create_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.create_server </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>host</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>family</em> = <code>socket.AF_UNSPEC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>socket.AI_PASSIVE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sock</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>backlog</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reuse_address</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reuse_port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_handshake_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_shutdown_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start_serving</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a TCP server.

The host parameter can be a string, in that case the TCP server is
bound to host and port.

The host parameter can also be a sequence of strings and in that case
the TCP server is bound to all hosts of the sequence. If a host
appears multiple times (possibly indirectly e.g. when hostnames
resolve to the same IP address), the server is only bound once to that
host.

Return a Server object which can be used to stop the service.

This method is a coroutine.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#ac133bfa1628aa683e060bd940b2e147d">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a0dc47457b896a1b7950642ca63f7754f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc47457b896a1b7950642ca63f7754f">&#9670;&nbsp;</a></span>create_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.create_task </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Schedule a coroutine object.

Return a task object.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a78f0ad767b8b5dd0911bd7657bdb6270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f0ad767b8b5dd0911bd7657bdb6270">&#9670;&nbsp;</a></span>default_exception_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.default_exception_handler </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Default exception handler.

This is called when an exception occurs and no exception
handler is set, and can be called by a custom exception
handler that wants to defer to the default behavior.

This default handler logs the error message and other
context-dependent information.  In debug mode, a truncated
stack trace is also appended showing where the given object
(e.g. a handle or future or task) was created, if any.

The context parameter has the same meaning as in
`call_exception_handler()`.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a137a9ae72f6ea6e8f070584293ecc142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137a9ae72f6ea6e8f070584293ecc142">&#9670;&nbsp;</a></span>get_exception_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.get_exception_handler </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an exception handler, or None if the default one is in use.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a7df367c993d00c9266b39cc899c8472a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df367c993d00c9266b39cc899c8472a">&#9670;&nbsp;</a></span>get_task_factory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.get_task_factory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a task factory, or None if the default one is in use.</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="ab9de3c18cd4beb4ece1a0b6c22f5714a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9de3c18cd4beb4ece1a0b6c22f5714a">&#9670;&nbsp;</a></span>is_closed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.is_closed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if the event loop was closed.</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#aad0bfc0fa7a42c3308e6afc468a62103">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a4f2ad8d56c0a3ebd38fc65ad24a20b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2ad8d56c0a3ebd38fc65ad24a20b65">&#9670;&nbsp;</a></span>is_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.is_running </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if the event loop is running.</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a34ff17e3bc3b74359a51bd48c56bd19f">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="af2735643e577be7a5e69db41b3e6a4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2735643e577be7a5e69db41b3e6a4d5">&#9670;&nbsp;</a></span>run_forever()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.run_forever </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Run until stop() is called.</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a402be2dddfe330eb3374cdbc75710181">asyncio.events.AbstractEventLoop</a>.</p>

<p>Reimplemented in <a class="el" href="classasyncio_1_1windows__events_1_1ProactorEventLoop.html#a834d555a1b0cc5377f5a5140e7a27edc">asyncio.windows_events.ProactorEventLoop</a>.</p>

</div>
</div>
<a id="ab7a3d195d47ced704013a9e3ebb02da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a3d195d47ced704013a9e3ebb02da6">&#9670;&nbsp;</a></span>run_until_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.run_until_complete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>future</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Run until the Future is done.

If the argument is a coroutine, it is wrapped in a Task.

WARNING: It would be disastrous to call run_until_complete()
with the same coroutine twice -- it would wrap it in two
different Tasks and that can't be good.

Return the Future's result, or raise its exception.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a4b04818ffd47d04742efaff6d8458b47">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="afc5940885522a735cda10a659074ca1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5940885522a735cda10a659074ca1e">&#9670;&nbsp;</a></span>sendfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.sendfile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>count</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>fallback</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a file to transport.

Return the total number of bytes which were sent.

The method uses high-performance os.sendfile if available.

file must be a regular file object opened in binary mode.

offset tells from where to start reading the file. If specified,
count is the total number of bytes to transmit as opposed to
sending the file until EOF is reached. File position is updated on
return or also in case of error in which case file.tell()
can be used to figure out the number of bytes
which were sent.

fallback set to True makes asyncio to manually read and send
the file when the platform does not support the sendfile syscall
(e.g. Windows or SSL socket on Unix).

Raise SendfileNotAvailableError if the system does not support
sendfile syscall and fallback is False.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a14d7094f997135456cd89b4d2fb97cf6">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a94675eaec58386406ab7e2d5ab862511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94675eaec58386406ab7e2d5ab862511">&#9670;&nbsp;</a></span>set_exception_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.set_exception_handler </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set handler as the new event loop exception handler.

If handler is None, the default exception handler will
be set.

If handler is a callable object, it should have a
signature matching '(loop, context)', where 'loop'
will be a reference to the active event loop, 'context'
will be a dict object (see `call_exception_handler()`
documentation for details about context).
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a6934b40be3b1d7dcaea761ea2eeb7bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6934b40be3b1d7dcaea761ea2eeb7bc1">&#9670;&nbsp;</a></span>set_task_factory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.set_task_factory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set a task factory that will be used by loop.create_task().

If factory is None the default task factory will be set.

If factory is a callable, it should have a signature matching
'(loop, coro)', where 'loop' will be a reference to the active
event loop, 'coro' will be a coroutine object.  The callable
must return a Future.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a25119ef4a9a9128bf3c55e3c47823520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25119ef4a9a9128bf3c55e3c47823520">&#9670;&nbsp;</a></span>shutdown_asyncgens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.shutdown_asyncgens </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Shutdown all active asynchronous generators.</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#acb68ef561c3f4873e5019e21a17bb926">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a407c8bbb9aaf8ee4407ae07794d5033f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407c8bbb9aaf8ee4407ae07794d5033f">&#9670;&nbsp;</a></span>shutdown_default_executor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.shutdown_default_executor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Schedule the shutdown of the default executor.

The timeout parameter specifies the amount of time the executor will
be given to finish joining. The default value is None, which means
that the executor will be given an unlimited amount of time.
</pre> 
</div>
</div>
<a id="ae1c3d49e324a18706284e85bcf099ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c3d49e324a18706284e85bcf099ecc">&#9670;&nbsp;</a></span>start_tls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.start_tls </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sslcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>server_side</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>server_hostname</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_handshake_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_shutdown_timeout</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Upgrade transport to TLS.

Return a new transport that *protocol* should start using
immediately.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a6ce8f478e851993280015e4b99c310e2">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="afa925fcc0b1fd0ada20aa38fc793a66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa925fcc0b1fd0ada20aa38fc793a66a">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.stop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Stop running the event loop.

Every callback already scheduled will still run.  This simply informs
run_forever to stop looping after a complete iteration.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#ab35b5f540bee1a817aae8becc048ecbd">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<a id="a5bef083d75d9b0ae3feec8c017fae06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bef083d75d9b0ae3feec8c017fae06f">&#9670;&nbsp;</a></span>time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.base_events.BaseEventLoop.time </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the time according to the event loop's clock.

This is a float expressed in seconds since an epoch, but the
epoch, precision, accuracy and drift are unspecified and may
differ per event loop.
</pre> 
<p>Reimplemented from <a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">asyncio.events.AbstractEventLoop</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>UI-UX/SFML/lib/python3.12/asyncio/base_events.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
