<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PHONE MANAGEMENT: asyncio.events.AbstractEventLoop Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PHONE MANAGEMENT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceasyncio.html">asyncio</a></li><li class="navelem"><a class="el" href="namespaceasyncio_1_1events.html">events</a></li><li class="navelem"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html">AbstractEventLoop</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classasyncio_1_1events_1_1AbstractEventLoop-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">asyncio.events.AbstractEventLoop Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for asyncio.events.AbstractEventLoop:</div>
<div class="dyncontent">
<div class="center"><img src="classasyncio_1_1events_1_1AbstractEventLoop__inherit__graph.png" border="0" usemap="#asyncio_8events_8AbstractEventLoop_inherit__map" alt="Inheritance graph"/></div>
<map name="asyncio_8events_8AbstractEventLoop_inherit__map" id="asyncio_8events_8AbstractEventLoop_inherit__map">
<area shape="rect" title=" " alt="" coords="5,127,252,154"/>
<area shape="rect" href="classasyncio_1_1base__events_1_1BaseEventLoop.html" title=" " alt="" coords="300,120,495,161"/>
<area shape="rect" href="classasyncio_1_1proactor__events_1_1BaseProactorEventLoop.html" title=" " alt="" coords="558,23,743,64"/>
<area shape="rect" href="classasyncio_1_1selector__events_1_1BaseSelectorEventLoop.html" title=" " alt="" coords="559,120,742,161"/>
<area shape="rect" href="classtest_1_1test__asyncio_1_1test__futures_1_1SimpleEvilEventLoop.html" title=" " alt="" coords="543,185,759,227"/>
<area shape="rect" href="classasyncio_1_1windows__events_1_1ProactorEventLoop.html" title=" " alt="" coords="809,5,1051,47"/>
<area shape="rect" href="classasyncio_1_1unix__events_1_1__UnixSelectorEventLoop.html" title=" " alt="" coords="840,71,1020,112"/>
<area shape="rect" href="classasyncio_1_1windows__events_1_1__WindowsSelectorEventLoop.html" title=" " alt="" coords="825,136,1035,177"/>
<area shape="rect" href="classtest_1_1test__asyncio_1_1test__selector__events_1_1TestBaseSelectorEventLoop.html" title=" " alt="" coords="807,202,1053,258"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a402be2dddfe330eb3374cdbc75710181"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a402be2dddfe330eb3374cdbc75710181">run_forever</a> (self)</td></tr>
<tr class="separator:a402be2dddfe330eb3374cdbc75710181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b04818ffd47d04742efaff6d8458b47"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a4b04818ffd47d04742efaff6d8458b47">run_until_complete</a> (self, future)</td></tr>
<tr class="separator:a4b04818ffd47d04742efaff6d8458b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35b5f540bee1a817aae8becc048ecbd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#ab35b5f540bee1a817aae8becc048ecbd">stop</a> (self)</td></tr>
<tr class="separator:ab35b5f540bee1a817aae8becc048ecbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ff17e3bc3b74359a51bd48c56bd19f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a34ff17e3bc3b74359a51bd48c56bd19f">is_running</a> (self)</td></tr>
<tr class="separator:a34ff17e3bc3b74359a51bd48c56bd19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0bfc0fa7a42c3308e6afc468a62103"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#aad0bfc0fa7a42c3308e6afc468a62103">is_closed</a> (self)</td></tr>
<tr class="separator:aad0bfc0fa7a42c3308e6afc468a62103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd74b51251a6e880e9248f6c2ea7c82f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#abd74b51251a6e880e9248f6c2ea7c82f">close</a> (self)</td></tr>
<tr class="separator:abd74b51251a6e880e9248f6c2ea7c82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb68ef561c3f4873e5019e21a17bb926"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#acb68ef561c3f4873e5019e21a17bb926">shutdown_asyncgens</a> (self)</td></tr>
<tr class="separator:acb68ef561c3f4873e5019e21a17bb926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5013993cc977bb88b93a8666a3470b0c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a5013993cc977bb88b93a8666a3470b0c">shutdown_default_executor</a> (self)</td></tr>
<tr class="separator:a5013993cc977bb88b93a8666a3470b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4946c1ede580bfa1227d2e487752c99"><td class="memItemLeft" align="right" valign="top"><a id="ab4946c1ede580bfa1227d2e487752c99"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>call_soon</b> (self, callback, *args, context=None)</td></tr>
<tr class="separator:ab4946c1ede580bfa1227d2e487752c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9016e85bb95136de7bb141a370f8b2b"><td class="memItemLeft" align="right" valign="top"><a id="ae9016e85bb95136de7bb141a370f8b2b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>call_later</b> (self, delay, callback, *args, context=None)</td></tr>
<tr class="separator:ae9016e85bb95136de7bb141a370f8b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fd2d0f25aebd039a777f5368691afc"><td class="memItemLeft" align="right" valign="top"><a id="a21fd2d0f25aebd039a777f5368691afc"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>call_at</b> (self, when, callback, *args, context=None)</td></tr>
<tr class="separator:a21fd2d0f25aebd039a777f5368691afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6eadb2d73640fc61deea156e71951a1"><td class="memItemLeft" align="right" valign="top"><a id="af6eadb2d73640fc61deea156e71951a1"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>time</b> (self)</td></tr>
<tr class="separator:af6eadb2d73640fc61deea156e71951a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425587bee6381e592128874e19649956"><td class="memItemLeft" align="right" valign="top"><a id="a425587bee6381e592128874e19649956"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>create_future</b> (self)</td></tr>
<tr class="separator:a425587bee6381e592128874e19649956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e26678c991caf65eba571ea13d22fc0"><td class="memItemLeft" align="right" valign="top"><a id="a7e26678c991caf65eba571ea13d22fc0"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>create_task</b> (self, coro, *name=None, context=None)</td></tr>
<tr class="separator:a7e26678c991caf65eba571ea13d22fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a423da46b5e09637d7bbbc297ff900a"><td class="memItemLeft" align="right" valign="top"><a id="a4a423da46b5e09637d7bbbc297ff900a"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>call_soon_threadsafe</b> (self, callback, *args, context=None)</td></tr>
<tr class="separator:a4a423da46b5e09637d7bbbc297ff900a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bbfeb8b21e2e66993d52837f6ba256"><td class="memItemLeft" align="right" valign="top"><a id="a60bbfeb8b21e2e66993d52837f6ba256"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>run_in_executor</b> (self, executor, func, *args)</td></tr>
<tr class="separator:a60bbfeb8b21e2e66993d52837f6ba256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142276511b053acda6613a06071547c2"><td class="memItemLeft" align="right" valign="top"><a id="a142276511b053acda6613a06071547c2"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>set_default_executor</b> (self, executor)</td></tr>
<tr class="separator:a142276511b053acda6613a06071547c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cf9309bec352f77f1f4dc3a839048d"><td class="memItemLeft" align="right" valign="top"><a id="ac5cf9309bec352f77f1f4dc3a839048d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>getaddrinfo</b> (self, host, port, *family=0, type=0, proto=0, flags=0)</td></tr>
<tr class="separator:ac5cf9309bec352f77f1f4dc3a839048d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b1a012fbe74545c56a3b9c77e7e0a6"><td class="memItemLeft" align="right" valign="top"><a id="aa8b1a012fbe74545c56a3b9c77e7e0a6"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>getnameinfo</b> (self, sockaddr, flags=0)</td></tr>
<tr class="separator:aa8b1a012fbe74545c56a3b9c77e7e0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd380bf16df7dd12f598c1f7e0a6a63"><td class="memItemLeft" align="right" valign="top"><a id="a2dd380bf16df7dd12f598c1f7e0a6a63"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>create_connection</b> (self, protocol_factory, host=None, port=None, *ssl=None, family=0, proto=0, flags=0, sock=None, local_addr=None, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, happy_eyeballs_delay=None, interleave=None)</td></tr>
<tr class="separator:a2dd380bf16df7dd12f598c1f7e0a6a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac133bfa1628aa683e060bd940b2e147d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#ac133bfa1628aa683e060bd940b2e147d">create_server</a> (self, protocol_factory, host=None, port=None, *family=socket.AF_UNSPEC, flags=socket.AI_PASSIVE, sock=None, backlog=100, ssl=None, reuse_address=None, reuse_port=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, start_serving=True)</td></tr>
<tr class="separator:ac133bfa1628aa683e060bd940b2e147d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d7094f997135456cd89b4d2fb97cf6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a14d7094f997135456cd89b4d2fb97cf6">sendfile</a> (self, transport, file, offset=0, count=None, *fallback=True)</td></tr>
<tr class="separator:a14d7094f997135456cd89b4d2fb97cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce8f478e851993280015e4b99c310e2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a6ce8f478e851993280015e4b99c310e2">start_tls</a> (self, transport, protocol, sslcontext, *server_side=False, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None)</td></tr>
<tr class="separator:a6ce8f478e851993280015e4b99c310e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320fc977ebde2e7930898bf63d305cb9"><td class="memItemLeft" align="right" valign="top"><a id="a320fc977ebde2e7930898bf63d305cb9"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>create_unix_connection</b> (self, protocol_factory, path=None, *ssl=None, sock=None, server_hostname=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None)</td></tr>
<tr class="separator:a320fc977ebde2e7930898bf63d305cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd28eab6b3fce628d4b5947306d5acd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#abcd28eab6b3fce628d4b5947306d5acd">create_unix_server</a> (self, protocol_factory, path=None, *sock=None, backlog=100, ssl=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None, start_serving=True)</td></tr>
<tr class="separator:abcd28eab6b3fce628d4b5947306d5acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a596c3e2da22758c983add8f6df070c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a0a596c3e2da22758c983add8f6df070c">connect_accepted_socket</a> (self, protocol_factory, sock, *ssl=None, ssl_handshake_timeout=None, ssl_shutdown_timeout=None)</td></tr>
<tr class="separator:a0a596c3e2da22758c983add8f6df070c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16515bf200bd711dc2446fb5c5124c64"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a16515bf200bd711dc2446fb5c5124c64">create_datagram_endpoint</a> (self, protocol_factory, local_addr=None, remote_addr=None, *family=0, proto=0, flags=0, reuse_address=None, reuse_port=None, allow_broadcast=None, sock=None)</td></tr>
<tr class="separator:a16515bf200bd711dc2446fb5c5124c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac62792db163b5f65d930e219091ef1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a7ac62792db163b5f65d930e219091ef1">connect_read_pipe</a> (self, protocol_factory, pipe)</td></tr>
<tr class="separator:a7ac62792db163b5f65d930e219091ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a63358afa691b5762e8e50815dfce6d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1events_1_1AbstractEventLoop.html#a9a63358afa691b5762e8e50815dfce6d">connect_write_pipe</a> (self, protocol_factory, pipe)</td></tr>
<tr class="separator:a9a63358afa691b5762e8e50815dfce6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa27e26eae8bed78440461d2848608f"><td class="memItemLeft" align="right" valign="top"><a id="a4aa27e26eae8bed78440461d2848608f"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>subprocess_shell</b> (self, protocol_factory, cmd, *stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kwargs)</td></tr>
<tr class="separator:a4aa27e26eae8bed78440461d2848608f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25feda476e28b25661e92067133377d"><td class="memItemLeft" align="right" valign="top"><a id="aa25feda476e28b25661e92067133377d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>subprocess_exec</b> (self, protocol_factory, *args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kwargs)</td></tr>
<tr class="separator:aa25feda476e28b25661e92067133377d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edc8f81bd8d977e2f511d4135efd017"><td class="memItemLeft" align="right" valign="top"><a id="a1edc8f81bd8d977e2f511d4135efd017"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>add_reader</b> (self, fd, callback, *args)</td></tr>
<tr class="separator:a1edc8f81bd8d977e2f511d4135efd017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a328557e34fc23e44d18939d1818c4"><td class="memItemLeft" align="right" valign="top"><a id="a21a328557e34fc23e44d18939d1818c4"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>remove_reader</b> (self, fd)</td></tr>
<tr class="separator:a21a328557e34fc23e44d18939d1818c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7440ed9024e60259b31aba6f5757762b"><td class="memItemLeft" align="right" valign="top"><a id="a7440ed9024e60259b31aba6f5757762b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>add_writer</b> (self, fd, callback, *args)</td></tr>
<tr class="separator:a7440ed9024e60259b31aba6f5757762b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3552c0ce0081bce7a5416210ea69567d"><td class="memItemLeft" align="right" valign="top"><a id="a3552c0ce0081bce7a5416210ea69567d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>remove_writer</b> (self, fd)</td></tr>
<tr class="separator:a3552c0ce0081bce7a5416210ea69567d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472115671360c4dd2fcf52c758b9c2f2"><td class="memItemLeft" align="right" valign="top"><a id="a472115671360c4dd2fcf52c758b9c2f2"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_recv</b> (self, sock, nbytes)</td></tr>
<tr class="separator:a472115671360c4dd2fcf52c758b9c2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c595d470509aed3c0447672874a62b3"><td class="memItemLeft" align="right" valign="top"><a id="a7c595d470509aed3c0447672874a62b3"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_recv_into</b> (self, sock, buf)</td></tr>
<tr class="separator:a7c595d470509aed3c0447672874a62b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1937bb7fff8059b33065812fddb139f3"><td class="memItemLeft" align="right" valign="top"><a id="a1937bb7fff8059b33065812fddb139f3"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_recvfrom</b> (self, sock, bufsize)</td></tr>
<tr class="separator:a1937bb7fff8059b33065812fddb139f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bd246c7618053971c5c486df55041b"><td class="memItemLeft" align="right" valign="top"><a id="a98bd246c7618053971c5c486df55041b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_recvfrom_into</b> (self, sock, buf, nbytes=0)</td></tr>
<tr class="separator:a98bd246c7618053971c5c486df55041b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c155d5cd37f20a6fa0df29135f9ce49"><td class="memItemLeft" align="right" valign="top"><a id="a9c155d5cd37f20a6fa0df29135f9ce49"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_sendall</b> (self, sock, data)</td></tr>
<tr class="separator:a9c155d5cd37f20a6fa0df29135f9ce49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39aad429d79d5a74b75954536f9b0096"><td class="memItemLeft" align="right" valign="top"><a id="a39aad429d79d5a74b75954536f9b0096"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_sendto</b> (self, sock, data, address)</td></tr>
<tr class="separator:a39aad429d79d5a74b75954536f9b0096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64978a2031000a60d991f22eaf7510a4"><td class="memItemLeft" align="right" valign="top"><a id="a64978a2031000a60d991f22eaf7510a4"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_connect</b> (self, sock, address)</td></tr>
<tr class="separator:a64978a2031000a60d991f22eaf7510a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdf825f59e25d82993ff21a58b63c3b"><td class="memItemLeft" align="right" valign="top"><a id="a8cdf825f59e25d82993ff21a58b63c3b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_accept</b> (self, sock)</td></tr>
<tr class="separator:a8cdf825f59e25d82993ff21a58b63c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d5e3bdb3b323e241139d63324392f7"><td class="memItemLeft" align="right" valign="top"><a id="aa6d5e3bdb3b323e241139d63324392f7"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>sock_sendfile</b> (self, sock, file, offset=0, count=None, *fallback=None)</td></tr>
<tr class="separator:aa6d5e3bdb3b323e241139d63324392f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938aa96b11db1d2f2f2c25abee6f4b85"><td class="memItemLeft" align="right" valign="top"><a id="a938aa96b11db1d2f2f2c25abee6f4b85"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>add_signal_handler</b> (self, sig, callback, *args)</td></tr>
<tr class="separator:a938aa96b11db1d2f2f2c25abee6f4b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f3104ebdf8b15c09eaa5269fe8c712"><td class="memItemLeft" align="right" valign="top"><a id="ac6f3104ebdf8b15c09eaa5269fe8c712"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>remove_signal_handler</b> (self, sig)</td></tr>
<tr class="separator:ac6f3104ebdf8b15c09eaa5269fe8c712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7793354a390197614b6d7d2c0c5370f"><td class="memItemLeft" align="right" valign="top"><a id="ae7793354a390197614b6d7d2c0c5370f"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>set_task_factory</b> (self, factory)</td></tr>
<tr class="separator:ae7793354a390197614b6d7d2c0c5370f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c0aafc45bc71c5e5a504bc43f131bd"><td class="memItemLeft" align="right" valign="top"><a id="a52c0aafc45bc71c5e5a504bc43f131bd"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>get_task_factory</b> (self)</td></tr>
<tr class="separator:a52c0aafc45bc71c5e5a504bc43f131bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98f0e513dcef4772098791c77a3b952"><td class="memItemLeft" align="right" valign="top"><a id="ad98f0e513dcef4772098791c77a3b952"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>get_exception_handler</b> (self)</td></tr>
<tr class="separator:ad98f0e513dcef4772098791c77a3b952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c3c6e8b12a25aa9dde54579e2825b8"><td class="memItemLeft" align="right" valign="top"><a id="aa0c3c6e8b12a25aa9dde54579e2825b8"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>set_exception_handler</b> (self, handler)</td></tr>
<tr class="separator:aa0c3c6e8b12a25aa9dde54579e2825b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46567850f260dd87c77afaff5e8af74"><td class="memItemLeft" align="right" valign="top"><a id="ab46567850f260dd87c77afaff5e8af74"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>default_exception_handler</b> (self, context)</td></tr>
<tr class="separator:ab46567850f260dd87c77afaff5e8af74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97acf428d3154d6db612c0cccc8c319"><td class="memItemLeft" align="right" valign="top"><a id="ac97acf428d3154d6db612c0cccc8c319"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>call_exception_handler</b> (self, context)</td></tr>
<tr class="separator:ac97acf428d3154d6db612c0cccc8c319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595d41ce4e55cb407e286efcb1b08142"><td class="memItemLeft" align="right" valign="top"><a id="a595d41ce4e55cb407e286efcb1b08142"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>get_debug</b> (self)</td></tr>
<tr class="separator:a595d41ce4e55cb407e286efcb1b08142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e19f64a183ef1886137ab5cc6a22114"><td class="memItemLeft" align="right" valign="top"><a id="a5e19f64a183ef1886137ab5cc6a22114"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>set_debug</b> (self, enabled)</td></tr>
<tr class="separator:a5e19f64a183ef1886137ab5cc6a22114"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Abstract event loop.</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abd74b51251a6e880e9248f6c2ea7c82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd74b51251a6e880e9248f6c2ea7c82f">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Close the loop.

The loop should not be running.

This is idempotent and irreversible.

No other methods should be called after this one.
</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a980d68b6681be79b7289970f38712925">asyncio.base_events.BaseEventLoop</a>, <a class="el" href="classasyncio_1_1proactor__events_1_1BaseProactorEventLoop.html#a98f3fcc00378c14a7c59889454cc8961">asyncio.proactor_events.BaseProactorEventLoop</a>, <a class="el" href="classasyncio_1_1selector__events_1_1BaseSelectorEventLoop.html#af4edf592ea3982f3a7506adb73e20021">asyncio.selector_events.BaseSelectorEventLoop</a>, and <a class="el" href="classasyncio_1_1unix__events_1_1__UnixSelectorEventLoop.html#a9922b58386ba9179c17522096ecaaeb6">asyncio.unix_events._UnixSelectorEventLoop</a>.</p>

</div>
</div>
<a id="a0a596c3e2da22758c983add8f6df070c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a596c3e2da22758c983add8f6df070c">&#9670;&nbsp;</a></span>connect_accepted_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.connect_accepted_socket </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>ssl</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_handshake_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_shutdown_timeout</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Handle an accepted connection.

This is used by servers that accept connections outside of
asyncio, but use asyncio to handle connections.

This method is a coroutine.  When completed, the coroutine
returns a (transport, protocol) pair.
</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a992792cd3da9befc2b5e86dd27349fac">asyncio.base_events.BaseEventLoop</a>.</p>

</div>
</div>
<a id="a7ac62792db163b5f65d930e219091ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac62792db163b5f65d930e219091ef1">&#9670;&nbsp;</a></span>connect_read_pipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.connect_read_pipe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Register read pipe in event loop. Set the pipe to non-blocking mode.

protocol_factory should instantiate object with Protocol interface.
pipe is a file-like object.
Return pair (transport, protocol), where transport supports the
ReadTransport interface.</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a2a3c381e0efe853d62f6968d383cf575">asyncio.base_events.BaseEventLoop</a>.</p>

</div>
</div>
<a id="a9a63358afa691b5762e8e50815dfce6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a63358afa691b5762e8e50815dfce6d">&#9670;&nbsp;</a></span>connect_write_pipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.connect_write_pipe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Register write pipe in event loop.

protocol_factory should instantiate object with BaseProtocol interface.
Pipe is file-like object already switched to nonblocking.
Return pair (transport, protocol), where transport support
WriteTransport interface.</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#abc433e0b24ebf84ba08b4d344efc9e61">asyncio.base_events.BaseEventLoop</a>.</p>

</div>
</div>
<a id="a16515bf200bd711dc2446fb5c5124c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16515bf200bd711dc2446fb5c5124c64">&#9670;&nbsp;</a></span>create_datagram_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.create_datagram_endpoint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>local_addr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>remote_addr</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>family</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proto</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reuse_address</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reuse_port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_broadcast</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sock</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A coroutine which creates a datagram endpoint.

This method will try to establish the endpoint in the background.
When successful, the coroutine returns a (transport, protocol) pair.

protocol_factory must be a callable returning a protocol instance.

socket family AF_INET, socket.AF_INET6 or socket.AF_UNIX depending on
host (or family if specified), socket type SOCK_DGRAM.

reuse_address tells the kernel to reuse a local socket in
TIME_WAIT state, without waiting for its natural timeout to
expire. If not specified it will automatically be set to True on
UNIX.

reuse_port tells the kernel to allow this endpoint to be bound to
the same port as other existing endpoints are bound to, so long as
they all set this flag when being created. This option is not
supported on Windows and some UNIX's. If the
:py:data:`~socket.SO_REUSEPORT` constant is not defined then this
capability is unsupported.

allow_broadcast tells the kernel to allow this endpoint to send
messages to the broadcast address.

sock can optionally be specified in order to use a preexisting
socket object.
</pre> 
</div>
</div>
<a id="ac133bfa1628aa683e060bd940b2e147d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac133bfa1628aa683e060bd940b2e147d">&#9670;&nbsp;</a></span>create_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.create_server </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>host</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>family</em> = <code>socket.AF_UNSPEC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flags</em> = <code>socket.AI_PASSIVE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sock</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>backlog</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reuse_address</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reuse_port</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_handshake_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_shutdown_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start_serving</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A coroutine which creates a TCP server bound to host and port.

The return value is a Server object which can be used to stop
the service.

If host is an empty string or None all interfaces are assumed
and a list of multiple sockets will be returned (most likely
one for IPv4 and another one for IPv6). The host parameter can also be
a sequence (e.g. list) of hosts to bind to.

family can be set to either AF_INET or AF_INET6 to force the
socket to use IPv4 or IPv6. If not set it will be determined
from host (defaults to AF_UNSPEC).

flags is a bitmask for getaddrinfo().

sock can optionally be specified in order to use a preexisting
socket object.

backlog is the maximum number of queued connections passed to
listen() (defaults to 100).

ssl can be set to an SSLContext to enable SSL over the
accepted connections.

reuse_address tells the kernel to reuse a local socket in
TIME_WAIT state, without waiting for its natural timeout to
expire. If not specified will automatically be set to True on
UNIX.

reuse_port tells the kernel to allow this endpoint to be bound to
the same port as other existing endpoints are bound to, so long as
they all set this flag when being created. This option is not
supported on Windows.

ssl_handshake_timeout is the time in seconds that an SSL server
will wait for completion of the SSL handshake before aborting the
connection. Default is 60s.

ssl_shutdown_timeout is the time in seconds that an SSL server
will wait for completion of the SSL shutdown procedure
before aborting the connection. Default is 30s.

start_serving set to True (default) causes the created server
to start accepting connections immediately.  When set to False,
the user should await Server.start_serving() or Server.serve_forever()
to make the server to start accepting connections.
</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a4cc4b919e9edd4fc9ac8a6930ac8b200">asyncio.base_events.BaseEventLoop</a>.</p>

</div>
</div>
<a id="abcd28eab6b3fce628d4b5947306d5acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd28eab6b3fce628d4b5947306d5acd">&#9670;&nbsp;</a></span>create_unix_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.create_unix_server </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>sock</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>backlog</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_handshake_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_shutdown_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start_serving</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A coroutine which creates a UNIX Domain Socket server.

The return value is a Server object, which can be used to stop
the service.

path is a str, representing a file system path to bind the
server socket to.

sock can optionally be specified in order to use a preexisting
socket object.

backlog is the maximum number of queued connections passed to
listen() (defaults to 100).

ssl can be set to an SSLContext to enable SSL over the
accepted connections.

ssl_handshake_timeout is the time in seconds that an SSL server
will wait for the SSL handshake to complete (defaults to 60s).

ssl_shutdown_timeout is the time in seconds that an SSL server
will wait for the SSL shutdown to finish (defaults to 30s).

start_serving set to True (default) causes the created server
to start accepting connections immediately.  When set to False,
the user should await Server.start_serving() or Server.serve_forever()
to make the server to start accepting connections.
</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1unix__events_1_1__UnixSelectorEventLoop.html#ac7ac3034c973810a713e34af4e7ffd61">asyncio.unix_events._UnixSelectorEventLoop</a>.</p>

</div>
</div>
<a id="aad0bfc0fa7a42c3308e6afc468a62103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0bfc0fa7a42c3308e6afc468a62103">&#9670;&nbsp;</a></span>is_closed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.is_closed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if the event loop was closed.</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#ab9de3c18cd4beb4ece1a0b6c22f5714a">asyncio.base_events.BaseEventLoop</a>.</p>

</div>
</div>
<a id="a34ff17e3bc3b74359a51bd48c56bd19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ff17e3bc3b74359a51bd48c56bd19f">&#9670;&nbsp;</a></span>is_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.is_running </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether the event loop is currently running.</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a4f2ad8d56c0a3ebd38fc65ad24a20b65">asyncio.base_events.BaseEventLoop</a>.</p>

</div>
</div>
<a id="a402be2dddfe330eb3374cdbc75710181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402be2dddfe330eb3374cdbc75710181">&#9670;&nbsp;</a></span>run_forever()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.run_forever </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Run the event loop until stop() is called.</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#af2735643e577be7a5e69db41b3e6a4d5">asyncio.base_events.BaseEventLoop</a>, and <a class="el" href="classasyncio_1_1windows__events_1_1ProactorEventLoop.html#a834d555a1b0cc5377f5a5140e7a27edc">asyncio.windows_events.ProactorEventLoop</a>.</p>

</div>
</div>
<a id="a4b04818ffd47d04742efaff6d8458b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b04818ffd47d04742efaff6d8458b47">&#9670;&nbsp;</a></span>run_until_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.run_until_complete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>future</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Run the event loop until a Future is done.

Return the Future's result, or raise its exception.
</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#ab7a3d195d47ced704013a9e3ebb02da6">asyncio.base_events.BaseEventLoop</a>.</p>

</div>
</div>
<a id="a14d7094f997135456cd89b4d2fb97cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d7094f997135456cd89b4d2fb97cf6">&#9670;&nbsp;</a></span>sendfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.sendfile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>count</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>fallback</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Send a file through a transport.

Return an amount of sent bytes.
</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#afc5940885522a735cda10a659074ca1e">asyncio.base_events.BaseEventLoop</a>.</p>

</div>
</div>
<a id="acb68ef561c3f4873e5019e21a17bb926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb68ef561c3f4873e5019e21a17bb926">&#9670;&nbsp;</a></span>shutdown_asyncgens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.shutdown_asyncgens </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Shutdown all active asynchronous generators.</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#a25119ef4a9a9128bf3c55e3c47823520">asyncio.base_events.BaseEventLoop</a>.</p>

</div>
</div>
<a id="a5013993cc977bb88b93a8666a3470b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5013993cc977bb88b93a8666a3470b0c">&#9670;&nbsp;</a></span>shutdown_default_executor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.shutdown_default_executor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Schedule the shutdown of the default executor.</pre> 
</div>
</div>
<a id="a6ce8f478e851993280015e4b99c310e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce8f478e851993280015e4b99c310e2">&#9670;&nbsp;</a></span>start_tls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.start_tls </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sslcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>server_side</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>server_hostname</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_handshake_timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ssl_shutdown_timeout</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Upgrade a transport to TLS.

Return a new transport that *protocol* should start using
immediately.
</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#ae1c3d49e324a18706284e85bcf099ecc">asyncio.base_events.BaseEventLoop</a>.</p>

</div>
</div>
<a id="ab35b5f540bee1a817aae8becc048ecbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35b5f540bee1a817aae8becc048ecbd">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.events.AbstractEventLoop.stop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Stop the event loop as soon as reasonable.

Exactly how soon that is may depend on the implementation, but
no more I/O callbacks should be scheduled.
</pre> 
<p>Reimplemented in <a class="el" href="classasyncio_1_1base__events_1_1BaseEventLoop.html#afa925fcc0b1fd0ada20aa38fc793a66a">asyncio.base_events.BaseEventLoop</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>UI-UX/SFML/lib/python3.12/asyncio/events.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
