<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PHONE MANAGEMENT: asyncio.tasks Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PHONE MANAGEMENT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceasyncio.html">asyncio</a></li><li class="navelem"><a class="el" href="namespaceasyncio_1_1tasks.html">tasks</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">asyncio.tasks Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1tasks_1_1__GatheringFuture.html">_GatheringFuture</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasyncio_1_1tasks_1_1Task.html">Task</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a663234f924fb73a8118389df86aa92e8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasyncio_1_1tasks.html#a663234f924fb73a8118389df86aa92e8">current_task</a> (loop=None)</td></tr>
<tr class="separator:a663234f924fb73a8118389df86aa92e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee598132d5284041c038e146873ff98a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasyncio_1_1tasks.html#aee598132d5284041c038e146873ff98a">all_tasks</a> (loop=None)</td></tr>
<tr class="separator:aee598132d5284041c038e146873ff98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e0da17fb733de9d727917fa8c7334a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasyncio_1_1tasks.html#a01e0da17fb733de9d727917fa8c7334a">create_task</a> (coro, *name=None, context=None)</td></tr>
<tr class="separator:a01e0da17fb733de9d727917fa8c7334a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b64bd867973c1441bef1f544274eee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasyncio_1_1tasks.html#ac0b64bd867973c1441bef1f544274eee">wait</a> (fs, *timeout=None, return_when=ALL_COMPLETED)</td></tr>
<tr class="separator:ac0b64bd867973c1441bef1f544274eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483668c00cdccbed1990ca40fd4e3c06"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasyncio_1_1tasks.html#a483668c00cdccbed1990ca40fd4e3c06">wait_for</a> (fut, timeout)</td></tr>
<tr class="separator:a483668c00cdccbed1990ca40fd4e3c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcd0d8ea847d981ccd3e793d389ec08"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasyncio_1_1tasks.html#abfcd0d8ea847d981ccd3e793d389ec08">as_completed</a> (fs, *timeout=None)</td></tr>
<tr class="separator:abfcd0d8ea847d981ccd3e793d389ec08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc208858a870f19d50b09b4179c6b54"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasyncio_1_1tasks.html#a6cc208858a870f19d50b09b4179c6b54">sleep</a> (delay, result=None)</td></tr>
<tr class="separator:a6cc208858a870f19d50b09b4179c6b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ea600044d8dee98cc0bd417fa862b1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasyncio_1_1tasks.html#a61ea600044d8dee98cc0bd417fa862b1">ensure_future</a> (coro_or_future, *loop=None)</td></tr>
<tr class="separator:a61ea600044d8dee98cc0bd417fa862b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c5b25e52257ba790c5d3e00f2bbd3a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasyncio_1_1tasks.html#ae5c5b25e52257ba790c5d3e00f2bbd3a">gather</a> (*coros_or_futures, return_exceptions=False)</td></tr>
<tr class="separator:ae5c5b25e52257ba790c5d3e00f2bbd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f98348502862fcb7389e2114ef352d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasyncio_1_1tasks.html#a32f98348502862fcb7389e2114ef352d">shield</a> (arg)</td></tr>
<tr class="separator:a32f98348502862fcb7389e2114ef352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dcbed96c27367c00c2b3393ca1c753"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasyncio_1_1tasks.html#ac1dcbed96c27367c00c2b3393ca1c753">run_coroutine_threadsafe</a> (coro, loop)</td></tr>
<tr class="separator:ac1dcbed96c27367c00c2b3393ca1c753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade038a2958f96c3439dea59e0e1c3a67"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasyncio_1_1tasks.html#ade038a2958f96c3439dea59e0e1c3a67">create_eager_task_factory</a> (custom_task_constructor)</td></tr>
<tr class="separator:ade038a2958f96c3439dea59e0e1c3a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afc659c59b73ce7993a4dbbe6c86b8342"><td class="memItemLeft" align="right" valign="top"><a id="afc659c59b73ce7993a4dbbe6c86b8342"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Task</b> = _asyncio.Task</td></tr>
<tr class="separator:afc659c59b73ce7993a4dbbe6c86b8342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72738ccd82b50d36530ab0feac654d06"><td class="memItemLeft" align="right" valign="top"><a id="a72738ccd82b50d36530ab0feac654d06"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FIRST_COMPLETED</b> = concurrent.futures.FIRST_COMPLETED</td></tr>
<tr class="separator:a72738ccd82b50d36530ab0feac654d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584d270dd805a52e17156e9301460cc8"><td class="memItemLeft" align="right" valign="top"><a id="a584d270dd805a52e17156e9301460cc8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FIRST_EXCEPTION</b> = concurrent.futures.FIRST_EXCEPTION</td></tr>
<tr class="separator:a584d270dd805a52e17156e9301460cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082a21d88207e172b1401a8898ca30a4"><td class="memItemLeft" align="right" valign="top"><a id="a082a21d88207e172b1401a8898ca30a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ALL_COMPLETED</b> = concurrent.futures.ALL_COMPLETED</td></tr>
<tr class="separator:a082a21d88207e172b1401a8898ca30a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2890fa133d642fa5b4a943fd7fcaf90"><td class="memItemLeft" align="right" valign="top"><a id="ad2890fa133d642fa5b4a943fd7fcaf90"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>eager_task_factory</b> = <a class="el" href="namespaceasyncio_1_1tasks.html#ade038a2958f96c3439dea59e0e1c3a67">create_eager_task_factory</a>(<a class="el" href="classasyncio_1_1tasks_1_1Task.html">Task</a>)</td></tr>
<tr class="separator:ad2890fa133d642fa5b4a943fd7fcaf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Support for tasks, coroutines and the scheduler.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aee598132d5284041c038e146873ff98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee598132d5284041c038e146873ff98a">&#9670;&nbsp;</a></span>all_tasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.tasks.all_tasks </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>loop</em> = <code>None</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a set of all tasks for the loop.</pre> 
</div>
</div>
<a id="abfcd0d8ea847d981ccd3e793d389ec08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcd0d8ea847d981ccd3e793d389ec08">&#9670;&nbsp;</a></span>as_completed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.tasks.as_completed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an iterator whose values are coroutines.

When waiting for the yielded coroutines you'll get the results (or
exceptions!) of the original Futures (or coroutines), in the order
in which and as soon as they complete.

This differs from PEP 3148; the proper way to use this is:

    for f in as_completed(fs):
        result = await f  # The 'await' may raise.
        # Use result.

If a timeout is specified, the 'await' will raise
TimeoutError when the timeout occurs before all Futures are done.

Note: The futures 'f' are not necessarily members of fs.
</pre> 
</div>
</div>
<a id="ade038a2958f96c3439dea59e0e1c3a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade038a2958f96c3439dea59e0e1c3a67">&#9670;&nbsp;</a></span>create_eager_task_factory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.tasks.create_eager_task_factory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>custom_task_constructor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a function suitable for use as a task factory on an event-loop.

    Example usage:

        loop.set_task_factory(
            asyncio.create_eager_task_factory(my_task_constructor))

    Now, tasks created will be started immediately (rather than being first
    scheduled to an event loop). The constructor argument can be any callable
    that returns a Task-compatible object and has a signature compatible
    with `Task.__init__`; it must have the `eager_start` keyword argument.

    Most applications will use `Task` for `custom_task_constructor` and in
    this case there's no need to call `create_eager_task_factory()`
    directly. Instead the  global `eager_task_factory` instance can be
    used. E.g. `loop.set_task_factory(asyncio.eager_task_factory)`.</pre> 
</div>
</div>
<a id="a01e0da17fb733de9d727917fa8c7334a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e0da17fb733de9d727917fa8c7334a">&#9670;&nbsp;</a></span>create_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.tasks.create_task </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Schedule the execution of a coroutine object in a spawn task.

Return a Task object.
</pre> 
</div>
</div>
<a id="a663234f924fb73a8118389df86aa92e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663234f924fb73a8118389df86aa92e8">&#9670;&nbsp;</a></span>current_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.tasks.current_task </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>loop</em> = <code>None</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a currently executed task.</pre> 
</div>
</div>
<a id="a61ea600044d8dee98cc0bd417fa862b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ea600044d8dee98cc0bd417fa862b1">&#9670;&nbsp;</a></span>ensure_future()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.tasks.ensure_future </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coro_or_future</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>loop</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrap a coroutine or an awaitable in a future.

If the argument is a Future, it is returned directly.
</pre> 
</div>
</div>
<a id="ae5c5b25e52257ba790c5d3e00f2bbd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c5b25e52257ba790c5d3e00f2bbd3a">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.tasks.gather </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>coros_or_futures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_exceptions</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a future aggregating results from the given coroutines/futures.

Coroutines will be wrapped in a future and scheduled in the event
loop. They will not necessarily be scheduled in the same order as
passed in.

All futures must share the same event loop.  If all the tasks are
done successfully, the returned future's result is the list of
results (in the order of the original sequence, not necessarily
the order of results arrival).  If *return_exceptions* is True,
exceptions in the tasks are treated the same as successful
results, and gathered in the result list; otherwise, the first
raised exception will be immediately propagated to the returned
future.

Cancellation: if the outer Future is cancelled, all children (that
have not completed yet) are also cancelled.  If any child is
cancelled, this is treated as if it raised CancelledError --
the outer Future is *not* cancelled in this case.  (This is to
prevent the cancellation of one child to cause other children to
be cancelled.)

If *return_exceptions* is False, cancelling gather() after it
has been marked done won't cancel any submitted awaitables.
For instance, gather can be marked done after propagating an
exception to the caller, therefore, calling ``gather.cancel()``
after catching an exception (raised by one of the awaitables) from
gather won't cancel any other awaitables.
</pre> 
</div>
</div>
<a id="ac1dcbed96c27367c00c2b3393ca1c753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1dcbed96c27367c00c2b3393ca1c753">&#9670;&nbsp;</a></span>run_coroutine_threadsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.tasks.run_coroutine_threadsafe </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>loop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Submit a coroutine object to a given event loop.

Return a concurrent.futures.Future to access the result.
</pre> 
</div>
</div>
<a id="a32f98348502862fcb7389e2114ef352d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f98348502862fcb7389e2114ef352d">&#9670;&nbsp;</a></span>shield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.tasks.shield </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wait for a future, shielding it from cancellation.

The statement

    task = asyncio.create_task(something())
    res = await shield(task)

is exactly equivalent to the statement

    res = await something()

*except* that if the coroutine containing it is cancelled, the
task running in something() is not cancelled.  From the POV of
something(), the cancellation did not happen.  But its caller is
still cancelled, so the yield-from expression still raises
CancelledError.  Note: If something() is cancelled by other means
this will still cancel shield().

If you want to completely ignore cancellation (not recommended)
you can combine shield() with a try/except clause, as follows:

    task = asyncio.create_task(something())
    try:
        res = await shield(task)
    except CancelledError:
        res = None

Save a reference to tasks passed to this function, to avoid
a task disappearing mid-execution. The event loop only keeps
weak references to tasks. A task that isn't referenced elsewhere
may get garbage collected at any time, even before it's done.
</pre> 
</div>
</div>
<a id="a6cc208858a870f19d50b09b4179c6b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc208858a870f19d50b09b4179c6b54">&#9670;&nbsp;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.tasks.sleep </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Coroutine that completes after a given time (in seconds).</pre> 
</div>
</div>
<a id="ac0b64bd867973c1441bef1f544274eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b64bd867973c1441bef1f544274eee">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.tasks.wait </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_when</em> = <code>ALL_COMPLETED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wait for the Futures or Tasks given by fs to complete.

The fs iterable must not be empty.

Coroutines will be wrapped in Tasks.

Returns two sets of Future: (done, pending).

Usage:

    done, pending = await asyncio.wait(fs)

Note: This does not raise TimeoutError! Futures that aren't done
when the timeout occurs are returned in the second set.
</pre> 
</div>
</div>
<a id="a483668c00cdccbed1990ca40fd4e3c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483668c00cdccbed1990ca40fd4e3c06">&#9670;&nbsp;</a></span>wait_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def asyncio.tasks.wait_for </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wait for the single Future or coroutine to complete, with timeout.

Coroutine will be wrapped in Task.

Returns result of the Future or coroutine.  When a timeout occurs,
it cancels the task and raises TimeoutError.  To avoid the task
cancellation, wrap it in shield().

If the wait is cancelled, the task is also cancelled.

If the task suppresses the cancellation and returns a value instead,
that value is returned.

This function is a coroutine.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
