<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PHONE MANAGEMENT: test.test_doctest.test_doctest Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PHONE MANAGEMENT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>test</b></li><li class="navelem"><b>test_doctest</b></li><li class="navelem"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html">test_doctest</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">test.test_doctest.test_doctest Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1test__doctest_1_1test__doctest_1_1SampleClass.html">SampleClass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1test__doctest_1_1test__doctest_1_1SampleNewStyleClass.html">SampleNewStyleClass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1test__doctest_1_1test__doctest_1_1test__DocTestFinder.html">test_DocTestFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1test__doctest_1_1test__doctest_1_1test__DocTestRunner.html">test_DocTestRunner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1test__doctest_1_1test__doctest_1_1TestDocTestFinder.html">TestDocTestFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1test__doctest_1_1test__doctest_1_1TestHook.html">TestHook</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1test__doctest_1_1test__doctest_1_1TestImporter.html">TestImporter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtest_1_1test__doctest_1_1test__doctest_1_1Wrapper.html">Wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac91205fef4bf2a4b4cd86473c64cfa43"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#ac91205fef4bf2a4b4cd86473c64cfa43">sample_func</a> (v)</td></tr>
<tr class="memdesc:ac91205fef4bf2a4b4cd86473c64cfa43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample Objects (used by test cases)  <a href="namespacetest_1_1test__doctest_1_1test__doctest.html#ac91205fef4bf2a4b4cd86473c64cfa43">More...</a><br /></td></tr>
<tr class="separator:ac91205fef4bf2a4b4cd86473c64cfa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b8e8a9b969452963e949207fc33224"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a67b8e8a9b969452963e949207fc33224">test_Example</a> ()</td></tr>
<tr class="memdesc:a67b8e8a9b969452963e949207fc33224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test Cases.  <a href="namespacetest_1_1test__doctest_1_1test__doctest.html#a67b8e8a9b969452963e949207fc33224">More...</a><br /></td></tr>
<tr class="separator:a67b8e8a9b969452963e949207fc33224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9f22a12bdf1fee46b69921d4c5027f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a8f9f22a12bdf1fee46b69921d4c5027f">test_DocTest</a> ()</td></tr>
<tr class="separator:a8f9f22a12bdf1fee46b69921d4c5027f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625066fd295d4f87f345b00829aee5ce"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a625066fd295d4f87f345b00829aee5ce">test_DocTestParser</a> ()</td></tr>
<tr class="separator:a625066fd295d4f87f345b00829aee5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f4c4d93d5070cc186fc6b2842b0a9b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a62f4c4d93d5070cc186fc6b2842b0a9b">test_testsource</a> ()</td></tr>
<tr class="separator:a62f4c4d93d5070cc186fc6b2842b0a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8bba5aa8571d6b2abf0a2b94931860"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#adc8bba5aa8571d6b2abf0a2b94931860">test_debug</a> ()</td></tr>
<tr class="separator:adc8bba5aa8571d6b2abf0a2b94931860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5a131c35db81f926ed9b6a08a04b3f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a5d5a131c35db81f926ed9b6a08a04b3f">test_pdb_set_trace</a> ()</td></tr>
<tr class="separator:a5d5a131c35db81f926ed9b6a08a04b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e85b35e9156c4872976d4600f1eb806"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a8e85b35e9156c4872976d4600f1eb806">test_pdb_set_trace_nested</a> ()</td></tr>
<tr class="separator:a8e85b35e9156c4872976d4600f1eb806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60f7043db240c51d3d9bb313b048d7e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#af60f7043db240c51d3d9bb313b048d7e">test_DocTestSuite</a> ()</td></tr>
<tr class="separator:af60f7043db240c51d3d9bb313b048d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6bc34df5fff226aa6aef68cc32223d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a0f6bc34df5fff226aa6aef68cc32223d">test_DocFileSuite</a> ()</td></tr>
<tr class="separator:a0f6bc34df5fff226aa6aef68cc32223d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783f931b14d57835cdd1f32fbb401fe1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a783f931b14d57835cdd1f32fbb401fe1">test_trailing_space_in_test</a> ()</td></tr>
<tr class="separator:a783f931b14d57835cdd1f32fbb401fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a0cc2db6192fd6988bd6cb24473b25"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#ae1a0cc2db6192fd6988bd6cb24473b25">wrapped</a> ()</td></tr>
<tr class="separator:ae1a0cc2db6192fd6988bd6cb24473b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a9c0c8b508785f37c8f17206151f37"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#af9a9c0c8b508785f37c8f17206151f37">test_look_in_unwrapped</a> ()</td></tr>
<tr class="separator:af9a9c0c8b508785f37c8f17206151f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f19244ab2854637e5a528ac5195574"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#aa7f19244ab2854637e5a528ac5195574">test_wrapped_c_func</a> ()</td></tr>
<tr class="separator:aa7f19244ab2854637e5a528ac5195574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2726c9f3c24f5223c327cc4553ce9a49"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a2726c9f3c24f5223c327cc4553ce9a49">test_unittest_reportflags</a> ()</td></tr>
<tr class="separator:a2726c9f3c24f5223c327cc4553ce9a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a33b571abc77b9479f15cc2b68794c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a57a33b571abc77b9479f15cc2b68794c">test_testfile</a> ()</td></tr>
<tr class="separator:a57a33b571abc77b9479f15cc2b68794c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362bb88e18052a7bd0b9da07b7175c93"><td class="memItemLeft" align="right" valign="top"><a id="a362bb88e18052a7bd0b9da07b7175c93"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>test_hook</b> (pathdir)</td></tr>
<tr class="separator:a362bb88e18052a7bd0b9da07b7175c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d85dcec5f7515d1cbb184409cd45c4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a6d85dcec5f7515d1cbb184409cd45c4e">test_lineendings</a> ()</td></tr>
<tr class="separator:a6d85dcec5f7515d1cbb184409cd45c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303d144abb6c7fd54b967507512af1b0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a303d144abb6c7fd54b967507512af1b0">test_testmod</a> ()</td></tr>
<tr class="separator:a303d144abb6c7fd54b967507512af1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10f97a64784744dcba6b695d742d752"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#af10f97a64784744dcba6b695d742d752">test_unicode</a> ()</td></tr>
<tr class="separator:af10f97a64784744dcba6b695d742d752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc664178a8f8d3483e58d88b60a2732"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a2bc664178a8f8d3483e58d88b60a2732">test_CLI</a> ()</td></tr>
<tr class="separator:a2bc664178a8f8d3483e58d88b60a2732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ecec9276e0646ab17ae6bc1331b97a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a90ecec9276e0646ab17ae6bc1331b97a">test_no_trailing_whitespace_stripping</a> ()</td></tr>
<tr class="separator:a90ecec9276e0646ab17ae6bc1331b97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1144e820e2e4430a16a3152dbdb4690"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#ac1144e820e2e4430a16a3152dbdb4690">test_run_doctestsuite_multiple_times</a> ()</td></tr>
<tr class="separator:ac1144e820e2e4430a16a3152dbdb4690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af84b8369fa4f48758406a3131e482e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a9af84b8369fa4f48758406a3131e482e">test_exception_with_note</a> (note)</td></tr>
<tr class="separator:a9af84b8369fa4f48758406a3131e482e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8adce0bb20d7c40dc7a542767d24df2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#ab8adce0bb20d7c40dc7a542767d24df2">test_exception_with_multiple_notes</a> ()</td></tr>
<tr class="separator:ab8adce0bb20d7c40dc7a542767d24df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e17aafeedd78f79321cf3b48f3084f4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#a8e17aafeedd78f79321cf3b48f3084f4">test_syntax_error_with_note</a> (cls, multiline=False)</td></tr>
<tr class="separator:a8e17aafeedd78f79321cf3b48f3084f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc429e723eda0f0588c05ed5b5998f79"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#adc429e723eda0f0588c05ed5b5998f79">test_syntax_error_subclass_from_stdlib</a> ()</td></tr>
<tr class="separator:adc429e723eda0f0588c05ed5b5998f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1656afb8aac9b5fb42ca4f5c022368a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetest_1_1test__doctest_1_1test__doctest.html#ae1656afb8aac9b5fb42ca4f5c022368a">test_syntax_error_with_incorrect_expected_note</a> ()</td></tr>
<tr class="separator:ae1656afb8aac9b5fb42ca4f5c022368a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b5ef8d484bea66ed8ebe6a66a7c255"><td class="memItemLeft" align="right" valign="top"><a id="a18b5ef8d484bea66ed8ebe6a66a7c255"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>load_tests</b> (loader, tests, pattern)</td></tr>
<tr class="separator:a18b5ef8d484bea66ed8ebe6a66a7c255"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab8db05263c91d41f053fb9048fef570b"><td class="memItemLeft" align="right" valign="top"><a id="ab8db05263c91d41f053fb9048fef570b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>cpython</b></td></tr>
<tr class="separator:ab8db05263c91d41f053fb9048fef570b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4916d7317105b5b2076bf9caa1b63e"><td class="memItemLeft" align="right" valign="top"><a id="afd4916d7317105b5b2076bf9caa1b63e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>supports_unicode</b> = False</td></tr>
<tr class="separator:afd4916d7317105b5b2076bf9caa1b63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cd6848acc2eca220e5b2553f607356"><td class="memItemLeft" align="right" valign="top"><a id="ad5cd6848acc2eca220e5b2553f607356"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>module</b></td></tr>
<tr class="separator:ad5cd6848acc2eca220e5b2553f607356"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Test script for doctest.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ac91205fef4bf2a4b4cd86473c64cfa43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91205fef4bf2a4b4cd86473c64cfa43">&#9670;&nbsp;</a></span>sample_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.sample_func </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample Objects (used by test cases) </p>
<pre class="fragment">Blah blah

&gt;&gt;&gt; print(sample_func(22))
44

Yee ha!
</pre> 
</div>
</div>
<a id="a2bc664178a8f8d3483e58d88b60a2732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc664178a8f8d3483e58d88b60a2732">&#9670;&nbsp;</a></span>test_CLI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_CLI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The doctest module can be used to run doctests against an arbitrary file.
These tests test this CLI functionality.

We'll use the support module's script_helpers for this, and write a test files
to a temp dir to run the command against.  Due to a current limitation in
script_helpers, though, we need a little utility function to turn the returned
output into something we can doctest against:

&gt;&gt;&gt; def normalize(s):
...     return '\n'.join(s.decode().splitlines())

With those preliminaries out of the way, we'll start with a file with two
simple tests and no errors.  We'll run both the unadorned doctest command, and
the verbose version, and then check the output:

&gt;&gt;&gt; from test.support import script_helper
&gt;&gt;&gt; from test.support.os_helper import temp_dir
&gt;&gt;&gt; with temp_dir() as tmpdir:
...     fn = os.path.join(tmpdir, 'myfile.doc')
...     with open(fn, 'w', encoding='utf-8') as f:
...         _ = f.write('This is a very simple test file.\n')
...         _ = f.write('   &gt;&gt;&gt; 1 + 1\n')
...         _ = f.write('   2\n')
...         _ = f.write('   &gt;&gt;&gt; "a"\n')
...         _ = f.write("   'a'\n")
...         _ = f.write('\n')
...         _ = f.write('And that is it.\n')
...     rc1, out1, err1 = script_helper.assert_python_ok(
...             '-m', 'doctest', fn)
...     rc2, out2, err2 = script_helper.assert_python_ok(
...             '-m', 'doctest', '-v', fn)

With no arguments and passing tests, we should get no output:

&gt;&gt;&gt; rc1, out1, err1
(0, b'', b'')

With the verbose flag, we should see the test output, but no error output:

&gt;&gt;&gt; rc2, err2
(0, b'')
&gt;&gt;&gt; print(normalize(out2))
Trying:
    1 + 1
Expecting:
    2
ok
Trying:
    "a"
Expecting:
    'a'
ok
1 items passed all tests:
   2 tests in myfile.doc
2 tests in 1 items.
2 passed and 0 failed.
Test passed.

Now we'll write a couple files, one with three tests, the other a python module
with two tests, both of the files having "errors" in the tests that can be made
non-errors by applying the appropriate doctest options to the run (ELLIPSIS in
the first file, NORMALIZE_WHITESPACE in the second).  This combination will
allow thoroughly testing the -f and -o flags, as well as the doctest command's
ability to process more than one file on the command line and, since the second
file ends in '.py', its handling of python module files (as opposed to straight
text files).

&gt;&gt;&gt; from test.support import script_helper
&gt;&gt;&gt; from test.support.os_helper import temp_dir
&gt;&gt;&gt; with temp_dir() as tmpdir:
...     fn = os.path.join(tmpdir, 'myfile.doc')
...     with open(fn, 'w', encoding="utf-8") as f:
...         _ = f.write('This is another simple test file.\n')
...         _ = f.write('   &gt;&gt;&gt; 1 + 1\n')
...         _ = f.write('   2\n')
...         _ = f.write('   &gt;&gt;&gt; "abcdef"\n')
...         _ = f.write("   'a...f'\n")
...         _ = f.write('   &gt;&gt;&gt; "ajkml"\n')
...         _ = f.write("   'a...l'\n")
...         _ = f.write('\n')
...         _ = f.write('And that is it.\n')
...     fn2 = os.path.join(tmpdir, 'myfile2.py')
...     with open(fn2, 'w', encoding='utf-8') as f:
...         _ = f.write('def test_func():\n')
...         _ = f.write('   \"\"\"\n')
...         _ = f.write('   This is simple python test function.\n')
...         _ = f.write('       &gt;&gt;&gt; 1 + 1\n')
...         _ = f.write('       2\n')
...         _ = f.write('       &gt;&gt;&gt; "abc   def"\n')
...         _ = f.write("       'abc def'\n")
...         _ = f.write("\n")
...         _ = f.write('   \"\"\"\n')
...     rc1, out1, err1 = script_helper.assert_python_failure(
...             '-m', 'doctest', fn, fn2)
...     rc2, out2, err2 = script_helper.assert_python_ok(
...             '-m', 'doctest', '-o', 'ELLIPSIS', fn)
...     rc3, out3, err3 = script_helper.assert_python_ok(
...             '-m', 'doctest', '-o', 'ELLIPSIS',
...             '-o', 'NORMALIZE_WHITESPACE', fn, fn2)
...     rc4, out4, err4 = script_helper.assert_python_failure(
...             '-m', 'doctest', '-f', fn, fn2)
...     rc5, out5, err5 = script_helper.assert_python_ok(
...             '-m', 'doctest', '-v', '-o', 'ELLIPSIS',
...             '-o', 'NORMALIZE_WHITESPACE', fn, fn2)

Our first test run will show the errors from the first file (doctest stops if a
file has errors).  Note that doctest test-run error output appears on stdout,
not stderr:

&gt;&gt;&gt; rc1, err1
(1, b'')
&gt;&gt;&gt; print(normalize(out1))                # doctest: +ELLIPSIS
**********************************************************************
File "...myfile.doc", line 4, in myfile.doc
Failed example:
    "abcdef"
Expected:
    'a...f'
Got:
    'abcdef'
**********************************************************************
File "...myfile.doc", line 6, in myfile.doc
Failed example:
    "ajkml"
Expected:
    'a...l'
Got:
    'ajkml'
**********************************************************************
1 items had failures:
   2 of   3 in myfile.doc
***Test Failed*** 2 failures.

With -o ELLIPSIS specified, the second run, against just the first file, should
produce no errors, and with -o NORMALIZE_WHITESPACE also specified, neither
should the third, which ran against both files:

&gt;&gt;&gt; rc2, out2, err2
(0, b'', b'')
&gt;&gt;&gt; rc3, out3, err3
(0, b'', b'')

The fourth run uses FAIL_FAST, so we should see only one error:

&gt;&gt;&gt; rc4, err4
(1, b'')
&gt;&gt;&gt; print(normalize(out4))                # doctest: +ELLIPSIS
**********************************************************************
File "...myfile.doc", line 4, in myfile.doc
Failed example:
    "abcdef"
Expected:
    'a...f'
Got:
    'abcdef'
**********************************************************************
1 items had failures:
   1 of   2 in myfile.doc
***Test Failed*** 1 failures.

The fifth test uses verbose with the two options, so we should get verbose
success output for the tests in both files:

&gt;&gt;&gt; rc5, err5
(0, b'')
&gt;&gt;&gt; print(normalize(out5))
Trying:
    1 + 1
Expecting:
    2
ok
Trying:
    "abcdef"
Expecting:
    'a...f'
ok
Trying:
    "ajkml"
Expecting:
    'a...l'
ok
1 items passed all tests:
   3 tests in myfile.doc
3 tests in 1 items.
3 passed and 0 failed.
Test passed.
Trying:
    1 + 1
Expecting:
    2
ok
Trying:
    "abc   def"
Expecting:
    'abc def'
ok
1 items had no tests:
    myfile2
1 items passed all tests:
   2 tests in myfile2.test_func
2 tests in 2 items.
2 passed and 0 failed.
Test passed.

We should also check some typical error cases.

Invalid file name:

&gt;&gt;&gt; rc, out, err = script_helper.assert_python_failure(
...         '-m', 'doctest', 'nosuchfile')
&gt;&gt;&gt; rc, out
(1, b'')
&gt;&gt;&gt; # The exact error message changes depending on the platform.
&gt;&gt;&gt; print(normalize(err))                    # doctest: +ELLIPSIS
Traceback (most recent call last):
  ...
FileNotFoundError: [Errno ...] ...nosuchfile...

Invalid doctest option:

&gt;&gt;&gt; rc, out, err = script_helper.assert_python_failure(
...         '-m', 'doctest', '-o', 'nosuchoption')
&gt;&gt;&gt; rc, out
(2, b'')
&gt;&gt;&gt; print(normalize(err))                    # doctest: +ELLIPSIS
usage...invalid...nosuchoption...</pre> 
</div>
</div>
<a id="adc8bba5aa8571d6b2abf0a2b94931860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8bba5aa8571d6b2abf0a2b94931860">&#9670;&nbsp;</a></span>test_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_debug </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a docstring that we want to debug:

&gt;&gt;&gt; s = '''
...     &gt;&gt;&gt; x = 12
...     &gt;&gt;&gt; print(x)
...     12
...     '''

Create some fake stdin input, to feed to the debugger:

&gt;&gt;&gt; real_stdin = sys.stdin
&gt;&gt;&gt; sys.stdin = FakeInput(['next', 'print(x)', 'continue'])

Run the debugger on the docstring, and then restore sys.stdin.

&gt;&gt;&gt; try: doctest.debug_src(s)
... finally: sys.stdin = real_stdin
&gt; &lt;string&gt;(1)&lt;module&gt;()
(Pdb) next
12
--Return--
&gt; &lt;string&gt;(1)&lt;module&gt;()-&gt;None
(Pdb) print(x)
12
(Pdb) continue</pre> 
</div>
</div>
<a id="a0f6bc34df5fff226aa6aef68cc32223d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6bc34df5fff226aa6aef68cc32223d">&#9670;&nbsp;</a></span>test_DocFileSuite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_DocFileSuite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">We can test tests found in text files using a DocFileSuite.

   We create a suite by providing the names of one or more text
   files that include examples:

     &gt;&gt;&gt; import unittest
     &gt;&gt;&gt; suite = doctest.DocFileSuite('test_doctest.txt',
     ...                              'test_doctest2.txt',
     ...                              'test_doctest4.txt')
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=3 errors=0 failures=2&gt;

   The test files are looked for in the directory containing the
   calling module.  A package keyword argument can be provided to
   specify a different relative location.

     &gt;&gt;&gt; import unittest
     &gt;&gt;&gt; suite = doctest.DocFileSuite('test_doctest.txt',
     ...                              'test_doctest2.txt',
     ...                              'test_doctest4.txt',
     ...                              package='test.test_doctest')
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=3 errors=0 failures=2&gt;

   Support for using a package's __loader__.get_data() is also
   provided.

     &gt;&gt;&gt; import unittest, pkgutil, test
     &gt;&gt;&gt; added_loader = False
     &gt;&gt;&gt; if not hasattr(test, '__loader__'):
     ...     test.__loader__ = pkgutil.get_loader(test)
     ...     added_loader = True
     &gt;&gt;&gt; try:
     ...     suite = doctest.DocFileSuite('test_doctest.txt',
     ...                                  'test_doctest2.txt',
     ...                                  'test_doctest4.txt',
     ...                                  package='test.test_doctest')
     ...     suite.run(unittest.TestResult())
     ... finally:
     ...     if added_loader:
     ...         del test.__loader__
     &lt;unittest.result.TestResult run=3 errors=0 failures=2&gt;

   '/' should be used as a path separator.  It will be converted
   to a native separator at run time:

     &gt;&gt;&gt; suite = doctest.DocFileSuite('../test_doctest/test_doctest.txt')
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=1 errors=0 failures=1&gt;

   If DocFileSuite is used from an interactive session, then files
   are resolved relative to the directory of sys.argv[0]:

     &gt;&gt;&gt; import types, os.path
     &gt;&gt;&gt; from test.test_doctest import test_doctest
     &gt;&gt;&gt; save_argv = sys.argv
     &gt;&gt;&gt; sys.argv = [test_doctest.__file__]
     &gt;&gt;&gt; suite = doctest.DocFileSuite('test_doctest.txt',
     ...                              package=types.ModuleType('__main__'))
     &gt;&gt;&gt; sys.argv = save_argv

   By setting `module_relative=False`, os-specific paths may be
   used (including absolute paths and paths relative to the
   working directory):

     &gt;&gt;&gt; # Get the absolute path of the test package.
     &gt;&gt;&gt; test_doctest_path = os.path.abspath(test_doctest.__file__)
     &gt;&gt;&gt; test_pkg_path = os.path.split(test_doctest_path)[0]

     &gt;&gt;&gt; # Use it to find the absolute path of test_doctest.txt.
     &gt;&gt;&gt; test_file = os.path.join(test_pkg_path, 'test_doctest.txt')

     &gt;&gt;&gt; suite = doctest.DocFileSuite(test_file, module_relative=False)
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=1 errors=0 failures=1&gt;

   It is an error to specify `package` when `module_relative=False`:

     &gt;&gt;&gt; suite = doctest.DocFileSuite(test_file, module_relative=False,
     ...                              package='test')
     Traceback (most recent call last):
     ValueError: Package may only be specified for module-relative paths.

   You can specify initial global variables:

     &gt;&gt;&gt; suite = doctest.DocFileSuite('test_doctest.txt',
     ...                              'test_doctest2.txt',
     ...                              'test_doctest4.txt',
     ...                              globs={'favorite_color': 'blue'})
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=3 errors=0 failures=1&gt;

   In this case, we supplied a missing favorite color. You can
   provide doctest options:

     &gt;&gt;&gt; suite = doctest.DocFileSuite('test_doctest.txt',
     ...                              'test_doctest2.txt',
     ...                              'test_doctest4.txt',
     ...                         optionflags=doctest.DONT_ACCEPT_BLANKLINE,
     ...                              globs={'favorite_color': 'blue'})
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=3 errors=0 failures=2&gt;

   And, you can provide setUp and tearDown functions:

     &gt;&gt;&gt; def setUp(t):
     ...     from test.test_doctest import test_doctest
     ...     test_doctest.sillySetup = True

     &gt;&gt;&gt; def tearDown(t):
     ...     from test.test_doctest import test_doctest
     ...     del test_doctest.sillySetup

   Here, we installed a silly variable that the test expects:

     &gt;&gt;&gt; suite = doctest.DocFileSuite('test_doctest.txt',
     ...                              'test_doctest2.txt',
     ...                              'test_doctest4.txt',
     ...                              setUp=setUp, tearDown=tearDown)
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=3 errors=0 failures=1&gt;

   But the tearDown restores sanity:

     &gt;&gt;&gt; from test.test_doctest import test_doctest
     &gt;&gt;&gt; test_doctest.sillySetup
     Traceback (most recent call last):
     ...
     AttributeError: module 'test.test_doctest.test_doctest' has no attribute 'sillySetup'

   The setUp and tearDown functions are passed test objects.
   Here, we'll use a setUp function to set the favorite color in
   test_doctest.txt:

     &gt;&gt;&gt; def setUp(test):
     ...     test.globs['favorite_color'] = 'blue'

     &gt;&gt;&gt; suite = doctest.DocFileSuite('test_doctest.txt', setUp=setUp)
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=1 errors=0 failures=0&gt;

   Here, we didn't need to use a tearDown function because we
   modified the test globals.  The test globals are
   automatically cleared for us after a test.

   Tests in a file run using `DocFileSuite` can also access the
   `__file__` global, which is set to the name of the file
   containing the tests:

     &gt;&gt;&gt; suite = doctest.DocFileSuite('test_doctest3.txt')
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=1 errors=0 failures=0&gt;

   If the tests contain non-ASCII characters, we have to specify which
   encoding the file is encoded with. We do so by using the `encoding`
   parameter:

     &gt;&gt;&gt; suite = doctest.DocFileSuite('test_doctest.txt',
     ...                              'test_doctest2.txt',
     ...                              'test_doctest4.txt',
     ...                              encoding='utf-8')
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=3 errors=0 failures=2&gt;</pre> 
</div>
</div>
<a id="a8f9f22a12bdf1fee46b69921d4c5027f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9f22a12bdf1fee46b69921d4c5027f">&#9670;&nbsp;</a></span>test_DocTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_DocTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Unit tests for the `DocTest` class.

DocTest is a collection of examples, extracted from a docstring, along
with information about where the docstring comes from (a name,
filename, and line number).  The docstring is parsed by the `DocTest`
constructor:

    &gt;&gt;&gt; docstring = '''
    ...     &gt;&gt;&gt; print(12)
    ...     12
    ...
    ... Non-example text.
    ...
    ...     &gt;&gt;&gt; print('another\\example')
    ...     another
    ...     example
    ... '''
    &gt;&gt;&gt; globs = {} # globals to run the test in.
    &gt;&gt;&gt; parser = doctest.DocTestParser()
    &gt;&gt;&gt; test = parser.get_doctest(docstring, globs, 'some_test',
    ...                           'some_file', 20)
    &gt;&gt;&gt; print(test)
    &lt;DocTest some_test from some_file:20 (2 examples)&gt;
    &gt;&gt;&gt; len(test.examples)
    2
    &gt;&gt;&gt; e1, e2 = test.examples
    &gt;&gt;&gt; (e1.source, e1.want, e1.lineno)
    ('print(12)\n', '12\n', 1)
    &gt;&gt;&gt; (e2.source, e2.want, e2.lineno)
    ("print('another\\example')\n", 'another\nexample\n', 6)

Source information (name, filename, and line number) is available as
attributes on the doctest object:

    &gt;&gt;&gt; (test.name, test.filename, test.lineno)
    ('some_test', 'some_file', 20)

The line number of an example within its containing file is found by
adding the line number of the example and the line number of its
containing test:

    &gt;&gt;&gt; test.lineno + e1.lineno
    21
    &gt;&gt;&gt; test.lineno + e2.lineno
    26

If the docstring contains inconsistent leading whitespace in the
expected output of an example, then `DocTest` will raise a ValueError:

    &gt;&gt;&gt; docstring = r'''
    ...       &gt;&gt;&gt; print('bad\nindentation')
    ...       bad
    ...     indentation
    ...     '''
    &gt;&gt;&gt; parser.get_doctest(docstring, globs, 'some_test', 'filename', 0)
    Traceback (most recent call last):
    ValueError: line 4 of the docstring for some_test has inconsistent leading whitespace: 'indentation'

If the docstring contains inconsistent leading whitespace on
continuation lines, then `DocTest` will raise a ValueError:

    &gt;&gt;&gt; docstring = r'''
    ...       &gt;&gt;&gt; print(('bad indentation',
    ...     ...          2))
    ...       ('bad', 'indentation')
    ...     '''
    &gt;&gt;&gt; parser.get_doctest(docstring, globs, 'some_test', 'filename', 0)
    Traceback (most recent call last):
    ValueError: line 2 of the docstring for some_test has inconsistent leading whitespace: '...          2))'

If there's no blank space after a PS1 prompt ('&gt;&gt;&gt;'), then `DocTest`
will raise a ValueError:

    &gt;&gt;&gt; docstring = '&gt;&gt;&gt;print(1)\n1'
    &gt;&gt;&gt; parser.get_doctest(docstring, globs, 'some_test', 'filename', 0)
    Traceback (most recent call last):
    ValueError: line 1 of the docstring for some_test lacks blank after &gt;&gt;&gt;: '&gt;&gt;&gt;print(1)'

If there's no blank space after a PS2 prompt ('...'), then `DocTest`
will raise a ValueError:

    &gt;&gt;&gt; docstring = '&gt;&gt;&gt; if 1:\n...print(1)\n1'
    &gt;&gt;&gt; parser.get_doctest(docstring, globs, 'some_test', 'filename', 0)
    Traceback (most recent call last):
    ValueError: line 2 of the docstring for some_test lacks blank after ...: '...print(1)'

Compare `DocTest`:

    &gt;&gt;&gt; docstring = '''
    ...     &gt;&gt;&gt; print 12
    ...     12
    ... '''
    &gt;&gt;&gt; test = parser.get_doctest(docstring, globs, 'some_test',
    ...                           'some_test', 20)
    &gt;&gt;&gt; same_test = parser.get_doctest(docstring, globs, 'some_test',
    ...                                'some_test', 20)
    &gt;&gt;&gt; test == same_test
    True
    &gt;&gt;&gt; test != same_test
    False
    &gt;&gt;&gt; hash(test) == hash(same_test)
    True
    &gt;&gt;&gt; docstring = '''
    ...     &gt;&gt;&gt; print 42
    ...     42
    ... '''
    &gt;&gt;&gt; other_test = parser.get_doctest(docstring, globs, 'other_test',
    ...                                 'other_file', 10)
    &gt;&gt;&gt; test == other_test
    False
    &gt;&gt;&gt; test != other_test
    True
    &gt;&gt;&gt; test &lt; other_test
    False
    &gt;&gt;&gt; other_test &lt; test
    True

Test comparison with lineno None on one side

    &gt;&gt;&gt; no_lineno = parser.get_doctest(docstring, globs, 'some_test',
    ...                               'some_test', None)
    &gt;&gt;&gt; test.lineno is None
    False
    &gt;&gt;&gt; no_lineno.lineno is None
    True
    &gt;&gt;&gt; test &lt; no_lineno
    False
    &gt;&gt;&gt; no_lineno &lt; test
    True

Compare `DocTestCase`:

    &gt;&gt;&gt; DocTestCase = doctest.DocTestCase
    &gt;&gt;&gt; test_case = DocTestCase(test)
    &gt;&gt;&gt; same_test_case = DocTestCase(same_test)
    &gt;&gt;&gt; other_test_case = DocTestCase(other_test)
    &gt;&gt;&gt; test_case == same_test_case
    True
    &gt;&gt;&gt; test_case != same_test_case
    False
    &gt;&gt;&gt; hash(test_case) == hash(same_test_case)
    True
    &gt;&gt;&gt; test == other_test_case
    False
    &gt;&gt;&gt; test != other_test_case
    True</pre> 
</div>
</div>
<a id="a625066fd295d4f87f345b00829aee5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625066fd295d4f87f345b00829aee5ce">&#9670;&nbsp;</a></span>test_DocTestParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_DocTestParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Unit tests for the `DocTestParser` class.

DocTestParser is used to parse docstrings containing doctest examples.

The `parse` method divides a docstring into examples and intervening
text:

    &gt;&gt;&gt; s = '''
    ...     &gt;&gt;&gt; x, y = 2, 3  # no output expected
    ...     &gt;&gt;&gt; if 1:
    ...     ...     print(x)
    ...     ...     print(y)
    ...     2
    ...     3
    ...
    ...     Some text.
    ...     &gt;&gt;&gt; x+y
    ...     5
    ...     '''
    &gt;&gt;&gt; parser = doctest.DocTestParser()
    &gt;&gt;&gt; for piece in parser.parse(s):
    ...     if isinstance(piece, doctest.Example):
    ...         print('Example:', (piece.source, piece.want, piece.lineno))
    ...     else:
    ...         print('   Text:', repr(piece))
       Text: '\n'
    Example: ('x, y = 2, 3  # no output expected\n', '', 1)
       Text: ''
    Example: ('if 1:\n    print(x)\n    print(y)\n', '2\n3\n', 2)
       Text: '\nSome text.\n'
    Example: ('x+y\n', '5\n', 9)
       Text: ''

The `get_examples` method returns just the examples:

    &gt;&gt;&gt; for piece in parser.get_examples(s):
    ...     print((piece.source, piece.want, piece.lineno))
    ('x, y = 2, 3  # no output expected\n', '', 1)
    ('if 1:\n    print(x)\n    print(y)\n', '2\n3\n', 2)
    ('x+y\n', '5\n', 9)

The `get_doctest` method creates a Test from the examples, along with the
given arguments:

    &gt;&gt;&gt; test = parser.get_doctest(s, {}, 'name', 'filename', lineno=5)
    &gt;&gt;&gt; (test.name, test.filename, test.lineno)
    ('name', 'filename', 5)
    &gt;&gt;&gt; for piece in test.examples:
    ...     print((piece.source, piece.want, piece.lineno))
    ('x, y = 2, 3  # no output expected\n', '', 1)
    ('if 1:\n    print(x)\n    print(y)\n', '2\n3\n', 2)
    ('x+y\n', '5\n', 9)
</pre> 
</div>
</div>
<a id="af60f7043db240c51d3d9bb313b048d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60f7043db240c51d3d9bb313b048d7e">&#9670;&nbsp;</a></span>test_DocTestSuite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_DocTestSuite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">DocTestSuite creates a unittest test suite from a doctest.

   We create a Suite by providing a module.  A module can be provided
   by passing a module object:

     &gt;&gt;&gt; import unittest
     &gt;&gt;&gt; import test.test_doctest.sample_doctest
     &gt;&gt;&gt; suite = doctest.DocTestSuite(test.test_doctest.sample_doctest)
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=9 errors=0 failures=4&gt;

   We can also supply the module by name:

     &gt;&gt;&gt; suite = doctest.DocTestSuite('test.test_doctest.sample_doctest')
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=9 errors=0 failures=4&gt;

   The module need not contain any doctest examples:

     &gt;&gt;&gt; suite = doctest.DocTestSuite('test.test_doctest.sample_doctest_no_doctests')
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=0 errors=0 failures=0&gt;

   The module need not contain any docstrings either:

     &gt;&gt;&gt; suite = doctest.DocTestSuite('test.test_doctest.sample_doctest_no_docstrings')
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=0 errors=0 failures=0&gt;

   We can use the current module:

     &gt;&gt;&gt; suite = test.test_doctest.sample_doctest.test_suite()
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=9 errors=0 failures=4&gt;

   We can also provide a DocTestFinder:

     &gt;&gt;&gt; finder = doctest.DocTestFinder()
     &gt;&gt;&gt; suite = doctest.DocTestSuite('test.test_doctest.sample_doctest',
     ...                          test_finder=finder)
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=9 errors=0 failures=4&gt;

   The DocTestFinder need not return any tests:

     &gt;&gt;&gt; finder = doctest.DocTestFinder()
     &gt;&gt;&gt; suite = doctest.DocTestSuite('test.test_doctest.sample_doctest_no_docstrings',
     ...                          test_finder=finder)
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=0 errors=0 failures=0&gt;

   We can supply global variables.  If we pass globs, they will be
   used instead of the module globals.  Here we'll pass an empty
   globals, triggering an extra error:

     &gt;&gt;&gt; suite = doctest.DocTestSuite('test.test_doctest.sample_doctest', globs={})
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=9 errors=0 failures=5&gt;

   Alternatively, we can provide extra globals.  Here we'll make an
   error go away by providing an extra global variable:

     &gt;&gt;&gt; suite = doctest.DocTestSuite('test.test_doctest.sample_doctest',
     ...                              extraglobs={'y': 1})
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=9 errors=0 failures=3&gt;

   You can pass option flags.  Here we'll cause an extra error
   by disabling the blank-line feature:

     &gt;&gt;&gt; suite = doctest.DocTestSuite('test.test_doctest.sample_doctest',
     ...                      optionflags=doctest.DONT_ACCEPT_BLANKLINE)
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=9 errors=0 failures=5&gt;

   You can supply setUp and tearDown functions:

     &gt;&gt;&gt; def setUp(t):
     ...     from test.test_doctest import test_doctest
     ...     test_doctest.sillySetup = True

     &gt;&gt;&gt; def tearDown(t):
     ...     from test.test_doctest import test_doctest
     ...     del test_doctest.sillySetup

   Here, we installed a silly variable that the test expects:

     &gt;&gt;&gt; suite = doctest.DocTestSuite('test.test_doctest.sample_doctest',
     ...      setUp=setUp, tearDown=tearDown)
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=9 errors=0 failures=3&gt;

   But the tearDown restores sanity:

     &gt;&gt;&gt; from test.test_doctest import test_doctest
     &gt;&gt;&gt; test_doctest.sillySetup
     Traceback (most recent call last):
     ...
     AttributeError: module 'test.test_doctest.test_doctest' has no attribute 'sillySetup'

   The setUp and tearDown functions are passed test objects. Here
   we'll use the setUp function to supply the missing variable y:

     &gt;&gt;&gt; def setUp(test):
     ...     test.globs['y'] = 1

     &gt;&gt;&gt; suite = doctest.DocTestSuite('test.test_doctest.sample_doctest', setUp=setUp)
     &gt;&gt;&gt; suite.run(unittest.TestResult())
     &lt;unittest.result.TestResult run=9 errors=0 failures=3&gt;

   Here, we didn't need to use a tearDown function because we
   modified the test globals, which are a copy of the
   sample_doctest module dictionary.  The test globals are
   automatically cleared for us after a test.</pre> 
</div>
</div>
<a id="a67b8e8a9b969452963e949207fc33224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b8e8a9b969452963e949207fc33224">&#9670;&nbsp;</a></span>test_Example()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_Example </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test Cases. </p>
<pre class="fragment">Unit tests for the `Example` class.

Example is a simple container class that holds:
  - `source`: A source string.
  - `want`: An expected output string.
  - `exc_msg`: An expected exception message string (or None if no
    exception is expected).
  - `lineno`: A line number (within the docstring).
  - `indent`: The example's indentation in the input string.
  - `options`: An option dictionary, mapping option flags to True or
    False.

These attributes are set by the constructor.  `source` and `want` are
required; the other attributes all have default values:

    &gt;&gt;&gt; example = doctest.Example('print(1)', '1\n')
    &gt;&gt;&gt; (example.source, example.want, example.exc_msg,
    ...  example.lineno, example.indent, example.options)
    ('print(1)\n', '1\n', None, 0, 0, {})

The first three attributes (`source`, `want`, and `exc_msg`) may be
specified positionally; the remaining arguments should be specified as
keyword arguments:

    &gt;&gt;&gt; exc_msg = 'IndexError: pop from an empty list'
    &gt;&gt;&gt; example = doctest.Example('[].pop()', '', exc_msg,
    ...                           lineno=5, indent=4,
    ...                           options={doctest.ELLIPSIS: True})
    &gt;&gt;&gt; (example.source, example.want, example.exc_msg,
    ...  example.lineno, example.indent, example.options)
    ('[].pop()\n', '', 'IndexError: pop from an empty list\n', 5, 4, {8: True})

The constructor normalizes the `source` string to end in a newline:

    Source spans a single line: no terminating newline.
    &gt;&gt;&gt; e = doctest.Example('print(1)', '1\n')
    &gt;&gt;&gt; e.source, e.want
    ('print(1)\n', '1\n')

    &gt;&gt;&gt; e = doctest.Example('print(1)\n', '1\n')
    &gt;&gt;&gt; e.source, e.want
    ('print(1)\n', '1\n')

    Source spans multiple lines: require terminating newline.
    &gt;&gt;&gt; e = doctest.Example('print(1);\nprint(2)\n', '1\n2\n')
    &gt;&gt;&gt; e.source, e.want
    ('print(1);\nprint(2)\n', '1\n2\n')

    &gt;&gt;&gt; e = doctest.Example('print(1);\nprint(2)', '1\n2\n')
    &gt;&gt;&gt; e.source, e.want
    ('print(1);\nprint(2)\n', '1\n2\n')

    Empty source string (which should never appear in real examples)
    &gt;&gt;&gt; e = doctest.Example('', '')
    &gt;&gt;&gt; e.source, e.want
    ('\n', '')

The constructor normalizes the `want` string to end in a newline,
unless it's the empty string:

    &gt;&gt;&gt; e = doctest.Example('print(1)', '1\n')
    &gt;&gt;&gt; e.source, e.want
    ('print(1)\n', '1\n')

    &gt;&gt;&gt; e = doctest.Example('print(1)', '1')
    &gt;&gt;&gt; e.source, e.want
    ('print(1)\n', '1\n')

    &gt;&gt;&gt; e = doctest.Example('print', '')
    &gt;&gt;&gt; e.source, e.want
    ('print\n', '')

The constructor normalizes the `exc_msg` string to end in a newline,
unless it's `None`:

    Message spans one line
    &gt;&gt;&gt; exc_msg = 'IndexError: pop from an empty list'
    &gt;&gt;&gt; e = doctest.Example('[].pop()', '', exc_msg)
    &gt;&gt;&gt; e.exc_msg
    'IndexError: pop from an empty list\n'

    &gt;&gt;&gt; exc_msg = 'IndexError: pop from an empty list\n'
    &gt;&gt;&gt; e = doctest.Example('[].pop()', '', exc_msg)
    &gt;&gt;&gt; e.exc_msg
    'IndexError: pop from an empty list\n'

    Message spans multiple lines
    &gt;&gt;&gt; exc_msg = 'ValueError: 1\n  2'
    &gt;&gt;&gt; e = doctest.Example('raise ValueError("1\n  2")', '', exc_msg)
    &gt;&gt;&gt; e.exc_msg
    'ValueError: 1\n  2\n'

    &gt;&gt;&gt; exc_msg = 'ValueError: 1\n  2\n'
    &gt;&gt;&gt; e = doctest.Example('raise ValueError("1\n  2")', '', exc_msg)
    &gt;&gt;&gt; e.exc_msg
    'ValueError: 1\n  2\n'

    Empty (but non-None) exception message (which should never appear
    in real examples)
    &gt;&gt;&gt; exc_msg = ''
    &gt;&gt;&gt; e = doctest.Example('raise X()', '', exc_msg)
    &gt;&gt;&gt; e.exc_msg
    '\n'

Compare `Example`:
    &gt;&gt;&gt; example = doctest.Example('print 1', '1\n')
    &gt;&gt;&gt; same_example = doctest.Example('print 1', '1\n')
    &gt;&gt;&gt; other_example = doctest.Example('print 42', '42\n')
    &gt;&gt;&gt; example == same_example
    True
    &gt;&gt;&gt; example != same_example
    False
    &gt;&gt;&gt; hash(example) == hash(same_example)
    True
    &gt;&gt;&gt; example == other_example
    False
    &gt;&gt;&gt; example != other_example
    True
</pre> 
</div>
</div>
<a id="ab8adce0bb20d7c40dc7a542767d24df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8adce0bb20d7c40dc7a542767d24df2">&#9670;&nbsp;</a></span>test_exception_with_multiple_notes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_exception_with_multiple_notes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">&gt;&gt;&gt; test_exception_with_multiple_notes()
Traceback (most recent call last):
  ...
ValueError: Text
One
Two
</pre> 
</div>
</div>
<a id="a9af84b8369fa4f48758406a3131e482e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af84b8369fa4f48758406a3131e482e">&#9670;&nbsp;</a></span>test_exception_with_note()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_exception_with_note </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>note</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">&gt;&gt;&gt; test_exception_with_note('Note')
Traceback (most recent call last):
  ...
ValueError: Text
Note

&gt;&gt;&gt; test_exception_with_note('Note')  # doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
  ...
ValueError: Text
Note

&gt;&gt;&gt; test_exception_with_note('''Note
... multiline
... example''')
Traceback (most recent call last):
ValueError: Text
Note
multiline
example

Different note will fail the test:

&gt;&gt;&gt; def f(x):
...     r'''
...     &gt;&gt;&gt; exc = ValueError('message')
...     &gt;&gt;&gt; exc.add_note('note')
...     &gt;&gt;&gt; raise exc
...     Traceback (most recent call last):
...     ValueError: message
...     wrong note
...     '''
&gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]
&gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)
... # doctest: +ELLIPSIS
**********************************************************************
File "...", line 5, in f
Failed example:
    raise exc
Expected:
    Traceback (most recent call last):
    ValueError: message
    wrong note
Got:
    Traceback (most recent call last):
      ...
    ValueError: message
    note
TestResults(failed=1, attempted=...)
</pre> 
</div>
</div>
<a id="a6d85dcec5f7515d1cbb184409cd45c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d85dcec5f7515d1cbb184409cd45c4e">&#9670;&nbsp;</a></span>test_lineendings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_lineendings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">*nix systems use \n line endings, while Windows systems use \r\n, and
old Mac systems used \r, which Python still recognizes as a line ending.  Python
handles this using universal newline mode for reading files.  Let's make
sure doctest does so (issue 8473) by creating temporary test files using each
of the three line disciplines.  At least one will not match either the universal
newline \n or os.linesep for the platform the test is run on.

Windows line endings first:

    &gt;&gt;&gt; import tempfile, os
    &gt;&gt;&gt; fn = tempfile.mktemp()
    &gt;&gt;&gt; with open(fn, 'wb') as f:
    ...    f.write(b'Test:\r\n\r\n  &gt;&gt;&gt; x = 1 + 1\r\n\r\nDone.\r\n')
    35
    &gt;&gt;&gt; doctest.testfile(fn, module_relative=False, verbose=False)
    TestResults(failed=0, attempted=1)
    &gt;&gt;&gt; os.remove(fn)

And now *nix line endings:

    &gt;&gt;&gt; fn = tempfile.mktemp()
    &gt;&gt;&gt; with open(fn, 'wb') as f:
    ...     f.write(b'Test:\n\n  &gt;&gt;&gt; x = 1 + 1\n\nDone.\n')
    30
    &gt;&gt;&gt; doctest.testfile(fn, module_relative=False, verbose=False)
    TestResults(failed=0, attempted=1)
    &gt;&gt;&gt; os.remove(fn)

And finally old Mac line endings:

    &gt;&gt;&gt; fn = tempfile.mktemp()
    &gt;&gt;&gt; with open(fn, 'wb') as f:
    ...     f.write(b'Test:\r\r  &gt;&gt;&gt; x = 1 + 1\r\rDone.\r')
    30
    &gt;&gt;&gt; doctest.testfile(fn, module_relative=False, verbose=False)
    TestResults(failed=0, attempted=1)
    &gt;&gt;&gt; os.remove(fn)

Now we test with a package loader that has a get_data method, since that
bypasses the standard universal newline handling so doctest has to do the
newline conversion itself; let's make sure it does so correctly (issue 1812).
We'll write a file inside the package that has all three kinds of line endings
in it, and use a package hook to install a custom loader; on any platform,
at least one of the line endings will raise a ValueError for inconsistent
whitespace if doctest does not correctly do the newline conversion.

    &gt;&gt;&gt; from test.support import os_helper
    &gt;&gt;&gt; import shutil
    &gt;&gt;&gt; dn = tempfile.mkdtemp()
    &gt;&gt;&gt; pkg = os.path.join(dn, "doctest_testpkg")
    &gt;&gt;&gt; os.mkdir(pkg)
    &gt;&gt;&gt; os_helper.create_empty_file(os.path.join(pkg, "__init__.py"))
    &gt;&gt;&gt; fn = os.path.join(pkg, "doctest_testfile.txt")
    &gt;&gt;&gt; with open(fn, 'wb') as f:
    ...     f.write(
    ...         b'Test:\r\n\r\n'
    ...         b'  &gt;&gt;&gt; x = 1 + 1\r\n\r\n'
    ...         b'Done.\r\n'
    ...         b'Test:\n\n'
    ...         b'  &gt;&gt;&gt; x = 1 + 1\n\n'
    ...         b'Done.\n'
    ...         b'Test:\r\r'
    ...         b'  &gt;&gt;&gt; x = 1 + 1\r\r'
    ...         b'Done.\r'
    ...     )
    95
    &gt;&gt;&gt; with test_hook(dn):
    ...     doctest.testfile("doctest_testfile.txt", package="doctest_testpkg", verbose=False)
    TestResults(failed=0, attempted=3)
    &gt;&gt;&gt; shutil.rmtree(dn)</pre> 
</div>
</div>
<a id="af9a9c0c8b508785f37c8f17206151f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a9c0c8b508785f37c8f17206151f37">&#9670;&nbsp;</a></span>test_look_in_unwrapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_look_in_unwrapped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Ensure that wrapped doctests work correctly.

&gt;&gt;&gt; import doctest
&gt;&gt;&gt; doctest.run_docstring_examples(
...     wrapped, {}, name=wrapped.__name__, verbose=True)
Finding tests in wrapped
Trying:
    'one other test'
Expecting:
    'one other test'
ok
</pre> 
</div>
</div>
<a id="a90ecec9276e0646ab17ae6bc1331b97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ecec9276e0646ab17ae6bc1331b97a">&#9670;&nbsp;</a></span>test_no_trailing_whitespace_stripping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_no_trailing_whitespace_stripping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The fancy reports had a bug for a long time where any trailing whitespace on
the reported diff lines was stripped, making it impossible to see the
differences in line reported as different that differed only in the amount of
trailing whitespace.  The whitespace still isn't particularly visible unless
you use NDIFF, but at least it is now there to be found.

*NOTE*: This snippet was intentionally put inside a raw string to get rid of
leading whitespace error in executing the example below

&gt;&gt;&gt; def f(x):
...     r'''
...     &gt;&gt;&gt; print('\n'.join(['a    ', 'b']))
...     a
...     b
...     '''
</pre><pre class="fragment">*NOTE*: These doctest are not placed in raw string to depict the trailing whitespace
using `\x20`

&gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]
&gt;&gt;&gt; flags = doctest.REPORT_NDIFF
&gt;&gt;&gt; doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)
... # doctest: +ELLIPSIS
**********************************************************************
File ..., line 3, in f
Failed example:
    print('\n'.join(['a    ', 'b']))
Differences (ndiff with -expected +actual):
    - a
    + a
      b
TestResults(failed=1, attempted=1)

*NOTE*: `\x20` is for checking the trailing whitespace on the +a line above.
We cannot use actual spaces there, as a commit hook prevents from committing
patches that contain trailing whitespace. More info on Issue 24746.
</pre> 
</div>
</div>
<a id="a5d5a131c35db81f926ed9b6a08a04b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5a131c35db81f926ed9b6a08a04b3f">&#9670;&nbsp;</a></span>test_pdb_set_trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_pdb_set_trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Using pdb.set_trace from a doctest.

You can use pdb.set_trace from a doctest.  To do so, you must
retrieve the set_trace function from the pdb module at the time
you use it.  The doctest module changes sys.stdout so that it can
capture program output.  It also temporarily replaces pdb.set_trace
with a version that restores stdout.  This is necessary for you to
see debugger output.

  &gt;&gt;&gt; doc = '''
  ... &gt;&gt;&gt; x = 42
  ... &gt;&gt;&gt; raise Exception('clé')
  ... Traceback (most recent call last):
  ... Exception: clé
  ... &gt;&gt;&gt; import pdb; pdb.set_trace()
  ... '''
  &gt;&gt;&gt; parser = doctest.DocTestParser()
  &gt;&gt;&gt; test = parser.get_doctest(doc, {}, "foo-bar@baz", "foo-bar@baz.py", 0)
  &gt;&gt;&gt; runner = doctest.DocTestRunner(verbose=False)

To demonstrate this, we'll create a fake standard input that
captures our debugger input:

  &gt;&gt;&gt; real_stdin = sys.stdin
  &gt;&gt;&gt; sys.stdin = FakeInput([
  ...    'print(x)',  # print data defined by the example
  ...    'continue', # stop debugging
  ...    ''])

  &gt;&gt;&gt; try: runner.run(test)
  ... finally: sys.stdin = real_stdin
  --Return--
  &gt; &lt;doctest foo-bar@baz[2]&gt;(1)&lt;module&gt;()-&gt;None
  -&gt; import pdb; pdb.set_trace()
  (Pdb) print(x)
  42
  (Pdb) continue
  TestResults(failed=0, attempted=3)

  You can also put pdb.set_trace in a function called from a test:

  &gt;&gt;&gt; def calls_set_trace():
  ...    y=2
  ...    import pdb; pdb.set_trace()

  &gt;&gt;&gt; doc = '''
  ... &gt;&gt;&gt; x=1
  ... &gt;&gt;&gt; calls_set_trace()
  ... '''
  &gt;&gt;&gt; test = parser.get_doctest(doc, globals(), "foo-bar@baz", "foo-bar@baz.py", 0)
  &gt;&gt;&gt; real_stdin = sys.stdin
  &gt;&gt;&gt; sys.stdin = FakeInput([
  ...    'print(y)',  # print data defined in the function
  ...    'up',       # out of function
  ...    'print(x)',  # print data defined by the example
  ...    'continue', # stop debugging
  ...    ''])

  &gt;&gt;&gt; try:
  ...     runner.run(test)
  ... finally:
  ...     sys.stdin = real_stdin
  --Return--
  &gt; &lt;doctest test.test_doctest.test_doctest.test_pdb_set_trace[7]&gt;(3)calls_set_trace()-&gt;None
  -&gt; import pdb; pdb.set_trace()
  (Pdb) print(y)
  2
  (Pdb) up
  &gt; &lt;doctest foo-bar@baz[1]&gt;(1)&lt;module&gt;()
  -&gt; calls_set_trace()
  (Pdb) print(x)
  1
  (Pdb) continue
  TestResults(failed=0, attempted=2)

During interactive debugging, source code is shown, even for
doctest examples:

  &gt;&gt;&gt; doc = '''
  ... &gt;&gt;&gt; def f(x):
  ... ...     g(x*2)
  ... &gt;&gt;&gt; def g(x):
  ... ...     print(x+3)
  ... ...     import pdb; pdb.set_trace()
  ... &gt;&gt;&gt; f(3)
  ... '''
  &gt;&gt;&gt; test = parser.get_doctest(doc, globals(), "foo-bar@baz", "foo-bar@baz.py", 0)
  &gt;&gt;&gt; real_stdin = sys.stdin
  &gt;&gt;&gt; sys.stdin = FakeInput([
  ...    'list',     # list source from example 2
  ...    'next',     # return from g()
  ...    'list',     # list source from example 1
  ...    'next',     # return from f()
  ...    'list',     # list source from example 3
  ...    'continue', # stop debugging
  ...    ''])
  &gt;&gt;&gt; try: runner.run(test)
  ... finally: sys.stdin = real_stdin
  ... # doctest: +NORMALIZE_WHITESPACE
  --Return--
  &gt; &lt;doctest foo-bar@baz[1]&gt;(3)g()-&gt;None
  -&gt; import pdb; pdb.set_trace()
  (Pdb) list
    1     def g(x):
    2         print(x+3)
    3  -&gt;     import pdb; pdb.set_trace()
  [EOF]
  (Pdb) next
  --Return--
  &gt; &lt;doctest foo-bar@baz[0]&gt;(2)f()-&gt;None
  -&gt; g(x*2)
  (Pdb) list
    1     def f(x):
    2  -&gt;     g(x*2)
  [EOF]
  (Pdb) next
  --Return--
  &gt; &lt;doctest foo-bar@baz[2]&gt;(1)&lt;module&gt;()-&gt;None
  -&gt; f(3)
  (Pdb) list
    1  -&gt; f(3)
  [EOF]
  (Pdb) continue
  **********************************************************************
  File "foo-bar@baz.py", line 7, in foo-bar@baz
  Failed example:
      f(3)
  Expected nothing
  Got:
      9
  TestResults(failed=1, attempted=3)</pre> 
</div>
</div>
<a id="a8e85b35e9156c4872976d4600f1eb806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e85b35e9156c4872976d4600f1eb806">&#9670;&nbsp;</a></span>test_pdb_set_trace_nested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_pdb_set_trace_nested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This illustrates more-demanding use of set_trace with nested functions.

&gt;&gt;&gt; class C(object):
...     def calls_set_trace(self):
...         y = 1
...         import pdb; pdb.set_trace()
...         self.f1()
...         y = 2
...     def f1(self):
...         x = 1
...         self.f2()
...         x = 2
...     def f2(self):
...         z = 1
...         z = 2

&gt;&gt;&gt; calls_set_trace = C().calls_set_trace

&gt;&gt;&gt; doc = '''
... &gt;&gt;&gt; a = 1
... &gt;&gt;&gt; calls_set_trace()
... '''
&gt;&gt;&gt; parser = doctest.DocTestParser()
&gt;&gt;&gt; runner = doctest.DocTestRunner(verbose=False)
&gt;&gt;&gt; test = parser.get_doctest(doc, globals(), "foo-bar@baz", "foo-bar@baz.py", 0)
&gt;&gt;&gt; real_stdin = sys.stdin
&gt;&gt;&gt; sys.stdin = FakeInput([
...    'print(y)',  # print data defined in the function
...    'step', 'step', 'step', 'step', 'step', 'step', 'print(z)',
...    'up', 'print(x)',
...    'up', 'print(y)',
...    'up', 'print(foo)',
...    'continue', # stop debugging
...    ''])

&gt;&gt;&gt; try:
...     runner.run(test)
... finally:
...     sys.stdin = real_stdin
... # doctest: +REPORT_NDIFF
&gt; &lt;doctest test.test_doctest.test_doctest.test_pdb_set_trace_nested[0]&gt;(5)calls_set_trace()
-&gt; self.f1()
(Pdb) print(y)
1
(Pdb) step
--Call--
&gt; &lt;doctest test.test_doctest.test_doctest.test_pdb_set_trace_nested[0]&gt;(7)f1()
-&gt; def f1(self):
(Pdb) step
&gt; &lt;doctest test.test_doctest.test_doctest.test_pdb_set_trace_nested[0]&gt;(8)f1()
-&gt; x = 1
(Pdb) step
&gt; &lt;doctest test.test_doctest.test_doctest.test_pdb_set_trace_nested[0]&gt;(9)f1()
-&gt; self.f2()
(Pdb) step
--Call--
&gt; &lt;doctest test.test_doctest.test_doctest.test_pdb_set_trace_nested[0]&gt;(11)f2()
-&gt; def f2(self):
(Pdb) step
&gt; &lt;doctest test.test_doctest.test_doctest.test_pdb_set_trace_nested[0]&gt;(12)f2()
-&gt; z = 1
(Pdb) step
&gt; &lt;doctest test.test_doctest.test_doctest.test_pdb_set_trace_nested[0]&gt;(13)f2()
-&gt; z = 2
(Pdb) print(z)
1
(Pdb) up
&gt; &lt;doctest test.test_doctest.test_doctest.test_pdb_set_trace_nested[0]&gt;(9)f1()
-&gt; self.f2()
(Pdb) print(x)
1
(Pdb) up
&gt; &lt;doctest test.test_doctest.test_doctest.test_pdb_set_trace_nested[0]&gt;(5)calls_set_trace()
-&gt; self.f1()
(Pdb) print(y)
1
(Pdb) up
&gt; &lt;doctest foo-bar@baz[1]&gt;(1)&lt;module&gt;()
-&gt; calls_set_trace()
(Pdb) print(foo)
*** NameError: name 'foo' is not defined
(Pdb) continue
TestResults(failed=0, attempted=2)</pre> 
</div>
</div>
<a id="ac1144e820e2e4430a16a3152dbdb4690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1144e820e2e4430a16a3152dbdb4690">&#9670;&nbsp;</a></span>test_run_doctestsuite_multiple_times()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_run_doctestsuite_multiple_times </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">It was not possible to run the same DocTestSuite multiple times
http://bugs.python.org/issue2604
http://bugs.python.org/issue9736

&gt;&gt;&gt; import unittest
&gt;&gt;&gt; import test.test_doctest.sample_doctest
&gt;&gt;&gt; suite = doctest.DocTestSuite(test.test_doctest.sample_doctest)
&gt;&gt;&gt; suite.run(unittest.TestResult())
&lt;unittest.result.TestResult run=9 errors=0 failures=4&gt;
&gt;&gt;&gt; suite.run(unittest.TestResult())
&lt;unittest.result.TestResult run=9 errors=0 failures=4&gt;
</pre> 
</div>
</div>
<a id="adc429e723eda0f0588c05ed5b5998f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc429e723eda0f0588c05ed5b5998f79">&#9670;&nbsp;</a></span>test_syntax_error_subclass_from_stdlib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_syntax_error_subclass_from_stdlib </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">`ParseError` is a subclass of `SyntaxError`, but it is not a builtin:

&gt;&gt;&gt; test_syntax_error_subclass_from_stdlib()
Traceback (most recent call last):
  ...
xml.etree.ElementTree.ParseError: error
error
Note
Line
</pre> 
</div>
</div>
<a id="ae1656afb8aac9b5fb42ca4f5c022368a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1656afb8aac9b5fb42ca4f5c022368a">&#9670;&nbsp;</a></span>test_syntax_error_with_incorrect_expected_note()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_syntax_error_with_incorrect_expected_note </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">&gt;&gt;&gt; def f(x):
...     r'''
...     &gt;&gt;&gt; exc = SyntaxError("error", ("x.py", 23, None, "bad syntax"))
...     &gt;&gt;&gt; exc.add_note('note1')
...     &gt;&gt;&gt; exc.add_note('note2')
...     &gt;&gt;&gt; raise exc
...     Traceback (most recent call last):
...     SyntaxError: error
...     wrong note
...     '''
&gt;&gt;&gt; test = doctest.DocTestFinder().find(f)[0]
&gt;&gt;&gt; doctest.DocTestRunner(verbose=False).run(test)
... # doctest: +ELLIPSIS
**********************************************************************
File "...", line 6, in f
Failed example:
    raise exc
Expected:
    Traceback (most recent call last):
    SyntaxError: error
    wrong note
Got:
    Traceback (most recent call last):
      ...
    SyntaxError: error
    note1
    note2
TestResults(failed=1, attempted=...)
</pre> 
</div>
</div>
<a id="a8e17aafeedd78f79321cf3b48f3084f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e17aafeedd78f79321cf3b48f3084f4">&#9670;&nbsp;</a></span>test_syntax_error_with_note()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_syntax_error_with_note </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multiline</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">&gt;&gt;&gt; test_syntax_error_with_note(SyntaxError)
Traceback (most recent call last):
  ...
SyntaxError: error
Note

&gt;&gt;&gt; test_syntax_error_with_note(SyntaxError)
Traceback (most recent call last):
SyntaxError: error
Note

&gt;&gt;&gt; test_syntax_error_with_note(SyntaxError)
Traceback (most recent call last):
  ...
  File "x.py", line 23
    bad syntax
SyntaxError: error
Note

&gt;&gt;&gt; test_syntax_error_with_note(IndentationError)
Traceback (most recent call last):
  ...
IndentationError: error
Note

&gt;&gt;&gt; test_syntax_error_with_note(TabError, multiline=True)
Traceback (most recent call last):
  ...
TabError: error
Note
Line
</pre> 
</div>
</div>
<a id="a57a33b571abc77b9479f15cc2b68794c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a33b571abc77b9479f15cc2b68794c">&#9670;&nbsp;</a></span>test_testfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_testfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Tests for the `testfile()` function.  This function runs all the
doctest examples in a given file.  In its simple invocation, it is
called with the name of a file, which is taken to be relative to the
calling module.  The return value is (#failures, #tests).

We don't want `-v` in sys.argv for these tests.

&gt;&gt;&gt; save_argv = sys.argv
&gt;&gt;&gt; if '-v' in sys.argv:
...     sys.argv = [arg for arg in save_argv if arg != '-v']


&gt;&gt;&gt; doctest.testfile('test_doctest.txt') # doctest: +ELLIPSIS
**********************************************************************
File "...", line 6, in test_doctest.txt
Failed example:
    favorite_color
Exception raised:
    ...
    NameError: name 'favorite_color' is not defined
**********************************************************************
1 items had failures:
   1 of   2 in test_doctest.txt
***Test Failed*** 1 failures.
TestResults(failed=1, attempted=2)
&gt;&gt;&gt; doctest.master = None  # Reset master.

(Note: we'll be clearing doctest.master after each call to
`doctest.testfile`, to suppress warnings about multiple tests with the
same name.)

Globals may be specified with the `globs` and `extraglobs` parameters:

&gt;&gt;&gt; globs = {'favorite_color': 'blue'}
&gt;&gt;&gt; doctest.testfile('test_doctest.txt', globs=globs)
TestResults(failed=0, attempted=2)
&gt;&gt;&gt; doctest.master = None  # Reset master.

&gt;&gt;&gt; extraglobs = {'favorite_color': 'red'}
&gt;&gt;&gt; doctest.testfile('test_doctest.txt', globs=globs,
...                  extraglobs=extraglobs) # doctest: +ELLIPSIS
**********************************************************************
File "...", line 6, in test_doctest.txt
Failed example:
    favorite_color
Expected:
    'blue'
Got:
    'red'
**********************************************************************
1 items had failures:
   1 of   2 in test_doctest.txt
***Test Failed*** 1 failures.
TestResults(failed=1, attempted=2)
&gt;&gt;&gt; doctest.master = None  # Reset master.

The file may be made relative to a given module or package, using the
optional `module_relative` parameter:

&gt;&gt;&gt; doctest.testfile('test_doctest.txt', globs=globs,
...                  module_relative='test')
TestResults(failed=0, attempted=2)
&gt;&gt;&gt; doctest.master = None  # Reset master.

Verbosity can be increased with the optional `verbose` parameter:

&gt;&gt;&gt; doctest.testfile('test_doctest.txt', globs=globs, verbose=True)
Trying:
    favorite_color
Expecting:
    'blue'
ok
Trying:
    if 1:
       print('a')
       print()
       print('b')
Expecting:
    a
    &lt;BLANKLINE&gt;
    b
ok
1 items passed all tests:
   2 tests in test_doctest.txt
2 tests in 1 items.
2 passed and 0 failed.
Test passed.
TestResults(failed=0, attempted=2)
&gt;&gt;&gt; doctest.master = None  # Reset master.

The name of the test may be specified with the optional `name`
parameter:

&gt;&gt;&gt; doctest.testfile('test_doctest.txt', name='newname')
... # doctest: +ELLIPSIS
**********************************************************************
File "...", line 6, in newname
...
TestResults(failed=1, attempted=2)
&gt;&gt;&gt; doctest.master = None  # Reset master.

The summary report may be suppressed with the optional `report`
parameter:

&gt;&gt;&gt; doctest.testfile('test_doctest.txt', report=False)
... # doctest: +ELLIPSIS
**********************************************************************
File "...", line 6, in test_doctest.txt
Failed example:
    favorite_color
Exception raised:
    ...
    NameError: name 'favorite_color' is not defined
TestResults(failed=1, attempted=2)
&gt;&gt;&gt; doctest.master = None  # Reset master.

The optional keyword argument `raise_on_error` can be used to raise an
exception on the first error (which may be useful for postmortem
debugging):

&gt;&gt;&gt; doctest.testfile('test_doctest.txt', raise_on_error=True)
... # doctest: +ELLIPSIS
Traceback (most recent call last):
doctest.UnexpectedException: ...
&gt;&gt;&gt; doctest.master = None  # Reset master.

If the tests contain non-ASCII characters, the tests might fail, since
it's unknown which encoding is used. The encoding can be specified
using the optional keyword argument `encoding`:

&gt;&gt;&gt; doctest.testfile('test_doctest4.txt', encoding='latin-1') # doctest: +ELLIPSIS
**********************************************************************
File "...", line 7, in test_doctest4.txt
Failed example:
    '...'
Expected:
    'f\xf6\xf6'
Got:
    'f\xc3\xb6\xc3\xb6'
**********************************************************************
...
**********************************************************************
1 items had failures:
   2 of   2 in test_doctest4.txt
***Test Failed*** 2 failures.
TestResults(failed=2, attempted=2)
&gt;&gt;&gt; doctest.master = None  # Reset master.

&gt;&gt;&gt; doctest.testfile('test_doctest4.txt', encoding='utf-8')
TestResults(failed=0, attempted=2)
&gt;&gt;&gt; doctest.master = None  # Reset master.

Test the verbose output:

&gt;&gt;&gt; doctest.testfile('test_doctest4.txt', encoding='utf-8', verbose=True)
Trying:
    'föö'
Expecting:
    'f\xf6\xf6'
ok
Trying:
    'bąr'
Expecting:
    'b\u0105r'
ok
1 items passed all tests:
   2 tests in test_doctest4.txt
2 tests in 1 items.
2 passed and 0 failed.
Test passed.
TestResults(failed=0, attempted=2)
&gt;&gt;&gt; doctest.master = None  # Reset master.
&gt;&gt;&gt; sys.argv = save_argv
</pre> 
</div>
</div>
<a id="a303d144abb6c7fd54b967507512af1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303d144abb6c7fd54b967507512af1b0">&#9670;&nbsp;</a></span>test_testmod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_testmod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Tests for the testmod function.  More might be useful, but for now we're just
testing the case raised by Issue 6195, where trying to doctest a C module would
fail with a UnicodeDecodeError because doctest tried to read the "source" lines
out of the binary module.

    &gt;&gt;&gt; import unicodedata
    &gt;&gt;&gt; doctest.testmod(unicodedata, verbose=False)
    TestResults(failed=0, attempted=0)
</pre> 
</div>
</div>
<a id="a62f4c4d93d5070cc186fc6b2842b0a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f4c4d93d5070cc186fc6b2842b0a9b">&#9670;&nbsp;</a></span>test_testsource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_testsource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Unit tests for `testsource()`.

The testsource() function takes a module and a name, finds the (first)
test with that name in that module, and converts it to a script. The
example code is converted to regular Python code.  The surrounding
words and expected output are converted to comments:

&gt;&gt;&gt; from test.test_doctest import test_doctest
&gt;&gt;&gt; name = 'test.test_doctest.test_doctest.sample_func'
&gt;&gt;&gt; print(doctest.testsource(test_doctest, name))
# Blah blah
#
print(sample_func(22))
# Expected:
## 44
#
# Yee ha!
&lt;BLANKLINE&gt;

&gt;&gt;&gt; name = 'test.test_doctest.test_doctest.SampleNewStyleClass'
&gt;&gt;&gt; print(doctest.testsource(test_doctest, name))
print('1\n2\n3')
# Expected:
## 1
## 2
## 3
&lt;BLANKLINE&gt;

&gt;&gt;&gt; name = 'test.test_doctest.test_doctest.SampleClass.a_classmethod'
&gt;&gt;&gt; print(doctest.testsource(test_doctest, name))
print(SampleClass.a_classmethod(10))
# Expected:
## 12
print(SampleClass(0).a_classmethod(10))
# Expected:
## 12
&lt;BLANKLINE&gt;
</pre> 
</div>
</div>
<a id="a783f931b14d57835cdd1f32fbb401fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783f931b14d57835cdd1f32fbb401fe1">&#9670;&nbsp;</a></span>test_trailing_space_in_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_trailing_space_in_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Trailing spaces in expected output are significant:

  &gt;&gt;&gt; x, y = 'foo', ''
  &gt;&gt;&gt; print(x, y)
  foo \n
</pre> 
</div>
</div>
<a id="af10f97a64784744dcba6b695d742d752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10f97a64784744dcba6b695d742d752">&#9670;&nbsp;</a></span>test_unicode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_unicode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check doctest with a non-ascii filename:

&gt;&gt;&gt; doc = '''
... &gt;&gt;&gt; raise Exception('clé')
... '''
...
&gt;&gt;&gt; parser = doctest.DocTestParser()
&gt;&gt;&gt; test = parser.get_doctest(doc, {}, "foo-bär@baz", "foo-bär@baz.py", 0)
&gt;&gt;&gt; test
&lt;DocTest foo-bär@baz from foo-bär@baz.py:0 (1 example)&gt;
&gt;&gt;&gt; runner = doctest.DocTestRunner(verbose=False)
&gt;&gt;&gt; runner.run(test) # doctest: +ELLIPSIS
**********************************************************************
File "foo-bär@baz.py", line 2, in foo-bär@baz
Failed example:
    raise Exception('clé')
Exception raised:
    Traceback (most recent call last):
      File ...
        exec(compile(example.source, filename, "single",
      File "&lt;doctest foo-bär@baz[0]&gt;", line 1, in &lt;module&gt;
        raise Exception('clé')
    Exception: clé
TestResults(failed=1, attempted=1)
</pre> 
</div>
</div>
<a id="a2726c9f3c24f5223c327cc4553ce9a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2726c9f3c24f5223c327cc4553ce9a49">&#9670;&nbsp;</a></span>test_unittest_reportflags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_unittest_reportflags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Default unittest reporting flags can be set to control reporting

Here, we'll set the REPORT_ONLY_FIRST_FAILURE option so we see
only the first failure of each test.  First, we'll look at the
output without the flag.  The file test_doctest.txt file has two
tests. They both fail if blank lines are disabled:

  &gt;&gt;&gt; suite = doctest.DocFileSuite('test_doctest.txt',
  ...                          optionflags=doctest.DONT_ACCEPT_BLANKLINE)
  &gt;&gt;&gt; import unittest
  &gt;&gt;&gt; result = suite.run(unittest.TestResult())
  &gt;&gt;&gt; print(result.failures[0][1]) # doctest: +ELLIPSIS
  Traceback ...
  Failed example:
      favorite_color
  ...
  Failed example:
      if 1:
  ...

Note that we see both failures displayed.

  &gt;&gt;&gt; old = doctest.set_unittest_reportflags(
  ...    doctest.REPORT_ONLY_FIRST_FAILURE)

Now, when we run the test:

  &gt;&gt;&gt; result = suite.run(unittest.TestResult())
  &gt;&gt;&gt; print(result.failures[0][1]) # doctest: +ELLIPSIS
  Traceback ...
  Failed example:
      favorite_color
  Exception raised:
      ...
      NameError: name 'favorite_color' is not defined
  &lt;BLANKLINE&gt;
  &lt;BLANKLINE&gt;

We get only the first failure.

If we give any reporting options when we set up the tests,
however:

  &gt;&gt;&gt; suite = doctest.DocFileSuite('test_doctest.txt',
  ...     optionflags=doctest.DONT_ACCEPT_BLANKLINE | doctest.REPORT_NDIFF)

Then the default eporting options are ignored:

  &gt;&gt;&gt; result = suite.run(unittest.TestResult())

*NOTE*: These doctest are intentionally not placed in raw string to depict
the trailing whitespace using `\x20` in the diff below.

  &gt;&gt;&gt; print(result.failures[0][1]) # doctest: +ELLIPSIS
  Traceback ...
  Failed example:
      favorite_color
  ...
  Failed example:
      if 1:
         print('a')
         print()
         print('b')
  Differences (ndiff with -expected +actual):
        a
      - &lt;BLANKLINE&gt;
      +\x20
        b
  &lt;BLANKLINE&gt;
  &lt;BLANKLINE&gt;


Test runners can restore the formatting flags after they run:

  &gt;&gt;&gt; ignored = doctest.set_unittest_reportflags(old)</pre> 
</div>
</div>
<a id="aa7f19244ab2854637e5a528ac5195574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f19244ab2854637e5a528ac5195574">&#9670;&nbsp;</a></span>test_wrapped_c_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.test_wrapped_c_func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"># https://github.com/python/cpython/issues/117692
&gt;&gt;&gt; import binascii
&gt;&gt;&gt; from test.test_doctest.decorator_mod import decorator

&gt;&gt;&gt; c_func_wrapped = decorator(binascii.b2a_hex)
&gt;&gt;&gt; tests = doctest.DocTestFinder(exclude_empty=False).find(c_func_wrapped)
&gt;&gt;&gt; for test in tests:
...    print(test.lineno, test.name)
None b2a_hex
</pre> 
</div>
</div>
<a id="ae1a0cc2db6192fd6988bd6cb24473b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a0cc2db6192fd6988bd6cb24473b25">&#9670;&nbsp;</a></span>wrapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def test.test_doctest.test_doctest.wrapped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Docstrings in wrapped functions must be detected as well.

&gt;&gt;&gt; 'one other test'
'one other test'
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
