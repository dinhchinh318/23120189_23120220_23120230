<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PHONE MANAGEMENT: UI-UX/SFML/include/lzma/index.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PHONE MANAGEMENT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_669fb1e37e108424641b4492fae48a00.html">UI-UX</a></li><li class="navelem"><a class="el" href="dir_fef68780f280e2b18cfa5347c2a48e1f.html">SFML</a></li><li class="navelem"><a class="el" href="dir_ab5abbf355e63c20d9132dc628d44eb6.html">include</a></li><li class="navelem"><a class="el" href="dir_40a6e693a8331efa19c2f3d27b8cdc28.html">lzma</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">index.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Handling of .xz Index and related information.  
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="index_8h__dep__incl.png" border="0" usemap="#UI-UX_2SFML_2include_2lzma_2index_8hdep" alt=""/></div>
<map name="UI-UX_2SFML_2include_2lzma_2index_8hdep" id="UI-UX_2SFML_2include_2lzma_2index_8hdep">
<area shape="rect" title="Handling of .xz Index and related information." alt="" coords="5,5,156,47"/>
<area shape="rect" href="lzma_8h_source.html" title=" " alt="" coords="5,95,156,136"/>
</map>
</div>
</div>
<p><a href="index_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__index__iter.html">lzma_index_iter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to get information about Blocks and Streams.  <a href="structlzma__index__iter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2643014196abf129ddbb51ec2bd956d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8h.html#a2643014196abf129ddbb51ec2bd956d9">LZMA_INDEX_CHECK_MASK_NONE</a>&#160;&#160;&#160;(UINT32_C(1) &lt;&lt; <a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3fa7b9851d75abfabc08d7fc5b4aaeb6f20">LZMA_CHECK_NONE</a>)</td></tr>
<tr class="memdesc:a2643014196abf129ddbb51ec2bd956d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for return value from lzma_index_checks() for check none.  <a href="index_8h.html#a2643014196abf129ddbb51ec2bd956d9">More...</a><br /></td></tr>
<tr class="separator:a2643014196abf129ddbb51ec2bd956d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6812319b2f335df98fcf5e97c144e4ac"><td class="memItemLeft" align="right" valign="top"><a id="a6812319b2f335df98fcf5e97c144e4ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8h.html#a6812319b2f335df98fcf5e97c144e4ac">LZMA_INDEX_CHECK_MASK_CRC32</a>&#160;&#160;&#160;(UINT32_C(1) &lt;&lt; <a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3fa0be65014a40b5cb4ab32252b3709bef7">LZMA_CHECK_CRC32</a>)</td></tr>
<tr class="memdesc:a6812319b2f335df98fcf5e97c144e4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for return value from lzma_index_checks() for check CRC32. <br /></td></tr>
<tr class="separator:a6812319b2f335df98fcf5e97c144e4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062a47783c17f64728d98b831411c5c3"><td class="memItemLeft" align="right" valign="top"><a id="a062a47783c17f64728d98b831411c5c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8h.html#a062a47783c17f64728d98b831411c5c3">LZMA_INDEX_CHECK_MASK_CRC64</a>&#160;&#160;&#160;(UINT32_C(1) &lt;&lt; <a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3fa87b4b0697a1e1ccb6766dd5c2fa24afc">LZMA_CHECK_CRC64</a>)</td></tr>
<tr class="memdesc:a062a47783c17f64728d98b831411c5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for return value from lzma_index_checks() for check CRC64. <br /></td></tr>
<tr class="separator:a062a47783c17f64728d98b831411c5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6540f1ecf60f186f7c0492937482169"><td class="memItemLeft" align="right" valign="top"><a id="ad6540f1ecf60f186f7c0492937482169"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8h.html#ad6540f1ecf60f186f7c0492937482169">LZMA_INDEX_CHECK_MASK_SHA256</a>&#160;&#160;&#160;(UINT32_C(1) &lt;&lt; <a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3faf26a55ddd204a50ae87ec3432e7bc309">LZMA_CHECK_SHA256</a>)</td></tr>
<tr class="memdesc:ad6540f1ecf60f186f7c0492937482169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for return value from lzma_index_checks() for check SHA256. <br /></td></tr>
<tr class="separator:ad6540f1ecf60f186f7c0492937482169"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afc18c1443b3b9aa0d146b44e8755b62e"><td class="memItemLeft" align="right" valign="top">typedef struct lzma_index_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a></td></tr>
<tr class="memdesc:afc18c1443b3b9aa0d146b44e8755b62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque data type to hold the Index(es) and other information.  <a href="index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">More...</a><br /></td></tr>
<tr class="separator:afc18c1443b3b9aa0d146b44e8755b62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a712b43192d944bf2f767711343cd9ca8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8h.html#a712b43192d944bf2f767711343cd9ca8">lzma_index_iter_mode</a> { <a class="el" href="index_8h.html#a712b43192d944bf2f767711343cd9ca8af46f6e5c414471c7c96586f380e48315">LZMA_INDEX_ITER_ANY</a> = 0, 
<a class="el" href="index_8h.html#a712b43192d944bf2f767711343cd9ca8a5b31d985de1c823151acdd7e4a966fc9">LZMA_INDEX_ITER_STREAM</a> = 1, 
<a class="el" href="index_8h.html#a712b43192d944bf2f767711343cd9ca8a2702617d60d6fc15138a749e06ef3414">LZMA_INDEX_ITER_BLOCK</a> = 2, 
<a class="el" href="index_8h.html#a712b43192d944bf2f767711343cd9ca8aa49bf4d561d8f2c61d300edbb6c282c7">LZMA_INDEX_ITER_NONEMPTY_BLOCK</a> = 3
 }</td></tr>
<tr class="memdesc:a712b43192d944bf2f767711343cd9ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation mode for lzma_index_iter_next()  <a href="index_8h.html#a712b43192d944bf2f767711343cd9ca8">More...</a><br /></td></tr>
<tr class="separator:a712b43192d944bf2f767711343cd9ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae98b469f1c6f135edcc819a05a4a6312"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8h.html#ae98b469f1c6f135edcc819a05a4a6312">LZMA_API</a> (uint64_t) lzma_index_memusage(<a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> streams</td></tr>
<tr class="memdesc:ae98b469f1c6f135edcc819a05a4a6312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate memory usage of lzma_index.  <a href="index_8h.html#ae98b469f1c6f135edcc819a05a4a6312">More...</a><br /></td></tr>
<tr class="separator:ae98b469f1c6f135edcc819a05a4a6312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfc02af573bf28d9274640e6514490c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8h.html#a8dfc02af573bf28d9274640e6514490c">LZMA_API</a> (<a class="el" href="index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *) lzma_index_init(const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *allocator) lzma_nothrow</td></tr>
<tr class="memdesc:a8dfc02af573bf28d9274640e6514490c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new lzma_index structure.  <a href="index_8h.html#a8dfc02af573bf28d9274640e6514490c">More...</a><br /></td></tr>
<tr class="separator:a8dfc02af573bf28d9274640e6514490c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9533b81e07f0984dc55796323c12086b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8h.html#a9533b81e07f0984dc55796323c12086b">LZMA_API</a> (void) lzma_index_end(<a class="el" href="index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i</td></tr>
<tr class="memdesc:a9533b81e07f0984dc55796323c12086b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate lzma_index.  <a href="index_8h.html#a9533b81e07f0984dc55796323c12086b">More...</a><br /></td></tr>
<tr class="separator:a9533b81e07f0984dc55796323c12086b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab93c5f82c7bd7596b46ce2e27402c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8h.html#afab93c5f82c7bd7596b46ce2e27402c6">LZMA_API</a> (<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>) lzma_index_append(<a class="el" href="index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i</td></tr>
<tr class="memdesc:afab93c5f82c7bd7596b46ce2e27402c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new Block to lzma_index.  <a href="index_8h.html#afab93c5f82c7bd7596b46ce2e27402c6">More...</a><br /></td></tr>
<tr class="separator:afab93c5f82c7bd7596b46ce2e27402c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac829732f7970ec88721e29f1a593df18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8h.html#ac829732f7970ec88721e29f1a593df18">LZMA_API</a> (uint32_t) lzma_index_checks(const <a class="el" href="index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *i) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:ac829732f7970ec88721e29f1a593df18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the types of integrity Checks.  <a href="index_8h.html#ac829732f7970ec88721e29f1a593df18">More...</a><br /></td></tr>
<tr class="separator:ac829732f7970ec88721e29f1a593df18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f1fb94dc708cd332db1c58f3f4ca69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8h.html#ac8f1fb94dc708cd332db1c58f3f4ca69">LZMA_API</a> (<a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a>) lzma_index_iter_next(<a class="el" href="structlzma__index__iter.html">lzma_index_iter</a> *iter</td></tr>
<tr class="memdesc:ac8f1fb94dc708cd332db1c58f3f4ca69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next Block or Stream.  <a href="index_8h.html#ac8f1fb94dc708cd332db1c58f3f4ca69">More...</a><br /></td></tr>
<tr class="separator:ac8f1fb94dc708cd332db1c58f3f4ca69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a728fec5d993ba02e68d57a42b9f1cd92"><td class="memItemLeft" align="right" valign="top"><a id="a728fec5d993ba02e68d57a42b9f1cd92"></a>
<a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> blocks&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_nothrow</b></td></tr>
<tr class="separator:a728fec5d993ba02e68d57a42b9f1cd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a262191c3aef519683175030acdef5"><td class="memItemLeft" align="right" valign="top"><a id="a99a262191c3aef519683175030acdef5"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>allocator</b></td></tr>
<tr class="separator:a99a262191c3aef519683175030acdef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7979179583d0c68d22577e028f6cd01"><td class="memItemLeft" align="right" valign="top"><a id="aa7979179583d0c68d22577e028f6cd01"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unpadded_size</b></td></tr>
<tr class="separator:aa7979179583d0c68d22577e028f6cd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a657de18c544bde8c60415316fcb14"><td class="memItemLeft" align="right" valign="top"><a id="a22a657de18c544bde8c60415316fcb14"></a>
const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> <a class="el" href="vli_8h.html#a1dbc0ffc3e72748f64df8f7f71898272">lzma_vli</a> uncompressed_size lzma_nothrow&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_attr_warn_unused_result</b></td></tr>
<tr class="separator:a22a657de18c544bde8c60415316fcb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f0e7f82032640961906350da4e834b"><td class="memItemLeft" align="right" valign="top"><a id="af0f0e7f82032640961906350da4e834b"></a>
<a class="el" href="index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>src</b></td></tr>
<tr class="separator:af0f0e7f82032640961906350da4e834b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686d4842602a8df8927417df3adbac37"><td class="memItemLeft" align="right" valign="top"><a id="a686d4842602a8df8927417df3adbac37"></a>
<a class="el" href="index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>i</b></td></tr>
<tr class="separator:a686d4842602a8df8927417df3adbac37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e75faab56db79cfe33d7c3d30a27a8"><td class="memItemLeft" align="right" valign="top"><a id="af3e75faab56db79cfe33d7c3d30a27a8"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>out</b></td></tr>
<tr class="separator:af3e75faab56db79cfe33d7c3d30a27a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349a406bbf028a7cb93cec74ca2f2e3b"><td class="memItemLeft" align="right" valign="top"><a id="a349a406bbf028a7cb93cec74ca2f2e3b"></a>
uint8_t size_t *&#160;</td><td class="memItemRight" valign="bottom"><b>out_pos</b></td></tr>
<tr class="separator:a349a406bbf028a7cb93cec74ca2f2e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000971d0c82376d907e0830561b2dabe"><td class="memItemLeft" align="right" valign="top"><a id="a000971d0c82376d907e0830561b2dabe"></a>
uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><b>memlimit</b></td></tr>
<tr class="separator:a000971d0c82376d907e0830561b2dabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8107a21fd07d980f38bb3a94abc541c"><td class="memItemLeft" align="right" valign="top"><a id="aa8107a21fd07d980f38bb3a94abc541c"></a>
uint64_t const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>in</b></td></tr>
<tr class="separator:aa8107a21fd07d980f38bb3a94abc541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dc8239f9d03d594028bea32495147a"><td class="memItemLeft" align="right" valign="top"><a id="a16dc8239f9d03d594028bea32495147a"></a>
uint64_t const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t *&#160;</td><td class="memItemRight" valign="bottom"><b>in_pos</b></td></tr>
<tr class="separator:a16dc8239f9d03d594028bea32495147a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b82441bd88b4558299888319ae9e6e5"><td class="memItemLeft" align="right" valign="top"><a id="a0b82441bd88b4558299888319ae9e6e5"></a>
<a class="el" href="index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>dest_index</b></td></tr>
<tr class="separator:a0b82441bd88b4558299888319ae9e6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Handling of .xz Index and related information. </p>
<dl class="section note"><dt>Note</dt><dd>Never include this file directly. Use &lt;<a class="el" href="lzma_8h_source.html">lzma.h</a>&gt; instead. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2643014196abf129ddbb51ec2bd956d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2643014196abf129ddbb51ec2bd956d9">&#9670;&nbsp;</a></span>LZMA_INDEX_CHECK_MASK_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_INDEX_CHECK_MASK_NONE&#160;&#160;&#160;(UINT32_C(1) &lt;&lt; <a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3fa7b9851d75abfabc08d7fc5b4aaeb6f20">LZMA_CHECK_NONE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask for return value from lzma_index_checks() for check none. </p>
<dl class="section note"><dt>Note</dt><dd>This and the other CHECK_MASK macros were added in 5.5.1alpha. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="afc18c1443b3b9aa0d146b44e8755b62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc18c1443b3b9aa0d146b44e8755b62e">&#9670;&nbsp;</a></span>lzma_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lzma_index_s <a class="el" href="index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque data type to hold the Index(es) and other information. </p>
<p>lzma_index often holds just one .xz Index and possibly the Stream Flags of the same Stream and size of the Stream Padding field. However, multiple lzma_indexes can be concatenated with lzma_index_cat() and then there may be information about multiple Streams in the same lzma_index.</p>
<p>Notes about thread safety: Only one thread may modify lzma_index at a time. All functions that take non-const pointer to lzma_index modify it. As long as no thread is modifying the lzma_index, getting information from the same lzma_index can be done from multiple threads at the same time with functions that take a const pointer to lzma_index or use <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a>. The same iterator must be used only by one thread at a time, of course, but there can be as many iterators for the same lzma_index as needed. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a712b43192d944bf2f767711343cd9ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712b43192d944bf2f767711343cd9ca8">&#9670;&nbsp;</a></span>lzma_index_iter_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="index_8h.html#a712b43192d944bf2f767711343cd9ca8">lzma_index_iter_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation mode for lzma_index_iter_next() </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a712b43192d944bf2f767711343cd9ca8af46f6e5c414471c7c96586f380e48315"></a>LZMA_INDEX_ITER_ANY&#160;</td><td class="fielddoc"><p>Get the next Block or Stream. </p>
<p>Go to the next Block if the current Stream has at least one Block left. Otherwise go to the next Stream even if it has no Blocks. If the Stream has no Blocks (lzma_index_iter.stream.block_count == 0), lzma_index_iter.block will have undefined values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a712b43192d944bf2f767711343cd9ca8a5b31d985de1c823151acdd7e4a966fc9"></a>LZMA_INDEX_ITER_STREAM&#160;</td><td class="fielddoc"><p>Get the next Stream. </p>
<p>Go to the next Stream even if the current Stream has unread Blocks left. If the next Stream has at least one Block, the iterator will point to the first Block. If there are no Blocks, lzma_index_iter.block will have undefined values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a712b43192d944bf2f767711343cd9ca8a2702617d60d6fc15138a749e06ef3414"></a>LZMA_INDEX_ITER_BLOCK&#160;</td><td class="fielddoc"><p>Get the next Block. </p>
<p>Go to the next Block if the current Stream has at least one Block left. If the current Stream has no Blocks left, the next Stream with at least one Block is located and the iterator will be made to point to the first Block of that Stream. </p>
</td></tr>
<tr><td class="fieldname"><a id="a712b43192d944bf2f767711343cd9ca8aa49bf4d561d8f2c61d300edbb6c282c7"></a>LZMA_INDEX_ITER_NONEMPTY_BLOCK&#160;</td><td class="fielddoc"><p>Get the next non-empty Block. </p>
<p>This is like LZMA_INDEX_ITER_BLOCK except that it will skip Blocks whose Uncompressed Size is zero. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac8f1fb94dc708cd332db1c58f3f4ca69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f1fb94dc708cd332db1c58f3f4ca69">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next Block or Stream. </p>
<p>Test if the given Filter ID is supported for encoding.</p>
<p>Test if the given Check ID is supported.</p>
<p>Locate a Block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Iterator initialized with lzma_index_iter_init() </td></tr>
    <tr><td class="paramname">mode</td><td>Specify what kind of information the caller wants to get. See lzma_index_iter_mode for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lzma_bool:<ul>
<li>true if no Block or Stream matching the mode is found. *iter is not updated (failure).</li>
<li>false if the next Block or Stream matching the mode was found. *iter is updated (success).</li>
</ul>
</dd></dl>
<p>If it is possible to seek in the .xz file, it is possible to parse the Index field(s) and use lzma_index_iter_locate() to do random-access reading with granularity of Block size.</p>
<p>If the target is smaller than the uncompressed size of the Stream (can be checked with lzma_index_uncompressed_size()):</p><ul>
<li>Information about the Stream and Block containing the requested uncompressed offset is stored into *iter.</li>
<li>Internal state of the iterator is adjusted so that lzma_index_iter_next() can be used to read subsequent Blocks or Streams.</li>
</ul>
<p>If the target is greater than the uncompressed size of the Stream, *iter is not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Iterator that was earlier initialized with lzma_index_iter_init(). </td></tr>
    <tr><td class="paramname">target</td><td>Uncompressed target offset which the caller would like to locate from the Stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lzma_bool:<ul>
<li>true if the target is greater than or equal to the uncompressed size of the Stream (failure)</li>
<li>false if the target is smaller than the uncompressed size of the Stream (success) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8dfc02af573bf28d9274640e6514490c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfc02af573bf28d9274640e6514490c">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="index_8h.html#afc18c1443b3b9aa0d146b44e8755b62e">lzma_index</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new lzma_index structure. </p>
<p>Duplicate lzma_index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to an empty initialized lzma_index is returned. If allocation fails, NULL is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure to be duplicated </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the lzma_index, or NULL if memory allocation failed. </dd></dl>

</div>
</div>
<a id="afab93c5f82c7bd7596b46ce2e27402c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab93c5f82c7bd7596b46ce2e27402c6">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new Block to lzma_index. </p>
<p>Initialize a .xz file information decoder.</p>
<p>Single-call .xz Index decoder.</p>
<p>Single-call .xz Index encoder.</p>
<p>Initialize .xz Index decoder.</p>
<p>Initialize .xz Index encoder.</p>
<p>Concatenate lzma_indexes.</p>
<p>Set the amount of Stream Padding.</p>
<p>Set the Stream Flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to a lzma_index structure </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramname">unpadded_size</td><td>Unpadded Size of a Block. This can be calculated with lzma_block_unpadded_size() after encoding or decoding the Block. </td></tr>
    <tr><td class="paramname">uncompressed_size</td><td>Uncompressed Size of a Block. This can be taken directly from <a class="el" href="structlzma__block.html" title="Options for the Block and Block Header encoders and decoders.">lzma_block</a> structure after encoding or decoding the Block.</td></tr>
  </table>
  </dd>
</dl>
<p>Appending a new Block does not invalidate iterators. For example, if an iterator was pointing to the end of the lzma_index, after lzma_index_append() it is possible to read the next Block with an existing iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR: Compressed or uncompressed size of the Stream or size of the Index field would grow too big.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>Set the Stream Flags of the last (and typically the only) Stream in lzma_index. This can be useful when reading information from the lzma_index, because to decode Blocks, knowing the integrity check type is needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure </td></tr>
    <tr><td class="paramname">stream_flags</td><td>Pointer to <a class="el" href="structlzma__stream__flags.html" title="Options for encoding/decoding Stream Header and Stream Footer.">lzma_stream_flags</a> structure. This is copied into the internal preallocated structure, so the caller doesn't need to keep the flags' data available after calling this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_OPTIONS_ERROR: Unsupported stream_flags-&gt;version.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>Set the amount of Stream Padding of the last (and typically the only) Stream in the lzma_index. This is needed when planning to do random-access reading within multiple concatenated Streams.</p>
<p>By default, the amount of Stream Padding is assumed to be zero bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_DATA_ERROR: The file size would grow too big.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>Concatenating lzma_indexes is useful when doing random-access reading in multi-Stream .xz file, or when combining multiple Streams into single Stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>lzma_index after which src is appended </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">src</td><td>lzma_index to be appended after dest. If this function succeeds, the memory allocated for src is freed or moved to be part of dest, and all iterators pointing to src will become invalid. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: lzma_indexes were concatenated successfully. src is now a dangling pointer.</li>
<li>LZMA_DATA_ERROR: *dest would grow too big.</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to properly prepared <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> </td></tr>
    <tr><td class="paramname">i</td><td>Pointer to lzma_index which should be encoded.</td></tr>
  </table>
  </dd>
</dl>
<p>The valid 'action' values for lzma_code() are LZMA_RUN and LZMA_FINISH. It is enough to use only one of them (you can choose freely).</p>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization succeeded, continue with lzma_code().</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">strm</td><td>Pointer to properly prepared <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>The decoded Index will be made available via this pointer. Initially this function will set *i to NULL (the old value is ignored). If decoding succeeds (lzma_code() returns LZMA_STREAM_END), *i will be set to point to a new lzma_index, which the application has to later free with lzma_index_end(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memlimit</td><td>How much memory the resulting lzma_index is allowed to require. liblzma 5.2.3 and earlier don't allow 0 here and return LZMA_PROG_ERROR; later versions treat 0 as if 1 had been specified.</td></tr>
  </table>
  </dd>
</dl>
<p>Valid 'action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH. There is no need to use LZMA_FINISH, but it's allowed because it may simplify certain types of applications.</p>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization succeeded, continue with lzma_code().</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>liblzma 5.2.3 and older list also LZMA_MEMLIMIT_ERROR here but that error code has never been possible from this initialization function.</dd>
<dd>
This function doesn't take allocator argument since all the internal data is allocated on stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>lzma_index to be encoded </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_BUF_ERROR: Output buffer is too small. Use lzma_index_size() to find out how much output space is needed.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>If decoding succeeds, *i will point to a new lzma_index, which the application has to later free with lzma_index_end(). If an error occurs, *i will be NULL. The old value of *i is always ignored and thus doesn't need to be initialized by the caller. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">memlimit</td><td>Pointer to how much memory the resulting lzma_index is allowed to require. The value pointed by this pointer is modified if and only if LZMA_MEMLIMIT_ERROR is returned. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Decoding was successful.</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_MEMLIMIT_ERROR: Memory usage limit was reached. The minimum required memlimit value was stored to *memlimit.</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This decoder decodes the Stream Header, Stream Footer, Index, and Stream Padding field(s) from the input .xz file and stores the resulting combined index in *dest_index. This information can be used to get the uncompressed file size with lzma_index_uncompressed_size(*dest_index) or, for example, to implement random access reading by locating the Blocks in the Streams.</p>
<p>To get the required information from the .xz file, lzma_code() may ask the application to seek in the input file by returning LZMA_SEEK_NEEDED and having the target file position specified in <a class="el" href="structlzma__stream.html#af7c43a61f3dfeb0b9c8487b7f275054e" title="New seek input position for LZMA_SEEK_NEEDED.">lzma_stream.seek_pos</a>. The number of seeks required depends on the input file and how big buffers the application provides. When possible, the decoder will seek backward and forward in the given buffer to avoid useless seek requests. Thus, if the application provides the whole file at once, no external seeking will be required (that is, lzma_code() won't return LZMA_SEEK_NEEDED).</p>
<p>The value in <a class="el" href="structlzma__stream.html#a1a411e1755d6185756caefabc3932c7b">lzma_stream.total_in</a> can be used to estimate how much data liblzma had to read to get the file information. However, due to seeking and the way total_in is updated, the value of total_in will be somewhat inaccurate (a little too big). Thus, total_in is a good estimate but don't expect to see the same exact value for the same file if you change the input buffer size or switch to a different liblzma version.</p>
<p>Valid 'action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH. You only need to use LZMA_RUN; LZMA_FINISH is only supported because it might be convenient for some applications. If you use LZMA_FINISH and if lzma_code() asks the application to seek, remember to reset 'action' back to LZMA_RUN unless you hit the end of the file again.</p>
<p>Possible return values from lzma_code():</p><ul>
<li>LZMA_OK: All OK so far, more input needed</li>
<li>LZMA_SEEK_NEEDED: Provide more input starting from the absolute file position strm-&gt;seek_pos</li>
<li>LZMA_STREAM_END: Decoding was successful, *dest_index has been set</li>
<li>LZMA_FORMAT_ERROR: The input file is not in the .xz format (the expected magic bytes were not found from the beginning of the file)</li>
<li>LZMA_OPTIONS_ERROR: File looks valid but contains headers that aren't supported by this version of liblzma</li>
<li>LZMA_DATA_ERROR: File is corrupt</li>
<li>LZMA_BUF_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_MEMLIMIT_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">strm</td><td>Pointer to a properly prepared <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest_index</td><td>Pointer to a pointer where the decoder will put the decoded lzma_index. The old value of *dest_index is ignored (not freed). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memlimit</td><td>How much memory the resulting lzma_index is allowed to require. Use UINT64_MAX to effectively disable the limiter. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">file_size</td><td>Size of the input .xz file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac829732f7970ec88721e29f1a593df18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac829732f7970ec88721e29f1a593df18">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the types of integrity Checks. </p>
<p>If lzma_index_stream_flags() is used to set the Stream Flags for every Stream, lzma_index_checks() can be used to get a bitmask to indicate which Check types have been used. It can be useful e.g. if showing the Check types to the user.</p>
<p>The bitmask is 1 &lt;&lt; check_id, e.g. CRC32 is 1 &lt;&lt; 1 and SHA-256 is 1 &lt;&lt; 10. These masks are defined for convenience as LZMA_INDEX_CHECK_MASK_XXX</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitmask indicating which Check types are used in the lzma_index </dd></dl>

</div>
</div>
<a id="ae98b469f1c6f135edcc819a05a4a6312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98b469f1c6f135edcc819a05a4a6312">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate memory usage of lzma_index. </p>
<p>Get the total amount of physical memory (RAM) in bytes.</p>
<p>Calculate approximate memory usage of easy encoder.</p>
<p>Get the uncompressed size of the file.</p>
<p>Get the total size of the file.</p>
<p>Get the total size of the Blocks.</p>
<p>Get the total size of the Stream.</p>
<p>Get the size of the Index field as bytes.</p>
<p>Get the number of Blocks.</p>
<p>Get the number of Streams.</p>
<p>Calculate the memory usage of an existing lzma_index.</p>
<p>On disk, the size of the Index field depends on both the number of Records stored and the size of the Records (due to variable-length integer encoding). When the Index is kept in lzma_index structure, the memory usage depends only on the number of Records/Blocks stored in the Index(es), and in case of concatenated lzma_indexes, the number of Streams. The size in RAM is almost always significantly bigger than in the encoded form on disk.</p>
<p>This function calculates an approximate amount of memory needed to hold the given number of Streams and Blocks in lzma_index structure. This value may vary between CPU architectures and also between liblzma versions if the internal implementation is modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streams</td><td>Number of Streams </td></tr>
    <tr><td class="paramname">blocks</td><td>Number of Blocks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximate memory in bytes needed in a lzma_index structure.</dd></dl>
<p>This is a shorthand for lzma_index_memusage(lzma_index_stream_count(i), lzma_index_block_count(i)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximate memory in bytes used by the lzma_index structure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of Streams in the lzma_index</dd></dl>
<p>This returns the total number of Blocks in lzma_index. To get number of Blocks in individual Streams, use <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of blocks in the lzma_index</dd></dl>
<p>This is needed to verify the Backward Size field in the Stream Footer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the Index</dd></dl>
<p>If multiple lzma_indexes have been combined, this works as if the Blocks were in a single Stream. This is useful if you are going to combine Blocks from multiple Streams into a single new Stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the Stream (if all Blocks are combined into one Stream).</dd></dl>
<p>This doesn't include the Stream Header, Stream Footer, Stream Padding, or Index fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of all Blocks in the Stream(s)</dd></dl>
<p>When no lzma_indexes have been combined with lzma_index_cat() and there is no Stream Padding, this function is identical to lzma_index_stream_size(). If multiple lzma_indexes have been combined, this includes also the headers of each separate Stream and the possible Stream Padding fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total size of the .xz file in bytes</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the uncompressed data in the file </dd></dl>

</div>
</div>
<a id="a9533b81e07f0984dc55796323c12086b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9533b81e07f0984dc55796323c12086b">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate lzma_index. </p>
<p>Rewind the iterator.</p>
<p>Initialize an iterator.</p>
<p>If i is NULL, this does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure to deallocate </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free().</td></tr>
  </table>
  </dd>
</dl>
<p>This function associates the iterator with the given lzma_index, and calls lzma_index_iter_rewind() on the iterator.</p>
<p>This function doesn't allocate any memory, thus there is no lzma_index_iter_end(). The iterator is valid as long as the associated lzma_index is valid, that is, until lzma_index_end() or using it as source in lzma_index_cat(). Specifically, lzma_index doesn't become invalid if new Blocks are added to it with lzma_index_append() or if it is used as the destination in lzma_index_cat().</p>
<p>It is safe to make copies of an initialized <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a>, for example, to easily restart reading at some particular position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Pointer to a <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a> structure </td></tr>
    <tr><td class="paramname">i</td><td>lzma_index to which the iterator will be associated</td></tr>
  </table>
  </dd>
</dl>
<p>Rewind the iterator so that next call to lzma_index_iter_next() will return the first Block or Stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Pointer to a <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
