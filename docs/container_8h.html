<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PHONE MANAGEMENT: UI-UX/SFML/include/lzma/container.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PHONE MANAGEMENT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_669fb1e37e108424641b4492fae48a00.html">UI-UX</a></li><li class="navelem"><a class="el" href="dir_fef68780f280e2b18cfa5347c2a48e1f.html">SFML</a></li><li class="navelem"><a class="el" href="dir_ab5abbf355e63c20d9132dc628d44eb6.html">include</a></li><li class="navelem"><a class="el" href="dir_40a6e693a8331efa19c2f3d27b8cdc28.html">lzma</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">container.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>File formats.  
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="container_8h__dep__incl.png" border="0" usemap="#UI-UX_2SFML_2include_2lzma_2container_8hdep" alt=""/></div>
<map name="UI-UX_2SFML_2include_2lzma_2container_8hdep" id="UI-UX_2SFML_2include_2lzma_2container_8hdep">
<area shape="rect" title="File formats." alt="" coords="5,5,156,47"/>
<area shape="rect" href="lzma_8h_source.html" title=" " alt="" coords="5,95,156,136"/>
</map>
</div>
</div>
<p><a href="container_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlzma__mt.html">lzma_mt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multithreading options.  <a href="structlzma__mt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af3ca20ff228b363a82515c1aee9e27bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#af3ca20ff228b363a82515c1aee9e27bc">LZMA_PRESET_DEFAULT</a>&#160;&#160;&#160;UINT32_C(6)</td></tr>
<tr class="memdesc:af3ca20ff228b363a82515c1aee9e27bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default compression preset.  <a href="container_8h.html#af3ca20ff228b363a82515c1aee9e27bc">More...</a><br /></td></tr>
<tr class="separator:af3ca20ff228b363a82515c1aee9e27bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e40265e355a21bd2465aaa5b85f03d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a97e40265e355a21bd2465aaa5b85f03d">LZMA_PRESET_LEVEL_MASK</a>&#160;&#160;&#160;UINT32_C(0x1F)</td></tr>
<tr class="memdesc:a97e40265e355a21bd2465aaa5b85f03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for preset level.  <a href="container_8h.html#a97e40265e355a21bd2465aaa5b85f03d">More...</a><br /></td></tr>
<tr class="separator:a97e40265e355a21bd2465aaa5b85f03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af524fe9af5737820fdadcd40a2c26deb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#af524fe9af5737820fdadcd40a2c26deb">LZMA_PRESET_EXTREME</a>&#160;&#160;&#160;(UINT32_C(1) &lt;&lt; 31)</td></tr>
<tr class="memdesc:af524fe9af5737820fdadcd40a2c26deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extreme compression preset.  <a href="container_8h.html#af524fe9af5737820fdadcd40a2c26deb">More...</a><br /></td></tr>
<tr class="separator:af524fe9af5737820fdadcd40a2c26deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9cd20febb28b5ed6656de9184a86e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#ada9cd20febb28b5ed6656de9184a86e9">LZMA_TELL_NO_CHECK</a>&#160;&#160;&#160;UINT32_C(0x01)</td></tr>
<tr class="separator:ada9cd20febb28b5ed6656de9184a86e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21fb746037c82735d40d428c462e078"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#ae21fb746037c82735d40d428c462e078">LZMA_TELL_UNSUPPORTED_CHECK</a>&#160;&#160;&#160;UINT32_C(0x02)</td></tr>
<tr class="separator:ae21fb746037c82735d40d428c462e078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdde702a77ff42b90a99c0bf4147b6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a0bdde702a77ff42b90a99c0bf4147b6b">LZMA_TELL_ANY_CHECK</a>&#160;&#160;&#160;UINT32_C(0x04)</td></tr>
<tr class="separator:a0bdde702a77ff42b90a99c0bf4147b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1289925ae1c63a8e86f69f3657118a4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a1289925ae1c63a8e86f69f3657118a4d">LZMA_IGNORE_CHECK</a>&#160;&#160;&#160;UINT32_C(0x10)</td></tr>
<tr class="separator:a1289925ae1c63a8e86f69f3657118a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563c84b5f368b3dd00d92ea903c5c33d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a563c84b5f368b3dd00d92ea903c5c33d">LZMA_CONCATENATED</a>&#160;&#160;&#160;UINT32_C(0x08)</td></tr>
<tr class="separator:a563c84b5f368b3dd00d92ea903c5c33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f469ed3d4b2eaf12f8081657efc9d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#aa1f469ed3d4b2eaf12f8081657efc9d5">LZMA_FAIL_FAST</a>&#160;&#160;&#160;UINT32_C(0x20)</td></tr>
<tr class="separator:aa1f469ed3d4b2eaf12f8081657efc9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a83def1b1258ada2f9e779d079181fef7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a83def1b1258ada2f9e779d079181fef7">LZMA_API</a> (uint64_t) lzma_easy_encoder_memusage(uint32_t preset) lzma_nothrow lzma_attr_pure</td></tr>
<tr class="memdesc:a83def1b1258ada2f9e779d079181fef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate approximate memory usage of easy encoder.  <a href="container_8h.html#a83def1b1258ada2f9e779d079181fef7">More...</a><br /></td></tr>
<tr class="separator:a83def1b1258ada2f9e779d079181fef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e76e1bb8605cbbc0095de0f6588207"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#aa2e76e1bb8605cbbc0095de0f6588207">LZMA_API</a> (<a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>) lzma_easy_encoder(<a class="el" href="structlzma__stream.html">lzma_stream</a> *strm</td></tr>
<tr class="memdesc:aa2e76e1bb8605cbbc0095de0f6588207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize .xz Stream encoder using a preset number.  <a href="container_8h.html#aa2e76e1bb8605cbbc0095de0f6588207">More...</a><br /></td></tr>
<tr class="separator:aa2e76e1bb8605cbbc0095de0f6588207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8746ae92120a60ff31ee568789365dac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="container_8h.html#a8746ae92120a60ff31ee568789365dac">LZMA_API</a> (size_t) lzma_stream_buffer_bound(size_t uncompressed_size) lzma_nothrow</td></tr>
<tr class="memdesc:a8746ae92120a60ff31ee568789365dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate output buffer size for single-call Stream encoder.  <a href="container_8h.html#a8746ae92120a60ff31ee568789365dac">More...</a><br /></td></tr>
<tr class="separator:a8746ae92120a60ff31ee568789365dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a063b3a8e954f0946e7836caccb19440d"><td class="memItemLeft" align="right" valign="top"><a id="a063b3a8e954f0946e7836caccb19440d"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>preset</b></td></tr>
<tr class="separator:a063b3a8e954f0946e7836caccb19440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530448f5ff03185970177c1648494d02"><td class="memItemLeft" align="right" valign="top"><a id="a530448f5ff03185970177c1648494d02"></a>
uint32_t <a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a> check lzma_nothrow&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_attr_warn_unused_result</b></td></tr>
<tr class="separator:a530448f5ff03185970177c1648494d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c94b0defea7996f245faec2693056cb"><td class="memItemLeft" align="right" valign="top"><a id="a5c94b0defea7996f245faec2693056cb"></a>
<a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a>&#160;</td><td class="memItemRight" valign="bottom"><b>check</b></td></tr>
<tr class="separator:a5c94b0defea7996f245faec2693056cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba23af0b7f80288030b969c21983825"><td class="memItemLeft" align="right" valign="top"><a id="aaba23af0b7f80288030b969c21983825"></a>
<a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a> const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>allocator</b></td></tr>
<tr class="separator:aaba23af0b7f80288030b969c21983825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f1bdf530d3ecdb1aeaa59a43e7f9c5"><td class="memItemLeft" align="right" valign="top"><a id="a04f1bdf530d3ecdb1aeaa59a43e7f9c5"></a>
<a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a> const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>in</b></td></tr>
<tr class="separator:a04f1bdf530d3ecdb1aeaa59a43e7f9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af172ff3d7cb50947e2d0d418a721f46a"><td class="memItemLeft" align="right" valign="top"><a id="af172ff3d7cb50947e2d0d418a721f46a"></a>
<a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a> const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>in_size</b></td></tr>
<tr class="separator:af172ff3d7cb50947e2d0d418a721f46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ad326959c6f8f3c1cb4a29e260cc65"><td class="memItemLeft" align="right" valign="top"><a id="af2ad326959c6f8f3c1cb4a29e260cc65"></a>
<a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a> const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>out</b></td></tr>
<tr class="separator:af2ad326959c6f8f3c1cb4a29e260cc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868c6f38e095d9616dfb58b27e7cdaaa"><td class="memItemLeft" align="right" valign="top"><a id="a868c6f38e095d9616dfb58b27e7cdaaa"></a>
<a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a> const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t uint8_t size_t *&#160;</td><td class="memItemRight" valign="bottom"><b>out_pos</b></td></tr>
<tr class="separator:a868c6f38e095d9616dfb58b27e7cdaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9def95878b527561deeb995f33ab2599"><td class="memItemLeft" align="right" valign="top"><a id="a9def95878b527561deeb995f33ab2599"></a>
<a class="el" href="check_8h.html#a0a6100c719ac9aa49be3fdf7519e8c3f">lzma_check</a> const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t uint8_t size_t size_t out_size&#160;</td><td class="memItemRight" valign="bottom"><b>lzma_nothrow</b></td></tr>
<tr class="separator:a9def95878b527561deeb995f33ab2599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6502b3fc1c4fb0aab44ae28e009d1adc"><td class="memItemLeft" align="right" valign="top"><a id="a6502b3fc1c4fb0aab44ae28e009d1adc"></a>
const <a class="el" href="structlzma__filter.html">lzma_filter</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>filters</b></td></tr>
<tr class="separator:a6502b3fc1c4fb0aab44ae28e009d1adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000971d0c82376d907e0830561b2dabe"><td class="memItemLeft" align="right" valign="top"><a id="a000971d0c82376d907e0830561b2dabe"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>memlimit</b></td></tr>
<tr class="separator:a000971d0c82376d907e0830561b2dabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba10aaac5975fb2c7d5e997dced28ee"><td class="memItemLeft" align="right" valign="top"><a id="a4ba10aaac5975fb2c7d5e997dced28ee"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>flags</b></td></tr>
<tr class="separator:a4ba10aaac5975fb2c7d5e997dced28ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2935a3141f770067395bd484b17b5c93"><td class="memItemLeft" align="right" valign="top"><a id="a2935a3141f770067395bd484b17b5c93"></a>
uint32_t const <a class="el" href="structlzma__allocator.html">lzma_allocator</a> const uint8_t size_t *&#160;</td><td class="memItemRight" valign="bottom"><b>in_pos</b></td></tr>
<tr class="separator:a2935a3141f770067395bd484b17b5c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af942e1e92b91e1b726998fae1f3d895f"><td class="memItemLeft" align="right" valign="top"><a id="af942e1e92b91e1b726998fae1f3d895f"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>comp_size</b></td></tr>
<tr class="separator:af942e1e92b91e1b726998fae1f3d895f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d21b93a51b4eacc103fd5d1906df02"><td class="memItemLeft" align="right" valign="top"><a id="a19d21b93a51b4eacc103fd5d1906df02"></a>
uint64_t uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>uncomp_size</b></td></tr>
<tr class="separator:a19d21b93a51b4eacc103fd5d1906df02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7367c10736f27ba684286387ff279522"><td class="memItemLeft" align="right" valign="top"><a id="a7367c10736f27ba684286387ff279522"></a>
uint64_t uint64_t <a class="el" href="base_8h.html#abbc819c74b484c846825ae1388a50a59">lzma_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>uncomp_size_is_exact</b></td></tr>
<tr class="separator:a7367c10736f27ba684286387ff279522"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>File formats. </p>
<dl class="section note"><dt>Note</dt><dd>Never include this file directly. Use &lt;<a class="el" href="lzma_8h_source.html">lzma.h</a>&gt; instead. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a563c84b5f368b3dd00d92ea903c5c33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563c84b5f368b3dd00d92ea903c5c33d">&#9670;&nbsp;</a></span>LZMA_CONCATENATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_CONCATENATED&#160;&#160;&#160;UINT32_C(0x08)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag enables decoding of concatenated files with file formats that allow concatenating compressed files as is. From the formats currently supported by liblzma, only the .xz and .lz formats allow concatenated files. Concatenated files are not allowed with the legacy .lzma format.</p>
<p>This flag also affects the usage of the 'action' argument for lzma_code(). When LZMA_CONCATENATED is used, lzma_code() won't return LZMA_STREAM_END unless LZMA_FINISH is used as 'action'. Thus, the application has to set LZMA_FINISH in the same way as it does when encoding.</p>
<p>If LZMA_CONCATENATED is not used, the decoders still accept LZMA_FINISH as 'action' for lzma_code(), but the usage of LZMA_FINISH isn't required. </p>

</div>
</div>
<a id="aa1f469ed3d4b2eaf12f8081657efc9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f469ed3d4b2eaf12f8081657efc9d5">&#9670;&nbsp;</a></span>LZMA_FAIL_FAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_FAIL_FAST&#160;&#160;&#160;UINT32_C(0x20)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag makes the threaded decoder report errors (like LZMA_DATA_ERROR) as soon as they are detected. This saves time when the application has no interest in a partially decompressed truncated or corrupt file. Note that due to timing randomness, if the same truncated or corrupt input is decompressed multiple times with this flag, a different amount of output may be produced by different runs, and even the error code might vary.</p>
<p>When using LZMA_FAIL_FAST, it is recommended to use LZMA_FINISH to tell the decoder when no more input will be coming because it can help fast detection and reporting of truncated files. Note that in this situation truncated files might be diagnosed with LZMA_DATA_ERROR instead of LZMA_OK or LZMA_BUF_ERROR!</p>
<p>Without this flag the threaded decoder will provide as much output as possible at first and then report the pending error. This default behavior matches the single-threaded decoder and provides repeatable behavior with truncated or corrupt input. There are a few special cases where the behavior can still differ like memory allocation failures (LZMA_MEM_ERROR).</p>
<p>Single-threaded decoders currently ignore this flag.</p>
<p>Support for this flag was added in liblzma 5.3.3alpha. Note that in older versions this flag isn't supported (LZMA_OPTIONS_ERROR) even by functions that ignore this flag in newer liblzma versions. </p>

</div>
</div>
<a id="a1289925ae1c63a8e86f69f3657118a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1289925ae1c63a8e86f69f3657118a4d">&#9670;&nbsp;</a></span>LZMA_IGNORE_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_IGNORE_CHECK&#160;&#160;&#160;UINT32_C(0x10)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag makes lzma_code() not calculate and verify the integrity check of the compressed data in .xz files. This means that invalid integrity check values won't be detected and LZMA_DATA_ERROR won't be returned in such cases.</p>
<p>This flag only affects the checks of the compressed data itself; the CRC32 values in the .xz headers will still be verified normally.</p>
<p>Don't use this flag unless you know what you are doing. Possible reasons to use this flag:</p>
<ul>
<li>Trying to recover data from a corrupt .xz file.</li>
<li>Speeding up decompression, which matters mostly with SHA-256 or with files that have compressed extremely well. It's recommended to not use this flag for this purpose unless the file integrity is verified externally in some other way.</li>
</ul>
<p>Support for this flag was added in liblzma 5.1.4beta. </p>

</div>
</div>
<a id="af3ca20ff228b363a82515c1aee9e27bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ca20ff228b363a82515c1aee9e27bc">&#9670;&nbsp;</a></span>LZMA_PRESET_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_PRESET_DEFAULT&#160;&#160;&#160;UINT32_C(6)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default compression preset. </p>
<p>It's not straightforward to recommend a default preset, because in some cases keeping the resource usage relatively low is more important that getting the maximum compression ratio. </p>

</div>
</div>
<a id="af524fe9af5737820fdadcd40a2c26deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af524fe9af5737820fdadcd40a2c26deb">&#9670;&nbsp;</a></span>LZMA_PRESET_EXTREME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_PRESET_EXTREME&#160;&#160;&#160;(UINT32_C(1) &lt;&lt; 31)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extreme compression preset. </p>
<p>This flag modifies the preset to make the encoding significantly slower while improving the compression ratio only marginally. This is useful when you don't mind spending time to get as small result as possible.</p>
<p>This flag doesn't affect the memory usage requirements of the decoder (at least not significantly). The memory usage of the encoder may be increased a little but only at the lowest preset levels (0-3). </p>

</div>
</div>
<a id="a97e40265e355a21bd2465aaa5b85f03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e40265e355a21bd2465aaa5b85f03d">&#9670;&nbsp;</a></span>LZMA_PRESET_LEVEL_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_PRESET_LEVEL_MASK&#160;&#160;&#160;UINT32_C(0x1F)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask for preset level. </p>
<p>This is useful only if you need to extract the level from the preset variable. That should be rare. </p>

</div>
</div>
<a id="a0bdde702a77ff42b90a99c0bf4147b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bdde702a77ff42b90a99c0bf4147b6b">&#9670;&nbsp;</a></span>LZMA_TELL_ANY_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_TELL_ANY_CHECK&#160;&#160;&#160;UINT32_C(0x04)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag makes lzma_code() return LZMA_GET_CHECK as soon as the type of the integrity check is known. The type can then be got with lzma_get_check(). </p>

</div>
</div>
<a id="ada9cd20febb28b5ed6656de9184a86e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9cd20febb28b5ed6656de9184a86e9">&#9670;&nbsp;</a></span>LZMA_TELL_NO_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_TELL_NO_CHECK&#160;&#160;&#160;UINT32_C(0x01)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag makes lzma_code() return LZMA_NO_CHECK if the input stream being decoded has no integrity check. Note that when used with lzma_auto_decoder(), all .lzma files will trigger LZMA_NO_CHECK if LZMA_TELL_NO_CHECK is used. </p>

</div>
</div>
<a id="ae21fb746037c82735d40d428c462e078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21fb746037c82735d40d428c462e078">&#9670;&nbsp;</a></span>LZMA_TELL_UNSUPPORTED_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LZMA_TELL_UNSUPPORTED_CHECK&#160;&#160;&#160;UINT32_C(0x02)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag makes lzma_code() return LZMA_UNSUPPORTED_CHECK if the input stream has an integrity check, but the type of the integrity check is not supported by this liblzma version or build. Such files can still be decoded, but the integrity check cannot be verified. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa2e76e1bb8605cbbc0095de0f6588207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e76e1bb8605cbbc0095de0f6588207">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_8h.html#a8494e0457e1463d6d2b6836018d87b6e">lzma_ret</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize .xz Stream encoder using a preset number. </p>
<p>MicroLZMA decoder.</p>
<p>Single-call .xz Stream decoder.</p>
<p>Initialize .lz (lzip) decoder (a foreign file format)</p>
<p>Initialize .lzma decoder (legacy file format)</p>
<p>Decode .xz, .lzma, and .lz (lzip) files with autodetection.</p>
<p>Initialize multithreaded .xz Stream decoder.</p>
<p>Initialize .xz Stream decoder.</p>
<p>MicroLZMA encoder.</p>
<p>Single-call .xz Stream encoder.</p>
<p>Initialize .lzma encoder (legacy file format)</p>
<p>Initialize multithreaded .xz Stream encoder.</p>
<p>Initialize .xz Stream encoder using a custom filter chain.</p>
<p>Single-call .xz Stream encoding using a preset number.</p>
<p>This function is intended for those who just want to use the basic features of liblzma (that is, most developers out there).</p>
<p>If initialization fails (return value is not LZMA_OK), all the memory allocated for *strm by liblzma is always freed. Thus, there is no need to call lzma_end() after failed initialization.</p>
<p>If initialization succeeds, use lzma_code() to do the actual encoding. Valid values for 'action' (the second argument of lzma_code()) are LZMA_RUN, LZMA_SYNC_FLUSH, LZMA_FULL_FLUSH, and LZMA_FINISH. In future, there may be compression levels or flags that don't support LZMA_SYNC_FLUSH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">preset</td><td>Compression preset to use. A preset consist of level number and zero or more flags. Usually flags aren't used, so preset is simply a number [0, 9] which match the options -0 ... -9 of the xz command line tool. Additional flags can be set using bitwise-or with the preset level number, e.g. 6 | LZMA_PRESET_EXTREME. </td></tr>
    <tr><td class="paramname">check</td><td>Integrity check type to use. See <a class="el" href="check_8h.html" title="Integrity checks.">check.h</a> for available checks. The xz command line tool defaults to LZMA_CHECK_CRC64, which is a good choice if you are unsure. LZMA_CHECK_CRC32 is good too as long as the uncompressed file is not many gigabytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization succeeded. Use lzma_code() to encode your data.</li>
<li>LZMA_MEM_ERROR: Memory allocation failed.</li>
<li>LZMA_OPTIONS_ERROR: The given compression preset is not supported by this build of liblzma.</li>
<li>LZMA_UNSUPPORTED_CHECK: The given check type is not supported by this liblzma build.</li>
<li>LZMA_PROG_ERROR: One or more of the parameters have values that will never be valid. For example, strm == NULL.</li>
</ul>
</dd></dl>
<p>The maximum required output buffer size can be calculated with lzma_stream_buffer_bound().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">preset</td><td>Compression preset to use. See the description in lzma_easy_encoder(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">check</td><td>Type of the integrity check to calculate from uncompressed data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN. See filters.h for more information. </td></tr>
    <tr><td class="paramname">check</td><td>Type of the integrity check to calculate from uncompressed data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization was successful.</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This provides the functionality of lzma_easy_encoder() and lzma_stream_encoder() as a single function for multithreaded use.</p>
<p>The supported actions for lzma_code() are LZMA_RUN, LZMA_FULL_FLUSH, LZMA_FULL_BARRIER, and LZMA_FINISH. Support for LZMA_SYNC_FLUSH might be added in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">options</td><td>Pointer to multithreaded compression options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>The .lzma format is sometimes called the LZMA_Alone format, which is the reason for the name of this function. The .lzma format supports only the LZMA1 filter. There is no support for integrity checks like CRC32.</p>
<p>Use this function if and only if you need to create files readable by legacy LZMA tools such as LZMA Utils 4.32.x. Moving to the .xz format is strongly recommended.</p>
<p>The valid action values for lzma_code() are LZMA_RUN and LZMA_FINISH. No kind of flushing is supported, because the file format doesn't make it possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">options</td><td>Pointer to encoder options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN. See filters.h for more information. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">check</td><td>Type of the integrity check to calculate from uncompressed data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if encoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Encoding was successful.</li>
<li>LZMA_BUF_ERROR: Not enough output buffer space.</li>
<li>LZMA_UNSUPPORTED_CHECK</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>The MicroLZMA format is a raw LZMA stream whose first byte (always 0x00) has been replaced with bitwise-negation of the LZMA properties (lc/lp/pb). This encoding ensures that the first byte of MicroLZMA stream is never 0x00. There is no end of payload marker and thus the uncompressed size must be stored separately. For the best error detection the dictionary size should be stored separately as well but alternatively one may use the uncompressed size as the dictionary size when decoding.</p>
<p>With the MicroLZMA encoder, lzma_code() behaves slightly unusually. The action argument must be LZMA_FINISH and the return value will never be LZMA_OK. Thus the encoding is always done with a single lzma_code() after the initialization. The benefit of the combination of initialization function and lzma_code() is that memory allocations can be reused for better performance.</p>
<p>lzma_code() will try to encode as much input as is possible to fit into the given output buffer. If not all input can be encoded, the stream will be finished without encoding all the input. The caller must check both input and output buffer usage after lzma_code() (total_in and total_out in <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> can be convenient). Often lzma_code() can fill the output buffer completely if there is a lot of input, but sometimes a few bytes may remain unused because the next LZMA symbol would require more space.</p>
<p><a class="el" href="structlzma__stream.html#a5ff28ea4e39148723c19f59811627904">lzma_stream.avail_out</a> must be at least 6. Otherwise LZMA_PROG_ERROR will be returned.</p>
<p>The LZMA dictionary should be reasonably low to speed up the encoder re-initialization. A good value is bigger than the resulting uncompressed size of most of the output chunks. For example, if output size is 4 KiB, dictionary size of 32 KiB or 64 KiB is good. If the data compresses extremely well, even 128 KiB may be useful.</p>
<p>The MicroLZMA format and this encoder variant were made with the EROFS file system in mind. This format may be convenient in other embedded uses too where many small streams are needed. XZ Embedded includes a decoder for this format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">options</td><td>Pointer to encoder options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_STREAM_END: All good. Check the amounts of input used and output produced. Store the amount of input used (uncompressed size) as it needs to be known to decompress the data.</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR: In addition to the generic reasons for this error code, this may also be returned if there isn't enough output space (6 bytes) to create a valid MicroLZMA stream.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">memlimit</td><td>Memory usage limit as bytes. Use UINT64_MAX to effectively disable the limiter. liblzma 5.2.3 and earlier don't allow 0 here and return LZMA_PROG_ERROR; later versions treat 0 as if 1 had been specified. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitwise-or of zero or more of the decoder flags: LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK, LZMA_TELL_ANY_CHECK, LZMA_IGNORE_CHECK, LZMA_CONCATENATED, LZMA_FAIL_FAST</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization was successful.</li>
<li>LZMA_MEM_ERROR: Cannot allocate memory.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported flags</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>The decoder can decode multiple Blocks in parallel. This requires that each Block Header contains the Compressed Size and Uncompressed size fields which are added by the multi-threaded encoder, see lzma_stream_encoder_mt().</p>
<p>A Stream with one Block will only utilize one thread. A Stream with multiple Blocks but without size information in Block Headers will be processed in single-threaded mode in the same way as done by lzma_stream_decoder(). Concatenated Streams are processed one Stream at a time; no inter-Stream parallelization is done.</p>
<p>This function behaves like lzma_stream_decoder() when options-&gt;threads == 1 and options-&gt;memlimit_threading &lt;= 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">options</td><td>Pointer to multithreaded compression options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization was successful.</li>
<li>LZMA_MEM_ERROR: Cannot allocate memory.</li>
<li>LZMA_MEMLIMIT_ERROR: Memory usage limit was reached.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported flags.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This decoder autodetects between the .xz, .lzma, and .lz file formats, and calls lzma_stream_decoder(), lzma_alone_decoder(), or lzma_lzip_decoder() once the type of the input file has been detected.</p>
<p>Support for .lz was added in 5.4.0.</p>
<p>If the flag LZMA_CONCATENATED is used and the input is a .lzma file: For historical reasons concatenated .lzma files aren't supported. If there is trailing data after one .lzma stream, lzma_code() will return LZMA_DATA_ERROR. (lzma_alone_decoder() doesn't have such a check as it doesn't support any decoder flags. It will return LZMA_STREAM_END after one .lzma stream.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">memlimit</td><td>Memory usage limit as bytes. Use UINT64_MAX to effectively disable the limiter. liblzma 5.2.3 and earlier don't allow 0 here and return LZMA_PROG_ERROR; later versions treat 0 as if 1 had been specified. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitwise-or of zero or more of the decoder flags: LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK, LZMA_TELL_ANY_CHECK, LZMA_IGNORE_CHECK, LZMA_CONCATENATED, LZMA_FAIL_FAST</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization was successful.</li>
<li>LZMA_MEM_ERROR: Cannot allocate memory.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported flags</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>Valid 'action' arguments to lzma_code() are LZMA_RUN and LZMA_FINISH. There is no need to use LZMA_FINISH, but it's allowed because it may simplify certain types of applications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">memlimit</td><td>Memory usage limit as bytes. Use UINT64_MAX to effectively disable the limiter. liblzma 5.2.3 and earlier don't allow 0 here and return LZMA_PROG_ERROR; later versions treat 0 as if 1 had been specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>This decoder supports the .lz format version 0 and the unextended .lz format version 1:</p>
<ul>
<li>Files in the format version 0 were produced by lzip 1.3 and older. Such files aren't common but may be found from file archives as a few source packages were released in this format. People might have old personal files in this format too. Decompression support for the format version 0 was removed in lzip 1.18.</li>
<li>lzip 1.3 added decompression support for .lz format version 1 files. Compression support was added in lzip 1.4. In lzip 1.6 the .lz format version 1 was extended to support the Sync Flush marker. This extension is not supported by liblzma. lzma_code() will return LZMA_DATA_ERROR at the location of the Sync Flush marker. In practice files with the Sync Flush marker are very rare and thus liblzma can decompress almost all .lz files.</li>
</ul>
<p>Just like with lzma_stream_decoder() for .xz files, LZMA_CONCATENATED should be used when decompressing normal standalone .lz files.</p>
<p>The .lz format allows putting non-.lz data at the end of a file after at least one valid .lz member. That is, one can append custom data at the end of a .lz file and the decoder is required to ignore it. In liblzma this is relevant only when LZMA_CONCATENATED is used. In that case lzma_code() will return LZMA_STREAM_END and leave <a class="el" href="structlzma__stream.html#a72fdc738c793f07a5c29715aa57802cf">lzma_stream.next_in</a> pointing to the first byte of the non-.lz data. An exception to this is if the first 1-3 bytes of the non-.lz data are identical to the .lz magic bytes (0x4C, 0x5A, 0x49, 0x50; "LZIP" in US-ASCII). In such a case the 1-3 bytes will have been ignored by lzma_code(). If one wishes to locate the non-.lz data reliably, one must ensure that the first byte isn't 0x4C. Actually one should ensure that none of the first four bytes of trailing data are equal to the magic bytes because lzip &gt;= 1.20 requires it by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">memlimit</td><td>Memory usage limit as bytes. Use UINT64_MAX to effectively disable the limiter. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitwise-or of flags, or zero for no flags. All decoder flags listed above are supported although only LZMA_CONCATENATED and (in very rare cases) LZMA_IGNORE_CHECK are actually useful. LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK, and LZMA_FAIL_FAST do nothing. LZMA_TELL_ANY_CHECK is supported for consistency only as CRC32 is always used in the .lz format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Initialization was successful.</li>
<li>LZMA_MEM_ERROR: Cannot allocate memory.</li>
<li>LZMA_OPTIONS_ERROR: Unsupported flags</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">memlimit</td><td>Pointer to how much memory the decoder is allowed to allocate. The value pointed by this pointer is modified if and only if LZMA_MEMLIMIT_ERROR is returned. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>Bitwise-or of zero or more of the decoder flags: LZMA_TELL_NO_CHECK, LZMA_TELL_UNSUPPORTED_CHECK, LZMA_IGNORE_CHECK, LZMA_CONCATENATED, LZMA_FAIL_FAST. Note that LZMA_TELL_ANY_CHECK is not allowed and will return LZMA_PROG_ERROR. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td><a class="el" href="structlzma__allocator.html" title="Custom functions for memory handling.">lzma_allocator</a> for custom allocator functions. Set to NULL to use malloc() and free(). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>Beginning of the input buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_pos</td><td>The next byte will be read from in[*in_pos]. *in_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_size</td><td>Size of the input buffer; the first byte that won't be read is in[in_size]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Beginning of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_pos</td><td>The next byte will be written to out[*out_pos]. *out_pos is updated only if decoding succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_size</td><td>Size of the out buffer; the first byte into which no data is written to is out[out_size].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK: Decoding was successful.</li>
<li>LZMA_FORMAT_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_DATA_ERROR</li>
<li>LZMA_NO_CHECK: This can be returned only if using the LZMA_TELL_NO_CHECK flag.</li>
<li>LZMA_UNSUPPORTED_CHECK: This can be returned only if using the LZMA_TELL_UNSUPPORTED_CHECK flag.</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_MEMLIMIT_ERROR: Memory usage limit was reached. The minimum required memlimit value was stored to *memlimit.</li>
<li>LZMA_BUF_ERROR: Output buffer was too small.</li>
<li>LZMA_PROG_ERROR</li>
</ul>
</dd></dl>
<p>See lzma_microlzma_encoder() for more information.</p>
<p>The lzma_code() usage with this decoder is completely normal. The special behavior of lzma_code() applies to lzma_microlzma_encoder() only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>Pointer to <a class="el" href="structlzma__stream.html" title="Passing data to and from liblzma.">lzma_stream</a> that is at least initialized with LZMA_STREAM_INIT. </td></tr>
    <tr><td class="paramname">comp_size</td><td>Compressed size of the MicroLZMA stream. The caller must somehow know this exactly. </td></tr>
    <tr><td class="paramname">uncomp_size</td><td>Uncompressed size of the MicroLZMA stream. If the exact uncompressed size isn't known, this can be set to a value that is at most as big as the exact uncompressed size would be, but then the next argument uncomp_size_is_exact must be false. </td></tr>
    <tr><td class="paramname">uncomp_size_is_exact</td><td>If true, uncomp_size must be exactly correct. This will improve error detection at the end of the stream. If the exact uncompressed size isn't known, this must be false. uncomp_size must still be at most as big as the exact uncompressed size is. Setting this to false when the exact size is known will work but error detection at the end of the stream will be weaker. </td></tr>
    <tr><td class="paramname">dict_size</td><td>LZMA dictionary size that was used when compressing the data. It is OK to use a bigger value too but liblzma will then allocate more memory than would actually be required and error detection will be slightly worse. (Note that with the implementation in XZ Embedded it doesn't affect the memory usage if one specifies bigger dictionary than actually required.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible lzma_ret values:<ul>
<li>LZMA_OK</li>
<li>LZMA_MEM_ERROR</li>
<li>LZMA_OPTIONS_ERROR</li>
<li>LZMA_PROG_ERROR </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8746ae92120a60ff31ee568789365dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8746ae92120a60ff31ee568789365dac">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate output buffer size for single-call Stream encoder. </p>
<p>When trying to compress incompressible data, the encoded size will be slightly bigger than the input data. This function calculates how much output buffer space is required to be sure that lzma_stream_buffer_encode() doesn't return LZMA_BUF_ERROR.</p>
<p>The calculated value is not exact, but it is guaranteed to be big enough. The actual maximum output space required may be slightly smaller (up to about 100 bytes). This should not be a problem in practice.</p>
<p>If the calculated maximum size doesn't fit into size_t or would make the Stream grow past LZMA_VLI_MAX (which should never happen in practice), zero is returned to indicate the error.</p>
<dl class="section note"><dt>Note</dt><dd>The limit calculated by this function applies only to single-call encoding. Multi-call encoding may (and probably will) have larger maximum expansion when encoding incompressible data. Currently there is no function to calculate the maximum expansion of multi-call encoding.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uncompressed_size</td><td>Size in bytes of the uncompressed input data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of bytes needed to store the compressed data.</dd></dl>
<p>Calculate output buffer size for single-call Stream encoder.</p>
<p>Calculate maximum output size for single-call Block encoding.</p>
<p>Raw x86 BCJ decoder.</p>
<p>Raw x86 BCJ encoder.</p>
<p>Raw RISC-V BCJ decoder.</p>
<p>Raw RISC-V BCJ encoder.</p>
<p>Raw ARM64 BCJ decoder.</p>
<p>This is for special use cases only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_offset</td><td>The lowest 32 bits of the offset in the executable being filtered. For the ARM64 filter, this must be a multiple of four. For the very best results, this should also be in sync with 4096-byte page boundaries in the executable due to how ARM64's ADRP instruction works. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer to be filtered in place </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes that were processed in <code>buf</code>. This is at most <code>size</code>. With the ARM64 filter, the return value is always a multiple of 4, and at most 3 bytes are left unfiltered.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>5.7.1alpha</dd></dl>
<p>See lzma_bcj_arm64_encode().</p>
<dl class="section since"><dt>Since</dt><dd>5.7.1alpha</dd></dl>
<p>This is for special use cases only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_offset</td><td>The lowest 32 bits of the offset in the executable being filtered. For the RISC-V filter, this must be a multiple of 2. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer to be filtered in place </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes that were processed in <code>buf</code>. This is at most <code>size</code>. With the RISC-V filter, the return value is always a multiple of 2, and at most 7 bytes are left unfiltered.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>5.7.1alpha</dd></dl>
<p>See lzma_bcj_riscv_encode().</p>
<dl class="section since"><dt>Since</dt><dd>5.7.1alpha</dd></dl>
<p>This is for special use cases only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_offset</td><td>The lowest 32 bits of the offset in the executable being filtered. For the x86 filter, all values are valid. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer to be filtered in place </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes that were processed in <code>buf</code>. This is at most <code>size</code>. For the x86 filter, the return value is always a multiple of 1, and at most 4 bytes are left unfiltered.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>5.7.1alpha</dd></dl>
<p>See lzma_bcj_x86_encode().</p>
<dl class="section since"><dt>Since</dt><dd>5.7.1alpha </dd></dl>

</div>
</div>
<a id="a83def1b1258ada2f9e779d079181fef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83def1b1258ada2f9e779d079181fef7">&#9670;&nbsp;</a></span>LZMA_API() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LZMA_API </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate approximate memory usage of easy encoder. </p>
<p>Calculate recommended Block size for multithreaded .xz encoder.</p>
<p>Calculate approximate memory usage of multithreaded .xz encoder.</p>
<p>Calculate approximate decoder memory usage of a preset.</p>
<p>This function is a wrapper for lzma_raw_encoder_memusage().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preset</td><td>Compression preset (level and possible flags)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of memory required for the given preset when encoding or UINT64_MAX on error.</dd></dl>
<p>This function is a wrapper for lzma_raw_decoder_memusage().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preset</td><td>Compression preset (level and possible flags)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of memory required to decompress a file that was compressed using the given preset or UINT64_MAX on error.</dd></dl>
<p>Since doing the encoding in threaded mode doesn't affect the memory requirements of single-threaded decompressor, you can use lzma_easy_decoder_memusage(options-&gt;preset) or lzma_raw_decoder_memusage(options-&gt;filters) to calculate the decompressor memory requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Compression options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes of memory required for encoding with the given options. If an error occurs, for example due to unsupported preset or filter chain, UINT64_MAX is returned.</dd></dl>
<p>This calculates a recommended Block size for multithreaded encoding given a filter chain. This is used internally by lzma_stream_encoder_mt() to determine the Block size if the block_size member is not set to the special value of 0 in the <a class="el" href="structlzma__mt.html" title="Multithreading options.">lzma_mt</a> options struct.</p>
<p>If one wishes to change the filters between Blocks, this function is helpful to set the block_size member of the <a class="el" href="structlzma__mt.html" title="Multithreading options.">lzma_mt</a> struct before calling lzma_stream_encoder_mt(). Since the block_size member represents the maximum possible Block size for the multithreaded .xz encoder, one can use this function to find the maximum recommended Block size based on all planned filter chains. Otherwise, the multithreaded encoder will base its maximum Block size on the first filter chain used (if the block_size member is not set), which may unnecessarily limit the Block size for a later filter chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filters</td><td>Array of filters terminated with .id == LZMA_VLI_UNKNOWN.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Recommended Block size in bytes, or UINT64_MAX if an error occurred.</dd></dl>
<p>Calculate approximate memory usage of easy encoder.</p>
<p>Get the uncompressed size of the file.</p>
<p>Get the total size of the file.</p>
<p>Get the total size of the Blocks.</p>
<p>Get the total size of the Stream.</p>
<p>Get the size of the Index field as bytes.</p>
<p>Get the number of Blocks.</p>
<p>Get the number of Streams.</p>
<p>Calculate the memory usage of an existing lzma_index.</p>
<p>On disk, the size of the Index field depends on both the number of Records stored and the size of the Records (due to variable-length integer encoding). When the Index is kept in lzma_index structure, the memory usage depends only on the number of Records/Blocks stored in the Index(es), and in case of concatenated lzma_indexes, the number of Streams. The size in RAM is almost always significantly bigger than in the encoded form on disk.</p>
<p>This function calculates an approximate amount of memory needed to hold the given number of Streams and Blocks in lzma_index structure. This value may vary between CPU architectures and also between liblzma versions if the internal implementation is modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streams</td><td>Number of Streams </td></tr>
    <tr><td class="paramname">blocks</td><td>Number of Blocks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximate memory in bytes needed in a lzma_index structure.</dd></dl>
<p>This is a shorthand for lzma_index_memusage(lzma_index_stream_count(i), lzma_index_block_count(i)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximate memory in bytes used by the lzma_index structure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of Streams in the lzma_index</dd></dl>
<p>This returns the total number of Blocks in lzma_index. To get number of Blocks in individual Streams, use <a class="el" href="structlzma__index__iter.html" title="Iterator to get information about Blocks and Streams.">lzma_index_iter</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of blocks in the lzma_index</dd></dl>
<p>This is needed to verify the Backward Size field in the Stream Footer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the Index</dd></dl>
<p>If multiple lzma_indexes have been combined, this works as if the Blocks were in a single Stream. This is useful if you are going to combine Blocks from multiple Streams into a single new Stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the Stream (if all Blocks are combined into one Stream).</dd></dl>
<p>This doesn't include the Stream Header, Stream Footer, Stream Padding, or Index fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of all Blocks in the Stream(s)</dd></dl>
<p>When no lzma_indexes have been combined with lzma_index_cat() and there is no Stream Padding, this function is identical to lzma_index_stream_size(). If multiple lzma_indexes have been combined, this includes also the headers of each separate Stream and the possible Stream Padding fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total size of the .xz file in bytes</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Pointer to lzma_index structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the uncompressed data in the file </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
